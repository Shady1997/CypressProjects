(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~ctChunk-reactdevtools"],{

/***/ "../../node_modules/react-devtools-inline/backend.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("../../node_modules/react-devtools-inline/dist/backend.js");


/***/ }),

/***/ "../../node_modules/react-devtools-inline/dist/backend.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 161);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports) {

module.exports = __webpack_require__("../../node_modules/react/index.js");

/***/ }),

/***/ 1:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return ElementTypeClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return ElementTypeContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return ElementTypeFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return ElementTypeForwardRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return ElementTypeHostComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return ElementTypeMemo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return ElementTypeOtherOrUnknown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return ElementTypeProfiler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return ElementTypeRoot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return ElementTypeSuspense; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return ElementTypeSuspenseList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ComponentFilterElementType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ComponentFilterDisplayName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return ComponentFilterLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ComponentFilterHOC; });
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// WARNING
// The values below are referenced by ComponentFilters (which are saved via localStorage).
// Do not change them or it will break previously saved user customizations.
// If new element types are added, use new numbers rather than re-ordering existing ones.
//
// Changing these types is also a backwards breaking change for the standalone shell,
// since the frontend and backend must share the same values-
// and the backend is embedded in certain environments (like React Native).
const ElementTypeClass = 1;
const ElementTypeContext = 2;
const ElementTypeFunction = 5;
const ElementTypeForwardRef = 6;
const ElementTypeHostComponent = 7;
const ElementTypeMemo = 8;
const ElementTypeOtherOrUnknown = 9;
const ElementTypeProfiler = 10;
const ElementTypeRoot = 11;
const ElementTypeSuspense = 12;
const ElementTypeSuspenseList = 13; // Different types of elements displayed in the Elements tree.
// These types may be used to visually distinguish types,
// or to enable/disable certain functionality.

// WARNING
// The values below are referenced by ComponentFilters (which are saved via localStorage).
// Do not change them or it will break previously saved user customizations.
// If new filter types are added, use new numbers rather than re-ordering existing ones.
const ComponentFilterElementType = 1;
const ComponentFilterDisplayName = 2;
const ComponentFilterLocation = 3;
const ComponentFilterHOC = 4;

/***/ }),

/***/ 161:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "activate", function() { return /* binding */ activate; });
__webpack_require__.d(__webpack_exports__, "initialize", function() { return /* binding */ backend_initialize; });

// EXTERNAL MODULE: ../react-devtools-shared/src/events.js
var events = __webpack_require__(25);

// EXTERNAL MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/lodash.throttle/index.js
var lodash_throttle = __webpack_require__(36);
var lodash_throttle_default = /*#__PURE__*/__webpack_require__.n(lodash_throttle);

// EXTERNAL MODULE: ../react-devtools-shared/src/constants.js
var constants = __webpack_require__(3);

// EXTERNAL MODULE: ../react-devtools-shared/src/storage.js
var storage = __webpack_require__(7);

// EXTERNAL MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/memoize-one/esm/index.js
var esm = __webpack_require__(28);

// EXTERNAL MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/object-assign/index.js
var object_assign = __webpack_require__(30);
var object_assign_default = /*#__PURE__*/__webpack_require__.n(object_assign);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/utils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// Get the window object for the document that a node belongs to,
// or return null if it cannot be found (node not attached to DOM,
// etc).
function getOwnerWindow(node) {
  if (!node.ownerDocument) {
    return null;
  }

  return node.ownerDocument.defaultView;
} // Get the iframe containing a node, or return null if it cannot
// be found (node not within iframe, etc).

function getOwnerIframe(node) {
  const nodeWindow = getOwnerWindow(node);

  if (nodeWindow) {
    return nodeWindow.frameElement;
  }

  return null;
} // Get a bounding client rect for a node, with an
// offset added to compensate for its border.

function getBoundingClientRectWithBorderOffset(node) {
  const dimensions = getElementDimensions(node);
  return mergeRectOffsets([node.getBoundingClientRect(), {
    top: dimensions.borderTop,
    left: dimensions.borderLeft,
    bottom: dimensions.borderBottom,
    right: dimensions.borderRight,
    // This width and height won't get used by mergeRectOffsets (since this
    // is not the first rect in the array), but we set them so that this
    // object typechecks as a ClientRect.
    width: 0,
    height: 0
  }]);
} // Add together the top, left, bottom, and right properties of
// each ClientRect, but keep the width and height of the first one.

function mergeRectOffsets(rects) {
  return rects.reduce((previousRect, rect) => {
    if (previousRect == null) {
      return rect;
    }

    return {
      top: previousRect.top + rect.top,
      left: previousRect.left + rect.left,
      width: previousRect.width,
      height: previousRect.height,
      bottom: previousRect.bottom + rect.bottom,
      right: previousRect.right + rect.right
    };
  });
} // Calculate a boundingClientRect for a node relative to boundaryWindow,
// taking into account any offsets caused by intermediate iframes.

function getNestedBoundingClientRect(node, boundaryWindow) {
  const ownerIframe = getOwnerIframe(node);

  if (ownerIframe && ownerIframe !== boundaryWindow) {
    const rects = [node.getBoundingClientRect()];
    let currentIframe = ownerIframe;
    let onlyOneMore = false;

    while (currentIframe) {
      const rect = getBoundingClientRectWithBorderOffset(currentIframe);
      rects.push(rect);
      currentIframe = getOwnerIframe(currentIframe);

      if (onlyOneMore) {
        break;
      } // We don't want to calculate iframe offsets upwards beyond
      // the iframe containing the boundaryWindow, but we
      // need to calculate the offset relative to the boundaryWindow.


      if (currentIframe && getOwnerWindow(currentIframe) === boundaryWindow) {
        onlyOneMore = true;
      }
    }

    return mergeRectOffsets(rects);
  } else {
    return node.getBoundingClientRect();
  }
}
function getElementDimensions(domElement) {
  const calculatedStyle = window.getComputedStyle(domElement);
  return {
    borderLeft: parseInt(calculatedStyle.borderLeftWidth, 10),
    borderRight: parseInt(calculatedStyle.borderRightWidth, 10),
    borderTop: parseInt(calculatedStyle.borderTopWidth, 10),
    borderBottom: parseInt(calculatedStyle.borderBottomWidth, 10),
    marginLeft: parseInt(calculatedStyle.marginLeft, 10),
    marginRight: parseInt(calculatedStyle.marginRight, 10),
    marginTop: parseInt(calculatedStyle.marginTop, 10),
    marginBottom: parseInt(calculatedStyle.marginBottom, 10),
    paddingLeft: parseInt(calculatedStyle.paddingLeft, 10),
    paddingRight: parseInt(calculatedStyle.paddingRight, 10),
    paddingTop: parseInt(calculatedStyle.paddingTop, 10),
    paddingBottom: parseInt(calculatedStyle.paddingBottom, 10)
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/Overlay.js
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



// Note that the Overlay components are not affected by the active Theme,
// because they highlight elements in the main Chrome window (outside of devtools).
// The colors below were chosen to roughly match those used by Chrome devtools.
class Overlay_OverlayRect {
  constructor(doc, container) {
    this.node = doc.createElement('div');
    this.border = doc.createElement('div');
    this.padding = doc.createElement('div');
    this.content = doc.createElement('div');
    this.border.style.borderColor = overlayStyles.border;
    this.padding.style.borderColor = overlayStyles.padding;
    this.content.style.backgroundColor = overlayStyles.background;
    object_assign_default()(this.node.style, {
      borderColor: overlayStyles.margin,
      pointerEvents: 'none',
      position: 'fixed'
    });
    this.node.style.zIndex = '10000000';
    this.node.appendChild(this.border);
    this.border.appendChild(this.padding);
    this.padding.appendChild(this.content);
    container.appendChild(this.node);
  }

  remove() {
    if (this.node.parentNode) {
      this.node.parentNode.removeChild(this.node);
    }
  }

  update(box, dims) {
    boxWrap(dims, 'margin', this.node);
    boxWrap(dims, 'border', this.border);
    boxWrap(dims, 'padding', this.padding);
    object_assign_default()(this.content.style, {
      height: box.height - dims.borderTop - dims.borderBottom - dims.paddingTop - dims.paddingBottom + 'px',
      width: box.width - dims.borderLeft - dims.borderRight - dims.paddingLeft - dims.paddingRight + 'px'
    });
    object_assign_default()(this.node.style, {
      top: box.top - dims.marginTop + 'px',
      left: box.left - dims.marginLeft + 'px'
    });
  }

}

class Overlay_OverlayTip {
  constructor(doc, container) {
    this.tip = doc.createElement('div');
    object_assign_default()(this.tip.style, {
      display: 'flex',
      flexFlow: 'row nowrap',
      backgroundColor: '#333740',
      borderRadius: '2px',
      fontFamily: '"SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace',
      fontWeight: 'bold',
      padding: '3px 5px',
      pointerEvents: 'none',
      position: 'fixed',
      fontSize: '12px',
      whiteSpace: 'nowrap'
    });
    this.nameSpan = doc.createElement('span');
    this.tip.appendChild(this.nameSpan);
    object_assign_default()(this.nameSpan.style, {
      color: '#ee78e6',
      borderRight: '1px solid #aaaaaa',
      paddingRight: '0.5rem',
      marginRight: '0.5rem'
    });
    this.dimSpan = doc.createElement('span');
    this.tip.appendChild(this.dimSpan);
    object_assign_default()(this.dimSpan.style, {
      color: '#d7d7d7'
    });
    this.tip.style.zIndex = '10000000';
    container.appendChild(this.tip);
  }

  remove() {
    if (this.tip.parentNode) {
      this.tip.parentNode.removeChild(this.tip);
    }
  }

  updateText(name, width, height) {
    this.nameSpan.textContent = name;
    this.dimSpan.textContent = Math.round(width) + 'px Ã— ' + Math.round(height) + 'px';
  }

  updatePosition(dims, bounds) {
    const tipRect = this.tip.getBoundingClientRect();
    const tipPos = findTipPos(dims, bounds, {
      width: tipRect.width,
      height: tipRect.height
    });
    object_assign_default()(this.tip.style, tipPos.style);
  }

}

class Overlay_Overlay {
  constructor() {
    // Find the root window, because overlays are positioned relative to it.
    const currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
    this.window = currentWindow; // When opened in shells/dev, the tooltip should be bound by the app iframe, not by the topmost window.

    const tipBoundsWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
    this.tipBoundsWindow = tipBoundsWindow;
    const doc = currentWindow.document;
    this.container = doc.createElement('div');
    this.container.style.zIndex = '10000000';
    this.tip = new Overlay_OverlayTip(doc, this.container);
    this.rects = [];
    doc.body.appendChild(this.container);
  }

  remove() {
    this.tip.remove();
    this.rects.forEach(rect => {
      rect.remove();
    });
    this.rects.length = 0;

    if (this.container.parentNode) {
      this.container.parentNode.removeChild(this.container);
    }
  }

  inspect(nodes, name) {
    // We can't get the size of text nodes or comment nodes. React as of v15
    // heavily uses comment nodes to delimit text.
    const elements = nodes.filter(node => node.nodeType === Node.ELEMENT_NODE);

    while (this.rects.length > elements.length) {
      const rect = this.rects.pop();
      rect.remove();
    }

    if (elements.length === 0) {
      return;
    }

    while (this.rects.length < elements.length) {
      this.rects.push(new Overlay_OverlayRect(this.window.document, this.container));
    }

    const outerBox = {
      top: Number.POSITIVE_INFINITY,
      right: Number.NEGATIVE_INFINITY,
      bottom: Number.NEGATIVE_INFINITY,
      left: Number.POSITIVE_INFINITY
    };
    elements.forEach((element, index) => {
      const box = getNestedBoundingClientRect(element, this.window);
      const dims = getElementDimensions(element);
      outerBox.top = Math.min(outerBox.top, box.top - dims.marginTop);
      outerBox.right = Math.max(outerBox.right, box.left + box.width + dims.marginRight);
      outerBox.bottom = Math.max(outerBox.bottom, box.top + box.height + dims.marginBottom);
      outerBox.left = Math.min(outerBox.left, box.left - dims.marginLeft);
      const rect = this.rects[index];
      rect.update(box, dims);
    });

    if (!name) {
      name = elements[0].nodeName.toLowerCase();
      const node = elements[0];
      const hook = node.ownerDocument.defaultView.__REACT_DEVTOOLS_GLOBAL_HOOK__;

      if (hook != null && hook.rendererInterfaces != null) {
        let ownerName = null; // eslint-disable-next-line no-for-of-loops/no-for-of-loops

        var _iterator = _createForOfIteratorHelper(hook.rendererInterfaces.values()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            const rendererInterface = _step.value;
            const id = rendererInterface.getFiberIDForNative(node, true);

            if (id !== null) {
              ownerName = rendererInterface.getDisplayNameForFiberID(id, true);
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (ownerName) {
          name += ' (in ' + ownerName + ')';
        }
      }
    }

    this.tip.updateText(name, outerBox.right - outerBox.left, outerBox.bottom - outerBox.top);
    const tipBounds = getNestedBoundingClientRect(this.tipBoundsWindow.document.documentElement, this.window);
    this.tip.updatePosition({
      top: outerBox.top,
      left: outerBox.left,
      height: outerBox.bottom - outerBox.top,
      width: outerBox.right - outerBox.left
    }, {
      top: tipBounds.top + this.tipBoundsWindow.scrollY,
      left: tipBounds.left + this.tipBoundsWindow.scrollX,
      height: this.tipBoundsWindow.innerHeight,
      width: this.tipBoundsWindow.innerWidth
    });
  }

}

function findTipPos(dims, bounds, tipSize) {
  const tipHeight = Math.max(tipSize.height, 20);
  const tipWidth = Math.max(tipSize.width, 60);
  const margin = 5;
  let top;

  if (dims.top + dims.height + tipHeight <= bounds.top + bounds.height) {
    if (dims.top + dims.height < bounds.top + 0) {
      top = bounds.top + margin;
    } else {
      top = dims.top + dims.height + margin;
    }
  } else if (dims.top - tipHeight <= bounds.top + bounds.height) {
    if (dims.top - tipHeight - margin < bounds.top + margin) {
      top = bounds.top + margin;
    } else {
      top = dims.top - tipHeight - margin;
    }
  } else {
    top = bounds.top + bounds.height - tipHeight - margin;
  }

  let left = dims.left + margin;

  if (dims.left < bounds.left) {
    left = bounds.left + margin;
  }

  if (dims.left + tipWidth > bounds.left + bounds.width) {
    left = bounds.left + bounds.width - tipWidth - margin;
  }

  top += 'px';
  left += 'px';
  return {
    style: {
      top,
      left
    }
  };
}

function boxWrap(dims, what, node) {
  object_assign_default()(node.style, {
    borderTopWidth: dims[what + 'Top'] + 'px',
    borderLeftWidth: dims[what + 'Left'] + 'px',
    borderRightWidth: dims[what + 'Right'] + 'px',
    borderBottomWidth: dims[what + 'Bottom'] + 'px',
    borderStyle: 'solid'
  });
}

const overlayStyles = {
  background: 'rgba(120, 170, 210, 0.7)',
  padding: 'rgba(77, 200, 0, 0.3)',
  margin: 'rgba(255, 155, 0, 0.3)',
  border: 'rgba(255, 200, 50, 0.3)'
};
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/Highlighter.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

const SHOW_DURATION = 2000;
let timeoutID = null;
let overlay = null;
function hideOverlay() {
  timeoutID = null;

  if (overlay !== null) {
    overlay.remove();
    overlay = null;
  }
}
function showOverlay(elements, componentName, hideAfterTimeout) {
  // TODO (npm-packages) Detect RN and support it somehow
  if (window.document == null) {
    return;
  }

  if (timeoutID !== null) {
    clearTimeout(timeoutID);
  }

  if (elements == null) {
    return;
  }

  if (overlay === null) {
    overlay = new Overlay_Overlay();
  }

  overlay.inspect(elements, componentName);

  if (hideAfterTimeout) {
    timeoutID = setTimeout(hideOverlay, SHOW_DURATION);
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */




// This plug-in provides in-page highlighting of the selected element.
// It is used by the browser extension nad the standalone DevTools shell (when connected to a browser).
// It is not currently the mechanism used to highlight React Native views.
// That is done by the React Native Inspector component.
let iframesListeningTo = new Set();
function setupHighlighter(bridge, agent) {
  bridge.addListener('clearNativeElementHighlight', clearNativeElementHighlight);
  bridge.addListener('highlightNativeElement', highlightNativeElement);
  bridge.addListener('shutdown', stopInspectingNative);
  bridge.addListener('startInspectingNative', startInspectingNative);
  bridge.addListener('stopInspectingNative', stopInspectingNative);

  function startInspectingNative() {
    registerListenersOnWindow(window);
  }

  function registerListenersOnWindow(window) {
    // This plug-in may run in non-DOM environments (e.g. React Native).
    if (window && typeof window.addEventListener === 'function') {
      window.addEventListener('click', onClick, true);
      window.addEventListener('mousedown', onMouseEvent, true);
      window.addEventListener('mouseover', onMouseEvent, true);
      window.addEventListener('mouseup', onMouseEvent, true);
      window.addEventListener('pointerdown', onPointerDown, true);
      window.addEventListener('pointerover', onPointerOver, true);
      window.addEventListener('pointerup', onPointerUp, true);
    }
  }

  function stopInspectingNative() {
    hideOverlay();
    removeListenersOnWindow(window);
    iframesListeningTo.forEach(function (frame) {
      try {
        removeListenersOnWindow(frame.contentWindow);
      } catch (error) {// This can error when the iframe is on a cross-origin.
      }
    });
    iframesListeningTo = new Set();
  }

  function removeListenersOnWindow(window) {
    // This plug-in may run in non-DOM environments (e.g. React Native).
    if (window && typeof window.removeEventListener === 'function') {
      window.removeEventListener('click', onClick, true);
      window.removeEventListener('mousedown', onMouseEvent, true);
      window.removeEventListener('mouseover', onMouseEvent, true);
      window.removeEventListener('mouseup', onMouseEvent, true);
      window.removeEventListener('pointerdown', onPointerDown, true);
      window.removeEventListener('pointerover', onPointerOver, true);
      window.removeEventListener('pointerup', onPointerUp, true);
    }
  }

  function clearNativeElementHighlight() {
    hideOverlay();
  }

  function highlightNativeElement({
    displayName,
    hideAfterTimeout,
    id,
    openNativeElementsPanel,
    rendererID,
    scrollIntoView
  }) {
    const renderer = agent.rendererInterfaces[rendererID];

    if (renderer == null) {
      console.warn(`Invalid renderer id "${rendererID}" for element "${id}"`);
    }

    let nodes = null;

    if (renderer != null) {
      nodes = renderer.findNativeNodesForFiberID(id);
    }

    if (nodes != null && nodes[0] != null) {
      const node = nodes[0];

      if (scrollIntoView && typeof node.scrollIntoView === 'function') {
        // If the node isn't visible show it before highlighting it.
        // We may want to reconsider this; it might be a little disruptive.
        // $FlowFixMe Flow only knows about 'start' | 'end'
        node.scrollIntoView({
          block: 'nearest',
          inline: 'nearest'
        });
      }

      showOverlay(nodes, displayName, hideAfterTimeout);

      if (openNativeElementsPanel) {
        window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0 = node;
        bridge.send('syncSelectionToNativeElementsPanel');
      }
    } else {
      hideOverlay();
    }
  }

  function onClick(event) {
    event.preventDefault();
    event.stopPropagation();
    stopInspectingNative();
    bridge.send('stopInspectingNative', true);
  }

  function onMouseEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  function onPointerDown(event) {
    event.preventDefault();
    event.stopPropagation();
    selectFiberForNode(event.target);
  }

  function onPointerOver(event) {
    event.preventDefault();
    event.stopPropagation();
    const target = event.target;

    if (target.tagName === 'IFRAME') {
      const iframe = target;

      try {
        if (!iframesListeningTo.has(iframe)) {
          const window = iframe.contentWindow;
          registerListenersOnWindow(window);
          iframesListeningTo.add(iframe);
        }
      } catch (error) {// This can error when the iframe is on a cross-origin.
      }
    } // Don't pass the name explicitly.
    // It will be inferred from DOM tag and Fiber owner.


    showOverlay([target], null, false);
    selectFiberForNode(target);
  }

  function onPointerUp(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  const selectFiberForNode = lodash_throttle_default()(Object(esm["a" /* default */])(node => {
    const id = agent.getIDForNode(node);

    if (id !== null) {
      bridge.send('selectFiber', id);
    }
  }), 200, // Don't change the selection in the very first 200ms
  // because those are usually unintentional as you lift the cursor.
  {
    leading: false
  });
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/TraceUpdates/canvas.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const OUTLINE_COLOR = '#f0f0f0'; // Note these colors are in sync with DevTools Profiler chart colors.

const COLORS = ['#37afa9', '#63b19e', '#80b393', '#97b488', '#abb67d', '#beb771', '#cfb965', '#dfba57', '#efbb49', '#febc38'];
let canvas = null;
function draw(nodeToData) {
  if (canvas === null) {
    initialize();
  }

  const canvasFlow = canvas;
  canvasFlow.width = window.innerWidth;
  canvasFlow.height = window.innerHeight;
  const context = canvasFlow.getContext('2d');
  context.clearRect(0, 0, canvasFlow.width, canvasFlow.height);
  nodeToData.forEach(({
    count,
    rect
  }) => {
    if (rect !== null) {
      const colorIndex = Math.min(COLORS.length - 1, count - 1);
      const color = COLORS[colorIndex];
      drawBorder(context, rect, color);
    }
  });
}

function drawBorder(context, rect, color) {
  const height = rect.height,
        left = rect.left,
        top = rect.top,
        width = rect.width; // outline

  context.lineWidth = 1;
  context.strokeStyle = OUTLINE_COLOR;
  context.strokeRect(left - 1, top - 1, width + 2, height + 2); // inset

  context.lineWidth = 1;
  context.strokeStyle = OUTLINE_COLOR;
  context.strokeRect(left + 1, top + 1, width - 1, height - 1);
  context.strokeStyle = color;
  context.setLineDash([0]); // border

  context.lineWidth = 1;
  context.strokeRect(left, top, width - 1, height - 1);
  context.setLineDash([0]);
}

function destroy() {
  if (canvas !== null) {
    if (canvas.parentNode != null) {
      canvas.parentNode.removeChild(canvas);
    }

    canvas = null;
  }
}

function initialize() {
  canvas = window.document.createElement('canvas');
  canvas.style.cssText = `
    xx-background-color: red;
    xx-opacity: 0.5;
    bottom: 0;
    left: 0;
    pointer-events: none;
    position: fixed;
    right: 0;
    top: 0;
    z-index: 1000000000;
  `;
  const root = window.document.documentElement;
  root.insertBefore(canvas, root.firstChild);
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/TraceUpdates/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



// How long the rect should be shown for?
const DISPLAY_DURATION = 250; // What's the longest we are willing to show the overlay for?
// This can be important if we're getting a flurry of events (e.g. scroll update).

const MAX_DISPLAY_DURATION = 3000; // How long should a rect be considered valid for?

const REMEASUREMENT_AFTER_DURATION = 250; // Some environments (e.g. React Native / Hermes) don't support the performance API yet.

const getCurrentTime = typeof performance === 'object' && typeof performance.now === 'function' ? () => performance.now() : () => Date.now();
const nodeToData = new Map();
let TraceUpdates_agent = null;
let drawAnimationFrameID = null;
let isEnabled = false;
let redrawTimeoutID = null;
function TraceUpdates_initialize(injectedAgent) {
  TraceUpdates_agent = injectedAgent;
  TraceUpdates_agent.addListener('traceUpdates', traceUpdates);
}
function toggleEnabled(value) {
  isEnabled = value;

  if (!isEnabled) {
    nodeToData.clear();

    if (drawAnimationFrameID !== null) {
      cancelAnimationFrame(drawAnimationFrameID);
      drawAnimationFrameID = null;
    }

    if (redrawTimeoutID !== null) {
      clearTimeout(redrawTimeoutID);
      redrawTimeoutID = null;
    }

    destroy();
  }
}

function traceUpdates(nodes) {
  if (!isEnabled) {
    return;
  }

  nodes.forEach(node => {
    const data = nodeToData.get(node);
    const now = getCurrentTime();
    let lastMeasuredAt = data != null ? data.lastMeasuredAt : 0;
    let rect = data != null ? data.rect : null;

    if (rect === null || lastMeasuredAt + REMEASUREMENT_AFTER_DURATION < now) {
      lastMeasuredAt = now;
      rect = measureNode(node);
    }

    nodeToData.set(node, {
      count: data != null ? data.count + 1 : 1,
      expirationTime: data != null ? Math.min(now + MAX_DISPLAY_DURATION, data.expirationTime + DISPLAY_DURATION) : now + DISPLAY_DURATION,
      lastMeasuredAt,
      rect
    });
  });

  if (redrawTimeoutID !== null) {
    clearTimeout(redrawTimeoutID);
    redrawTimeoutID = null;
  }

  if (drawAnimationFrameID === null) {
    drawAnimationFrameID = requestAnimationFrame(prepareToDraw);
  }
}

function prepareToDraw() {
  drawAnimationFrameID = null;
  redrawTimeoutID = null;
  const now = getCurrentTime();
  let earliestExpiration = Number.MAX_VALUE; // Remove any items that have already expired.

  nodeToData.forEach((data, node) => {
    if (data.expirationTime < now) {
      nodeToData.delete(node);
    } else {
      earliestExpiration = Math.min(earliestExpiration, data.expirationTime);
    }
  });
  draw(nodeToData);

  if (earliestExpiration !== Number.MAX_VALUE) {
    redrawTimeoutID = setTimeout(prepareToDraw, earliestExpiration - now);
  }
}

function measureNode(node) {
  if (!node || typeof node.getBoundingClientRect !== 'function') {
    return null;
  }

  const currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
  return getNestedBoundingClientRect(node, currentWindow);
}
// EXTERNAL MODULE: ../react-devtools-shared/node_modules/semver/semver.js
var semver = __webpack_require__(49);

// EXTERNAL MODULE: ../react-devtools-shared/src/types.js
var types = __webpack_require__(1);

// EXTERNAL MODULE: ../react-devtools-shared/src/utils.js
var utils = __webpack_require__(2);

// EXTERNAL MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/clipboard-js/clipboard.js
var clipboard = __webpack_require__(17);

// EXTERNAL MODULE: ../react-devtools-shared/src/hydration.js
var hydration = __webpack_require__(8);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/utils.js
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


function cleanForBridge(data, isPathAllowed, path = []) {
  if (data !== null) {
    const cleanedPaths = [];
    const unserializablePaths = [];
    const cleanedData = Object(hydration["a" /* dehydrate */])(data, cleanedPaths, unserializablePaths, path, isPathAllowed);
    return {
      data: cleanedData,
      cleaned: cleanedPaths,
      unserializable: unserializablePaths
    };
  } else {
    return null;
  }
}
function copyToClipboard(value) {
  const safeToCopy = serializeToString(value);
  const text = safeToCopy === undefined ? 'undefined' : safeToCopy;
  const clipboardCopyText = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.clipboardCopyText; // On Firefox navigator.clipboard.writeText has to be called from
  // the content script js code (because it requires the clipboardWrite
  // permission to be allowed out of a "user handling" callback),
  // clipboardCopyText is an helper injected into the page from.
  // injectGlobalHook.

  if (typeof clipboardCopyText === 'function') {
    clipboardCopyText(text).catch(err => {});
  } else {
    Object(clipboard["copy"])(text);
  }
}
function copyWithDelete(obj, path, index = 0) {
  const key = path[index];
  const updated = Array.isArray(obj) ? obj.slice() : _objectSpread({}, obj);

  if (index + 1 === path.length) {
    if (Array.isArray(updated)) {
      updated.splice(key, 1);
    } else {
      delete updated[key];
    }
  } else {
    // $FlowFixMe number or string is fine here
    updated[key] = copyWithDelete(obj[key], path, index + 1);
  }

  return updated;
} // This function expects paths to be the same except for the final value.
// e.g. ['path', 'to', 'foo'] and ['path', 'to', 'bar']

function copyWithRename(obj, oldPath, newPath, index = 0) {
  const oldKey = oldPath[index];
  const updated = Array.isArray(obj) ? obj.slice() : _objectSpread({}, obj);

  if (index + 1 === oldPath.length) {
    const newKey = newPath[index]; // $FlowFixMe number or string is fine here

    updated[newKey] = updated[oldKey];

    if (Array.isArray(updated)) {
      updated.splice(oldKey, 1);
    } else {
      delete updated[oldKey];
    }
  } else {
    // $FlowFixMe number or string is fine here
    updated[oldKey] = copyWithRename(obj[oldKey], oldPath, newPath, index + 1);
  }

  return updated;
}
function copyWithSet(obj, path, value, index = 0) {
  if (index >= path.length) {
    return value;
  }

  const key = path[index];
  const updated = Array.isArray(obj) ? obj.slice() : _objectSpread({}, obj); // $FlowFixMe number or string is fine here

  updated[key] = copyWithSet(obj[key], path, value, index + 1);
  return updated;
}
function serializeToString(data) {
  const cache = new Set(); // Use a custom replacer function to protect against circular references.

  return JSON.stringify(data, (key, value) => {
    if (typeof value === 'object' && value !== null) {
      if (cache.has(value)) {
        return;
      }

      cache.add(value);
    } // $FlowFixMe


    if (typeof value === 'bigint') {
      return value.toString() + 'n';
    }

    return value;
  });
}
// CONCATENATED MODULE: ../react-reconciler/src/ReactTypeOfMode.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const NoMode = 0b00000;
const StrictMode = 0b00001; // TODO: Remove BlockingMode and ConcurrentMode by reading from the root
// tag instead

const BlockingMode = 0b00010;
const ConcurrentMode = 0b00100;
const ProfileMode = 0b01000;
const DebugTracingMode = 0b10000;
// EXTERNAL MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/error-stack-parser/error-stack-parser.js
var error_stack_parser = __webpack_require__(50);
var error_stack_parser_default = /*#__PURE__*/__webpack_require__.n(error_stack_parser);

// CONCATENATED MODULE: ../shared/invariant.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */
function invariant(condition, format, a, b, c, d, e, f) {
  throw new Error('Internal React error: invariant() is meant to be replaced at compile ' + 'time. There is no runtime version.');
}
// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__(0);

// CONCATENATED MODULE: ../shared/ReactSharedInternals.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

const ReactSharedInternals = external_react_["__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED"];
/* harmony default export */ var shared_ReactSharedInternals = (ReactSharedInternals);
// EXTERNAL MODULE: ../shared/ReactSymbols.js
var ReactSymbols = __webpack_require__(37);

// CONCATENATED MODULE: ../react-reconciler/src/ReactWorkTags.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const ReactWorkTags_FunctionComponent = 0;
const ReactWorkTags_ClassComponent = 1;
const ReactWorkTags_IndeterminateComponent = 2; // Before we know whether it is function or class

const ReactWorkTags_HostRoot = 3; // Root of a host tree. Could be nested inside another node.

const ReactWorkTags_HostPortal = 4; // A subtree. Could be an entry point to a different renderer.

const ReactWorkTags_HostComponent = 5;
const ReactWorkTags_HostText = 6;
const ReactWorkTags_Fragment = 7;
const Mode = 8;
const ReactWorkTags_ContextConsumer = 9;
const ContextProvider = 10;
const ReactWorkTags_ForwardRef = 11;
const Profiler = 12;
const ReactWorkTags_SuspenseComponent = 13;
const ReactWorkTags_MemoComponent = 14;
const ReactWorkTags_SimpleMemoComponent = 15;
const ReactWorkTags_LazyComponent = 16;
const ReactWorkTags_IncompleteClassComponent = 17;
const DehydratedFragment = 18;
const ReactWorkTags_SuspenseListComponent = 19;
const FundamentalComponent = 20;
const ReactWorkTags_ScopeComponent = 21;
const ReactWorkTags_OffscreenComponent = 22;
const ReactWorkTags_LegacyHiddenComponent = 23;
// CONCATENATED MODULE: ../react-debug-tools/src/ReactDebugHooks.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






let hookLog = []; // Primitives

let primitiveStackCache = null;
let currentFiber = null;

function getPrimitiveStackCache() {
  // This initializes a cache of all primitive hooks so that the top
  // most stack frames added by calling the primitive hook can be removed.
  if (primitiveStackCache === null) {
    const cache = new Map();
    let readHookLog;

    try {
      // Use all hooks here to add them to the hook log.
      Dispatcher.useContext({
        _currentValue: null
      });
      Dispatcher.useState(null);
      Dispatcher.useReducer((s, a) => s, null);
      Dispatcher.useRef(null);
      Dispatcher.useLayoutEffect(() => {});
      Dispatcher.useEffect(() => {});
      Dispatcher.useImperativeHandle(undefined, () => null);
      Dispatcher.useDebugValue(null);
      Dispatcher.useCallback(() => {});
      Dispatcher.useMemo(() => null);
    } finally {
      readHookLog = hookLog;
      hookLog = [];
    }

    for (let i = 0; i < readHookLog.length; i++) {
      const hook = readHookLog[i];
      cache.set(hook.primitive, error_stack_parser_default.a.parse(hook.stackError));
    }

    primitiveStackCache = cache;
  }

  return primitiveStackCache;
}

let currentHook = null;

function nextHook() {
  const hook = currentHook;

  if (hook !== null) {
    currentHook = hook.next;
  }

  return hook;
}

function getCacheForType(resourceType) {
  invariant(false, 'Not implemented.');
}

function readContext(context, observedBits) {
  // For now we don't expose readContext usage in the hooks debugging info.
  return context._currentValue;
}

function useContext(context, observedBits) {
  hookLog.push({
    primitive: 'Context',
    stackError: new Error(),
    value: context._currentValue
  });
  return context._currentValue;
}

function useState(initialState) {
  const hook = nextHook();
  const state = hook !== null ? hook.memoizedState : typeof initialState === 'function' ? // $FlowFixMe: Flow doesn't like mixed types
  initialState() : initialState;
  hookLog.push({
    primitive: 'State',
    stackError: new Error(),
    value: state
  });
  return [state, action => {}];
}

function useReducer(reducer, initialArg, init) {
  const hook = nextHook();
  let state;

  if (hook !== null) {
    state = hook.memoizedState;
  } else {
    state = init !== undefined ? init(initialArg) : initialArg;
  }

  hookLog.push({
    primitive: 'Reducer',
    stackError: new Error(),
    value: state
  });
  return [state, action => {}];
}

function useRef(initialValue) {
  const hook = nextHook();
  const ref = hook !== null ? hook.memoizedState : {
    current: initialValue
  };
  hookLog.push({
    primitive: 'Ref',
    stackError: new Error(),
    value: ref.current
  });
  return ref;
}

function useLayoutEffect(create, inputs) {
  nextHook();
  hookLog.push({
    primitive: 'LayoutEffect',
    stackError: new Error(),
    value: create
  });
}

function useEffect(create, inputs) {
  nextHook();
  hookLog.push({
    primitive: 'Effect',
    stackError: new Error(),
    value: create
  });
}

function useImperativeHandle(ref, create, inputs) {
  nextHook(); // We don't actually store the instance anywhere if there is no ref callback
  // and if there is a ref callback it might not store it but if it does we
  // have no way of knowing where. So let's only enable introspection of the
  // ref itself if it is using the object form.

  let instance = undefined;

  if (ref !== null && typeof ref === 'object') {
    instance = ref.current;
  }

  hookLog.push({
    primitive: 'ImperativeHandle',
    stackError: new Error(),
    value: instance
  });
}

function useDebugValue(value, formatterFn) {
  hookLog.push({
    primitive: 'DebugValue',
    stackError: new Error(),
    value: typeof formatterFn === 'function' ? formatterFn(value) : value
  });
}

function useCallback(callback, inputs) {
  const hook = nextHook();
  hookLog.push({
    primitive: 'Callback',
    stackError: new Error(),
    value: hook !== null ? hook.memoizedState[0] : callback
  });
  return callback;
}

function useMemo(nextCreate, inputs) {
  const hook = nextHook();
  const value = hook !== null ? hook.memoizedState[0] : nextCreate();
  hookLog.push({
    primitive: 'Memo',
    stackError: new Error(),
    value
  });
  return value;
}

function useMutableSource(source, getSnapshot, subscribe) {
  // useMutableSource() composes multiple hooks internally.
  // Advance the current hook index the same number of times
  // so that subsequent hooks have the right memoized state.
  nextHook(); // MutableSource

  nextHook(); // State

  nextHook(); // Effect

  nextHook(); // Effect

  const value = getSnapshot(source._source);
  hookLog.push({
    primitive: 'MutableSource',
    stackError: new Error(),
    value
  });
  return value;
}

function useTransition() {
  // useTransition() composes multiple hooks internally.
  // Advance the current hook index the same number of times
  // so that subsequent hooks have the right memoized state.
  nextHook(); // State

  nextHook(); // Callback

  hookLog.push({
    primitive: 'Transition',
    stackError: new Error(),
    value: undefined
  });
  return [callback => {}, false];
}

function useDeferredValue(value) {
  // useDeferredValue() composes multiple hooks internally.
  // Advance the current hook index the same number of times
  // so that subsequent hooks have the right memoized state.
  nextHook(); // State

  nextHook(); // Effect

  hookLog.push({
    primitive: 'DeferredValue',
    stackError: new Error(),
    value
  });
  return value;
}

function useOpaqueIdentifier() {
  const hook = nextHook(); // State

  if (currentFiber && currentFiber.mode === NoMode) {
    nextHook(); // Effect
  }

  let value = hook === null ? undefined : hook.memoizedState;

  if (value && value.$$typeof === ReactSymbols["a" /* REACT_OPAQUE_ID_TYPE */]) {
    value = undefined;
  }

  hookLog.push({
    primitive: 'OpaqueIdentifier',
    stackError: new Error(),
    value
  });
  return value;
}

const Dispatcher = {
  getCacheForType,
  readContext,
  useCallback,
  useContext,
  useEffect,
  useImperativeHandle,
  useDebugValue,
  useLayoutEffect,
  useMemo,
  useReducer,
  useRef,
  useState,
  useTransition,
  useMutableSource,
  useDeferredValue,
  useOpaqueIdentifier
}; // Inspect

// Don't assume
//
// We can't assume that stack frames are nth steps away from anything.
// E.g. we can't assume that the root call shares all frames with the stack
// of a hook call. A simple way to demonstrate this is wrapping `new Error()`
// in a wrapper constructor like a polyfill. That'll add an extra frame.
// Similar things can happen with the call to the dispatcher. The top frame
// may not be the primitive. Likewise the primitive can have fewer stack frames
// such as when a call to useState got inlined to use dispatcher.useState.
//
// We also can't assume that the last frame of the root call is the same
// frame as the last frame of the hook call because long stack traces can be
// truncated to a stack trace limit.
let mostLikelyAncestorIndex = 0;

function findSharedIndex(hookStack, rootStack, rootIndex) {
  const source = rootStack[rootIndex].source;

  hookSearch: for (let i = 0; i < hookStack.length; i++) {
    if (hookStack[i].source === source) {
      // This looks like a match. Validate that the rest of both stack match up.
      for (let a = rootIndex + 1, b = i + 1; a < rootStack.length && b < hookStack.length; a++, b++) {
        if (hookStack[b].source !== rootStack[a].source) {
          // If not, give up and try a different match.
          continue hookSearch;
        }
      }

      return i;
    }
  }

  return -1;
}

function findCommonAncestorIndex(rootStack, hookStack) {
  let rootIndex = findSharedIndex(hookStack, rootStack, mostLikelyAncestorIndex);

  if (rootIndex !== -1) {
    return rootIndex;
  } // If the most likely one wasn't a hit, try any other frame to see if it is shared.
  // If that takes more than 5 frames, something probably went wrong.


  for (let i = 0; i < rootStack.length && i < 5; i++) {
    rootIndex = findSharedIndex(hookStack, rootStack, i);

    if (rootIndex !== -1) {
      mostLikelyAncestorIndex = i;
      return rootIndex;
    }
  }

  return -1;
}

function isReactWrapper(functionName, primitiveName) {
  if (!functionName) {
    return false;
  }

  const expectedPrimitiveName = 'use' + primitiveName;

  if (functionName.length < expectedPrimitiveName.length) {
    return false;
  }

  return functionName.lastIndexOf(expectedPrimitiveName) === functionName.length - expectedPrimitiveName.length;
}

function findPrimitiveIndex(hookStack, hook) {
  const stackCache = getPrimitiveStackCache();
  const primitiveStack = stackCache.get(hook.primitive);

  if (primitiveStack === undefined) {
    return -1;
  }

  for (let i = 0; i < primitiveStack.length && i < hookStack.length; i++) {
    if (primitiveStack[i].source !== hookStack[i].source) {
      // If the next two frames are functions called `useX` then we assume that they're part of the
      // wrappers that the React packager or other packages adds around the dispatcher.
      if (i < hookStack.length - 1 && isReactWrapper(hookStack[i].functionName, hook.primitive)) {
        i++;
      }

      if (i < hookStack.length - 1 && isReactWrapper(hookStack[i].functionName, hook.primitive)) {
        i++;
      }

      return i;
    }
  }

  return -1;
}

function parseTrimmedStack(rootStack, hook) {
  // Get the stack trace between the primitive hook function and
  // the root function call. I.e. the stack frames of custom hooks.
  const hookStack = error_stack_parser_default.a.parse(hook.stackError);
  const rootIndex = findCommonAncestorIndex(rootStack, hookStack);
  const primitiveIndex = findPrimitiveIndex(hookStack, hook);

  if (rootIndex === -1 || primitiveIndex === -1 || rootIndex - primitiveIndex < 2) {
    // Something went wrong. Give up.
    return null;
  }

  return hookStack.slice(primitiveIndex, rootIndex - 1);
}

function parseCustomHookName(functionName) {
  if (!functionName) {
    return '';
  }

  let startIndex = functionName.lastIndexOf('.');

  if (startIndex === -1) {
    startIndex = 0;
  }

  if (functionName.substr(startIndex, 3) === 'use') {
    startIndex += 3;
  }

  return functionName.substr(startIndex);
}

function buildTree(rootStack, readHookLog) {
  const rootChildren = [];
  let prevStack = null;
  let levelChildren = rootChildren;
  let nativeHookID = 0;
  const stackOfChildren = [];

  for (let i = 0; i < readHookLog.length; i++) {
    const hook = readHookLog[i];
    const stack = parseTrimmedStack(rootStack, hook);

    if (stack !== null) {
      // Note: The indices 0 <= n < length-1 will contain the names.
      // The indices 1 <= n < length will contain the source locations.
      // That's why we get the name from n - 1 and don't check the source
      // of index 0.
      let commonSteps = 0;

      if (prevStack !== null) {
        // Compare the current level's stack to the new stack.
        while (commonSteps < stack.length && commonSteps < prevStack.length) {
          const stackSource = stack[stack.length - commonSteps - 1].source;
          const prevSource = prevStack[prevStack.length - commonSteps - 1].source;

          if (stackSource !== prevSource) {
            break;
          }

          commonSteps++;
        } // Pop back the stack as many steps as were not common.


        for (let j = prevStack.length - 1; j > commonSteps; j--) {
          levelChildren = stackOfChildren.pop();
        }
      } // The remaining part of the new stack are custom hooks. Push them
      // to the tree.


      for (let j = stack.length - commonSteps - 1; j >= 1; j--) {
        const children = [];
        levelChildren.push({
          id: null,
          isStateEditable: false,
          name: parseCustomHookName(stack[j - 1].functionName),
          value: undefined,
          subHooks: children
        });
        stackOfChildren.push(levelChildren);
        levelChildren = children;
      }

      prevStack = stack;
    }

    const primitive = hook.primitive; // For now, the "id" of stateful hooks is just the stateful hook index.
    // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).

    const id = primitive === 'Context' || primitive === 'DebugValue' ? null : nativeHookID++; // For the time being, only State and Reducer hooks support runtime overrides.

    const isStateEditable = primitive === 'Reducer' || primitive === 'State';
    levelChildren.push({
      id,
      isStateEditable,
      name: primitive,
      value: hook.value,
      subHooks: []
    });
  } // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.


  processDebugValues(rootChildren, null);
  return rootChildren;
} // Custom hooks support user-configurable labels (via the special useDebugValue() hook).
// That hook adds user-provided values to the hooks tree,
// but these values aren't intended to appear alongside of the other hooks.
// Instead they should be attributed to their parent custom hook.
// This method walks the tree and assigns debug values to their custom hook owners.


function processDebugValues(hooksTree, parentHooksNode) {
  const debugValueHooksNodes = [];

  for (let i = 0; i < hooksTree.length; i++) {
    const hooksNode = hooksTree[i];

    if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {
      hooksTree.splice(i, 1);
      i--;
      debugValueHooksNodes.push(hooksNode);
    } else {
      processDebugValues(hooksNode.subHooks, hooksNode);
    }
  } // Bubble debug value labels to their custom hook owner.
  // If there is no parent hook, just ignore them for now.
  // (We may warn about this in the future.)


  if (parentHooksNode !== null) {
    if (debugValueHooksNodes.length === 1) {
      parentHooksNode.value = debugValueHooksNodes[0].value;
    } else if (debugValueHooksNodes.length > 1) {
      parentHooksNode.value = debugValueHooksNodes.map(({
        value
      }) => value);
    }
  }
}

function inspectHooks(renderFunction, props, currentDispatcher) {
  // DevTools will pass the current renderer's injected dispatcher.
  // Other apps might compile debug hooks as part of their app though.
  if (currentDispatcher == null) {
    currentDispatcher = shared_ReactSharedInternals.ReactCurrentDispatcher;
  }

  const previousDispatcher = currentDispatcher.current;
  let readHookLog;
  currentDispatcher.current = Dispatcher;
  let ancestorStackError;

  try {
    ancestorStackError = new Error();
    renderFunction(props);
  } finally {
    readHookLog = hookLog;
    hookLog = [];
    currentDispatcher.current = previousDispatcher;
  }

  const rootStack = error_stack_parser_default.a.parse(ancestorStackError);
  return buildTree(rootStack, readHookLog);
}

function setupContexts(contextMap, fiber) {
  let current = fiber;

  while (current) {
    if (current.tag === ContextProvider) {
      const providerType = current.type;
      const context = providerType._context;

      if (!contextMap.has(context)) {
        // Store the current value that we're going to restore later.
        contextMap.set(context, context._currentValue); // Set the inner most provider value on the context.

        context._currentValue = current.memoizedProps.value;
      }
    }

    current = current.return;
  }
}

function restoreContexts(contextMap) {
  contextMap.forEach((value, context) => context._currentValue = value);
}

function inspectHooksOfForwardRef(renderFunction, props, ref, currentDispatcher) {
  const previousDispatcher = currentDispatcher.current;
  let readHookLog;
  currentDispatcher.current = Dispatcher;
  let ancestorStackError;

  try {
    ancestorStackError = new Error();
    renderFunction(props, ref);
  } finally {
    readHookLog = hookLog;
    hookLog = [];
    currentDispatcher.current = previousDispatcher;
  }

  const rootStack = error_stack_parser_default.a.parse(ancestorStackError);
  return buildTree(rootStack, readHookLog);
}

function resolveDefaultProps(Component, baseProps) {
  if (Component && Component.defaultProps) {
    // Resolve default props. Taken from ReactElement
    const props = Object.assign({}, baseProps);
    const defaultProps = Component.defaultProps;

    for (const propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }

    return props;
  }

  return baseProps;
}

function inspectHooksOfFiber(fiber, currentDispatcher) {
  // DevTools will pass the current renderer's injected dispatcher.
  // Other apps might compile debug hooks as part of their app though.
  if (currentDispatcher == null) {
    currentDispatcher = shared_ReactSharedInternals.ReactCurrentDispatcher;
  }

  currentFiber = fiber;

  if (fiber.tag !== ReactWorkTags_FunctionComponent && fiber.tag !== ReactWorkTags_SimpleMemoComponent && fiber.tag !== ReactWorkTags_ForwardRef) {
    throw new Error('Unknown Fiber. Needs to be a function component to inspect hooks.');
  } // Warm up the cache so that it doesn't consume the currentHook.


  getPrimitiveStackCache();
  const type = fiber.type;
  let props = fiber.memoizedProps;

  if (type !== fiber.elementType) {
    props = resolveDefaultProps(type, props);
  } // Set up the current hook so that we can step through and read the
  // current state from them.


  currentHook = fiber.memoizedState;
  const contextMap = new Map();

  try {
    setupContexts(contextMap, fiber);

    if (fiber.tag === ReactWorkTags_ForwardRef) {
      return inspectHooksOfForwardRef(type.render, props, fiber.ref, currentDispatcher);
    }

    return inspectHooks(type, props, currentDispatcher);
  } finally {
    currentHook = null;
    restoreContexts(contextMap);
  }
}
// CONCATENATED MODULE: ../react-debug-tools/src/ReactDebugTools.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


// CONCATENATED MODULE: ../react-debug-tools/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/ReactSymbols.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This list should be kept updated to reflect additions to 'shared/ReactSymbols'.
// DevTools can't import symbols from 'shared/ReactSymbols' directly for two reasons:
// 1. DevTools requires symbols which may have been deleted in more recent versions (e.g. concurrent mode)
// 2. DevTools must support both Symbol and numeric forms of each symbol;
//    Since e.g. standalone DevTools runs in a separate process, it can't rely on its own ES capabilities.
const CONCURRENT_MODE_NUMBER = 0xeacf;
const CONCURRENT_MODE_SYMBOL_STRING = 'Symbol(react.concurrent_mode)';
const CONTEXT_NUMBER = 0xeace;
const CONTEXT_SYMBOL_STRING = 'Symbol(react.context)';
const DEPRECATED_ASYNC_MODE_SYMBOL_STRING = 'Symbol(react.async_mode)';
const ELEMENT_NUMBER = 0xeac7;
const ELEMENT_SYMBOL_STRING = 'Symbol(react.element)';
const DEBUG_TRACING_MODE_NUMBER = 0xeae1;
const DEBUG_TRACING_MODE_SYMBOL_STRING = 'Symbol(react.debug_trace_mode)';
const FORWARD_REF_NUMBER = 0xead0;
const FORWARD_REF_SYMBOL_STRING = 'Symbol(react.forward_ref)';
const FRAGMENT_NUMBER = 0xeacb;
const FRAGMENT_SYMBOL_STRING = 'Symbol(react.fragment)';
const FUNDAMENTAL_NUMBER = 0xead5;
const FUNDAMENTAL_SYMBOL_STRING = 'Symbol(react.fundamental)';
const LAZY_NUMBER = 0xead4;
const LAZY_SYMBOL_STRING = 'Symbol(react.lazy)';
const MEMO_NUMBER = 0xead3;
const MEMO_SYMBOL_STRING = 'Symbol(react.memo)';
const OPAQUE_ID_NUMBER = 0xeae0;
const OPAQUE_ID_SYMBOL_STRING = 'Symbol(react.opaque.id)';
const PORTAL_NUMBER = 0xeaca;
const PORTAL_SYMBOL_STRING = 'Symbol(react.portal)';
const PROFILER_NUMBER = 0xead2;
const PROFILER_SYMBOL_STRING = 'Symbol(react.profiler)';
const PROVIDER_NUMBER = 0xeacd;
const PROVIDER_SYMBOL_STRING = 'Symbol(react.provider)';
const SCOPE_NUMBER = 0xead7;
const SCOPE_SYMBOL_STRING = 'Symbol(react.scope)';
const STRICT_MODE_NUMBER = 0xeacc;
const STRICT_MODE_SYMBOL_STRING = 'Symbol(react.strict_mode)';
const SUSPENSE_NUMBER = 0xead1;
const SUSPENSE_SYMBOL_STRING = 'Symbol(react.suspense)';
const SUSPENSE_LIST_NUMBER = 0xead8;
const SUSPENSE_LIST_SYMBOL_STRING = 'Symbol(react.suspense_list)';
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/renderer.js
function renderer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function renderer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { renderer_ownKeys(Object(source), true).forEach(function (key) { renderer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { renderer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function renderer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || renderer_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function renderer_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = renderer_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function renderer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return renderer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return renderer_arrayLikeToArray(o, minLen); }

function renderer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */










function getFiberFlags(fiber) {
  // The name of this field changed from "effectTag" to "flags"
  return fiber.flags !== undefined ? fiber.flags : fiber.effectTag;
} // Some environments (e.g. React Native / Hermes) don't support the performance API yet.


const renderer_getCurrentTime = typeof performance === 'object' && typeof performance.now === 'function' ? () => performance.now() : () => Date.now();
function getInternalReactConstants(version) {
  const ReactTypeOfSideEffect = {
    NoFlags: 0b00,
    PerformedWork: 0b01,
    Placement: 0b10
  }; // **********************************************************
  // The section below is copied from files in React repo.
  // Keep it in sync, and add version guards if it changes.
  //
  // Technically these priority levels are invalid for versions before 16.9,
  // but 16.9 is the first version to report priority level to DevTools,
  // so we can avoid checking for earlier versions and support pre-16.9 canary releases in the process.

  const ReactPriorityLevels = {
    ImmediatePriority: 99,
    UserBlockingPriority: 98,
    NormalPriority: 97,
    LowPriority: 96,
    IdlePriority: 95,
    NoPriority: 90
  };
  let ReactTypeOfWork = null; // **********************************************************
  // The section below is copied from files in React repo.
  // Keep it in sync, and add version guards if it changes.
  //
  // TODO Update the gt() check below to be gte() whichever the next version number is.
  // Currently the version in Git is 17.0.2 (but that version has not been/may not end up being released).

  if (Object(semver["gt"])(version, '17.0.1')) {
    ReactTypeOfWork = {
      ClassComponent: 1,
      ContextConsumer: 9,
      ContextProvider: 10,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: 18,
      // Behind a flag
      ForwardRef: 11,
      Fragment: 7,
      FunctionComponent: 0,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostText: 6,
      IncompleteClassComponent: 17,
      IndeterminateComponent: 2,
      LazyComponent: 16,
      LegacyHiddenComponent: 23,
      MemoComponent: 14,
      Mode: 8,
      OffscreenComponent: 22,
      // Experimental
      Profiler: 12,
      ScopeComponent: 21,
      // Experimental
      SimpleMemoComponent: 15,
      SuspenseComponent: 13,
      SuspenseListComponent: 19,
      // Experimental
      YieldComponent: -1 // Removed

    };
  } else if (Object(semver["gte"])(version, '17.0.0-alpha')) {
    ReactTypeOfWork = {
      ClassComponent: 1,
      ContextConsumer: 9,
      ContextProvider: 10,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: 18,
      // Behind a flag
      ForwardRef: 11,
      Fragment: 7,
      FunctionComponent: 0,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostText: 6,
      IncompleteClassComponent: 17,
      IndeterminateComponent: 2,
      LazyComponent: 16,
      LegacyHiddenComponent: 24,
      MemoComponent: 14,
      Mode: 8,
      OffscreenComponent: 23,
      // Experimental
      Profiler: 12,
      ScopeComponent: 21,
      // Experimental
      SimpleMemoComponent: 15,
      SuspenseComponent: 13,
      SuspenseListComponent: 19,
      // Experimental
      YieldComponent: -1 // Removed

    };
  } else if (Object(semver["gte"])(version, '16.6.0-beta.0')) {
    ReactTypeOfWork = {
      ClassComponent: 1,
      ContextConsumer: 9,
      ContextProvider: 10,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: 18,
      // Behind a flag
      ForwardRef: 11,
      Fragment: 7,
      FunctionComponent: 0,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostText: 6,
      IncompleteClassComponent: 17,
      IndeterminateComponent: 2,
      LazyComponent: 16,
      LegacyHiddenComponent: -1,
      MemoComponent: 14,
      Mode: 8,
      OffscreenComponent: -1,
      // Experimental
      Profiler: 12,
      ScopeComponent: -1,
      // Experimental
      SimpleMemoComponent: 15,
      SuspenseComponent: 13,
      SuspenseListComponent: 19,
      // Experimental
      YieldComponent: -1 // Removed

    };
  } else if (Object(semver["gte"])(version, '16.4.3-alpha')) {
    ReactTypeOfWork = {
      ClassComponent: 2,
      ContextConsumer: 11,
      ContextProvider: 12,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: -1,
      // Doesn't exist yet
      ForwardRef: 13,
      Fragment: 9,
      FunctionComponent: 0,
      HostComponent: 7,
      HostPortal: 6,
      HostRoot: 5,
      HostText: 8,
      IncompleteClassComponent: -1,
      // Doesn't exist yet
      IndeterminateComponent: 4,
      LazyComponent: -1,
      // Doesn't exist yet
      LegacyHiddenComponent: -1,
      MemoComponent: -1,
      // Doesn't exist yet
      Mode: 10,
      OffscreenComponent: -1,
      // Experimental
      Profiler: 15,
      ScopeComponent: -1,
      // Experimental
      SimpleMemoComponent: -1,
      // Doesn't exist yet
      SuspenseComponent: 16,
      SuspenseListComponent: -1,
      // Doesn't exist yet
      YieldComponent: -1 // Removed

    };
  } else {
    ReactTypeOfWork = {
      ClassComponent: 2,
      ContextConsumer: 12,
      ContextProvider: 13,
      CoroutineComponent: 7,
      CoroutineHandlerPhase: 8,
      DehydratedSuspenseComponent: -1,
      // Doesn't exist yet
      ForwardRef: 14,
      Fragment: 10,
      FunctionComponent: 1,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostText: 6,
      IncompleteClassComponent: -1,
      // Doesn't exist yet
      IndeterminateComponent: 0,
      LazyComponent: -1,
      // Doesn't exist yet
      LegacyHiddenComponent: -1,
      MemoComponent: -1,
      // Doesn't exist yet
      Mode: 11,
      OffscreenComponent: -1,
      // Experimental
      Profiler: 15,
      ScopeComponent: -1,
      // Experimental
      SimpleMemoComponent: -1,
      // Doesn't exist yet
      SuspenseComponent: 16,
      SuspenseListComponent: -1,
      // Doesn't exist yet
      YieldComponent: 9
    };
  } // **********************************************************
  // End of copied code.
  // **********************************************************


  function getTypeSymbol(type) {
    const symbolOrNumber = typeof type === 'object' && type !== null ? type.$$typeof : type; // $FlowFixMe Flow doesn't know about typeof "symbol"

    return typeof symbolOrNumber === 'symbol' ? symbolOrNumber.toString() : symbolOrNumber;
  }

  const _ReactTypeOfWork = ReactTypeOfWork,
        ClassComponent = _ReactTypeOfWork.ClassComponent,
        IncompleteClassComponent = _ReactTypeOfWork.IncompleteClassComponent,
        FunctionComponent = _ReactTypeOfWork.FunctionComponent,
        IndeterminateComponent = _ReactTypeOfWork.IndeterminateComponent,
        ForwardRef = _ReactTypeOfWork.ForwardRef,
        HostRoot = _ReactTypeOfWork.HostRoot,
        HostComponent = _ReactTypeOfWork.HostComponent,
        HostPortal = _ReactTypeOfWork.HostPortal,
        HostText = _ReactTypeOfWork.HostText,
        Fragment = _ReactTypeOfWork.Fragment,
        LazyComponent = _ReactTypeOfWork.LazyComponent,
        LegacyHiddenComponent = _ReactTypeOfWork.LegacyHiddenComponent,
        MemoComponent = _ReactTypeOfWork.MemoComponent,
        OffscreenComponent = _ReactTypeOfWork.OffscreenComponent,
        ScopeComponent = _ReactTypeOfWork.ScopeComponent,
        SimpleMemoComponent = _ReactTypeOfWork.SimpleMemoComponent,
        SuspenseComponent = _ReactTypeOfWork.SuspenseComponent,
        SuspenseListComponent = _ReactTypeOfWork.SuspenseListComponent;

  function resolveFiberType(type) {
    const typeSymbol = getTypeSymbol(type);

    switch (typeSymbol) {
      case MEMO_NUMBER:
      case MEMO_SYMBOL_STRING:
        // recursively resolving memo type in case of memo(forwardRef(Component))
        return resolveFiberType(type.type);

      case FORWARD_REF_NUMBER:
      case FORWARD_REF_SYMBOL_STRING:
        return type.render;

      default:
        return type;
    }
  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods


  function getDisplayNameForFiber(fiber) {
    const type = fiber.type,
          tag = fiber.tag;
    let resolvedType = type;

    if (typeof type === 'object' && type !== null) {
      resolvedType = resolveFiberType(type);
    }

    let resolvedContext = null;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
        return Object(utils["h" /* getDisplayName */])(resolvedType);

      case FunctionComponent:
      case IndeterminateComponent:
        return Object(utils["h" /* getDisplayName */])(resolvedType);

      case ForwardRef:
        // Mirror https://github.com/facebook/react/blob/7c21bf72ace77094fd1910cc350a548287ef8350/packages/shared/getComponentName.js#L27-L37
        return type && type.displayName || Object(utils["h" /* getDisplayName */])(resolvedType, 'Anonymous');

      case HostRoot:
        return null;

      case HostComponent:
        return type;

      case HostPortal:
      case HostText:
      case Fragment:
        return null;

      case LazyComponent:
        // This display name will not be user visible.
        // Once a Lazy component loads its inner component, React replaces the tag and type.
        // This display name will only show up in console logs when DevTools DEBUG mode is on.
        return 'Lazy';

      case MemoComponent:
      case SimpleMemoComponent:
        return Object(utils["h" /* getDisplayName */])(resolvedType, 'Anonymous');

      case SuspenseComponent:
        return 'Suspense';

      case LegacyHiddenComponent:
        return 'LegacyHidden';

      case OffscreenComponent:
        return 'Offscreen';

      case ScopeComponent:
        return 'Scope';

      case SuspenseListComponent:
        return 'SuspenseList';

      default:
        const typeSymbol = getTypeSymbol(type);

        switch (typeSymbol) {
          case CONCURRENT_MODE_NUMBER:
          case CONCURRENT_MODE_SYMBOL_STRING:
          case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:
            return null;

          case PROVIDER_NUMBER:
          case PROVIDER_SYMBOL_STRING:
            // 16.3.0 exposed the context object as "context"
            // PR #12501 changed it to "_context" for 16.3.1+
            // NOTE Keep in sync with inspectElementRaw()
            resolvedContext = fiber.type._context || fiber.type.context;
            return `${resolvedContext.displayName || 'Context'}.Provider`;

          case CONTEXT_NUMBER:
          case CONTEXT_SYMBOL_STRING:
            // 16.3-16.5 read from "type" because the Consumer is the actual context object.
            // 16.6+ should read from "type._context" because Consumer can be different (in DEV).
            // NOTE Keep in sync with inspectElementRaw()
            resolvedContext = fiber.type._context || fiber.type; // NOTE: TraceUpdatesBackendManager depends on the name ending in '.Consumer'
            // If you change the name, figure out a more resilient way to detect it.

            return `${resolvedContext.displayName || 'Context'}.Consumer`;

          case STRICT_MODE_NUMBER:
          case STRICT_MODE_SYMBOL_STRING:
            return null;

          case PROFILER_NUMBER:
          case PROFILER_SYMBOL_STRING:
            return `Profiler(${fiber.memoizedProps.id})`;

          case SCOPE_NUMBER:
          case SCOPE_SYMBOL_STRING:
            return 'Scope';

          default:
            // Unknown element type.
            // This may mean a new element type that has not yet been added to DevTools.
            return null;
        }

    }
  }

  return {
    getDisplayNameForFiber,
    getTypeSymbol,
    ReactPriorityLevels,
    ReactTypeOfWork,
    ReactTypeOfSideEffect
  };
}
function renderer_attach(hook, rendererID, renderer, global) {
  const _getInternalReactCons = getInternalReactConstants(renderer.version),
        getDisplayNameForFiber = _getInternalReactCons.getDisplayNameForFiber,
        getTypeSymbol = _getInternalReactCons.getTypeSymbol,
        ReactPriorityLevels = _getInternalReactCons.ReactPriorityLevels,
        ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork,
        ReactTypeOfSideEffect = _getInternalReactCons.ReactTypeOfSideEffect;

  const NoFlags = ReactTypeOfSideEffect.NoFlags,
        PerformedWork = ReactTypeOfSideEffect.PerformedWork,
        Placement = ReactTypeOfSideEffect.Placement;
  const FunctionComponent = ReactTypeOfWork.FunctionComponent,
        ClassComponent = ReactTypeOfWork.ClassComponent,
        ContextConsumer = ReactTypeOfWork.ContextConsumer,
        DehydratedSuspenseComponent = ReactTypeOfWork.DehydratedSuspenseComponent,
        Fragment = ReactTypeOfWork.Fragment,
        ForwardRef = ReactTypeOfWork.ForwardRef,
        HostRoot = ReactTypeOfWork.HostRoot,
        HostPortal = ReactTypeOfWork.HostPortal,
        HostComponent = ReactTypeOfWork.HostComponent,
        HostText = ReactTypeOfWork.HostText,
        IncompleteClassComponent = ReactTypeOfWork.IncompleteClassComponent,
        IndeterminateComponent = ReactTypeOfWork.IndeterminateComponent,
        MemoComponent = ReactTypeOfWork.MemoComponent,
        OffscreenComponent = ReactTypeOfWork.OffscreenComponent,
        SimpleMemoComponent = ReactTypeOfWork.SimpleMemoComponent,
        SuspenseComponent = ReactTypeOfWork.SuspenseComponent,
        SuspenseListComponent = ReactTypeOfWork.SuspenseListComponent;
  const ImmediatePriority = ReactPriorityLevels.ImmediatePriority,
        UserBlockingPriority = ReactPriorityLevels.UserBlockingPriority,
        NormalPriority = ReactPriorityLevels.NormalPriority,
        LowPriority = ReactPriorityLevels.LowPriority,
        IdlePriority = ReactPriorityLevels.IdlePriority,
        NoPriority = ReactPriorityLevels.NoPriority;
  const overrideHookState = renderer.overrideHookState,
        overrideHookStateDeletePath = renderer.overrideHookStateDeletePath,
        overrideHookStateRenamePath = renderer.overrideHookStateRenamePath,
        overrideProps = renderer.overrideProps,
        overridePropsDeletePath = renderer.overridePropsDeletePath,
        overridePropsRenamePath = renderer.overridePropsRenamePath,
        setSuspenseHandler = renderer.setSuspenseHandler,
        scheduleUpdate = renderer.scheduleUpdate;
  const supportsTogglingSuspense = typeof setSuspenseHandler === 'function' && typeof scheduleUpdate === 'function'; // Patching the console enables DevTools to do a few useful things:
  // * Append component stacks to warnings and error messages
  // * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)
  //
  // Don't patch in test environments because we don't want to interfere with Jest's own console overrides.

  if (true) {
    registerRenderer(renderer); // The renderer interface can't read these preferences directly,
    // because it is stored in localStorage within the context of the extension.
    // It relies on the extension to pass the preference through via the global.

    const appendComponentStack = window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ !== false;
    const breakOnConsoleErrors = window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ === true;

    if (appendComponentStack || breakOnConsoleErrors) {
      patch({
        appendComponentStack,
        breakOnConsoleErrors
      });
    }
  }

  const debug = (name, fiber, parentFiber) => {
    if (constants["q" /* __DEBUG__ */]) {
      const displayName = fiber.tag + ':' + (getDisplayNameForFiber(fiber) || 'null');
      const id = getFiberID(fiber);
      const parentDisplayName = parentFiber ? parentFiber.tag + ':' + (getDisplayNameForFiber(parentFiber) || 'null') : '';
      const parentID = parentFiber ? getFiberID(parentFiber) : ''; // NOTE: calling getFiberID or getPrimaryFiber is unsafe here
      // because it will put them in the map. For now, we'll omit them.
      // TODO: better debugging story for this.

      console.log(`[renderer] %c${name} %c${displayName} (${id}) %c${parentFiber ? `${parentDisplayName} (${parentID})` : ''}`, 'color: red; font-weight: bold;', 'color: blue;', 'color: purple;');
    }
  }; // Configurable Components tree filters.


  const hideElementsWithDisplayNames = new Set();
  const hideElementsWithPaths = new Set();
  const hideElementsWithTypes = new Set(); // Highlight updates

  let traceUpdatesEnabled = false;
  const traceUpdatesForNodes = new Set();

  function applyComponentFilters(componentFilters) {
    hideElementsWithTypes.clear();
    hideElementsWithDisplayNames.clear();
    hideElementsWithPaths.clear();
    componentFilters.forEach(componentFilter => {
      if (!componentFilter.isEnabled) {
        return;
      }

      switch (componentFilter.type) {
        case types["a" /* ComponentFilterDisplayName */]:
          if (componentFilter.isValid && componentFilter.value !== '') {
            hideElementsWithDisplayNames.add(new RegExp(componentFilter.value, 'i'));
          }

          break;

        case types["b" /* ComponentFilterElementType */]:
          hideElementsWithTypes.add(componentFilter.value);
          break;

        case types["d" /* ComponentFilterLocation */]:
          if (componentFilter.isValid && componentFilter.value !== '') {
            hideElementsWithPaths.add(new RegExp(componentFilter.value, 'i'));
          }

          break;

        case types["c" /* ComponentFilterHOC */]:
          hideElementsWithDisplayNames.add(new RegExp('\\('));
          break;

        default:
          console.warn(`Invalid component filter type "${componentFilter.type}"`);
          break;
      }
    });
  } // The renderer interface can't read saved component filters directly,
  // because they are stored in localStorage within the context of the extension.
  // Instead it relies on the extension to pass filters through.


  if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ != null) {
    applyComponentFilters(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__);
  } else {
    // Unfortunately this feature is not expected to work for React Native for now.
    // It would be annoying for us to spam YellowBox warnings with unactionable stuff,
    // so for now just skip this message...
    //console.warn('âš›ï¸ DevTools: Could not locate saved component filters');
    // Fallback to assuming the default filters in this case.
    applyComponentFilters(Object(utils["g" /* getDefaultComponentFilters */])());
  } // If necessary, we can revisit optimizing this operation.
  // For example, we could add a new recursive unmount tree operation.
  // The unmount operations are already significantly smaller than mount operations though.
  // This is something to keep in mind for later.


  function updateComponentFilters(componentFilters) {
    if (isProfiling) {
      // Re-mounting a tree while profiling is in progress might break a lot of assumptions.
      // If necessary, we could support this- but it doesn't seem like a necessary use case.
      throw Error('Cannot modify filter preferences while profiling');
    } // Recursively unmount all roots.


    hook.getFiberRoots(rendererID).forEach(root => {
      currentRootID = getFiberID(getPrimaryFiber(root.current));
      unmountFiberChildrenRecursively(root.current);
      recordUnmount(root.current, false);
      currentRootID = -1;
    });
    applyComponentFilters(componentFilters); // Reset pseudo counters so that new path selections will be persisted.

    rootDisplayNameCounter.clear(); // Recursively re-mount all roots with new filter criteria applied.

    hook.getFiberRoots(rendererID).forEach(root => {
      currentRootID = getFiberID(getPrimaryFiber(root.current));
      setRootPseudoKey(currentRootID, root.current);
      mountFiberRecursively(root.current, null, false, false);
      flushPendingEvents(root);
      currentRootID = -1;
    });
  } // NOTICE Keep in sync with get*ForFiber methods


  function shouldFilterFiber(fiber) {
    const _debugSource = fiber._debugSource,
          tag = fiber.tag,
          type = fiber.type;

    switch (tag) {
      case DehydratedSuspenseComponent:
        // TODO: ideally we would show dehydrated Suspense immediately.
        // However, it has some special behavior (like disconnecting
        // an alternate and turning into real Suspense) which breaks DevTools.
        // For now, ignore it, and only show it once it gets hydrated.
        // https://github.com/bvaughn/react-devtools-experimental/issues/197
        return true;

      case HostPortal:
      case HostText:
      case Fragment:
      case OffscreenComponent:
        return true;

      case HostRoot:
        // It is never valid to filter the root element.
        return false;

      default:
        const typeSymbol = getTypeSymbol(type);

        switch (typeSymbol) {
          case CONCURRENT_MODE_NUMBER:
          case CONCURRENT_MODE_SYMBOL_STRING:
          case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:
          case STRICT_MODE_NUMBER:
          case STRICT_MODE_SYMBOL_STRING:
            return true;

          default:
            break;
        }

    }

    const elementType = getElementTypeForFiber(fiber);

    if (hideElementsWithTypes.has(elementType)) {
      return true;
    }

    if (hideElementsWithDisplayNames.size > 0) {
      const displayName = getDisplayNameForFiber(fiber);

      if (displayName != null) {
        // eslint-disable-next-line no-for-of-loops/no-for-of-loops
        var _iterator = renderer_createForOfIteratorHelper(hideElementsWithDisplayNames),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            const displayNameRegExp = _step.value;

            if (displayNameRegExp.test(displayName)) {
              return true;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }

    if (_debugSource != null && hideElementsWithPaths.size > 0) {
      const fileName = _debugSource.fileName; // eslint-disable-next-line no-for-of-loops/no-for-of-loops

      var _iterator2 = renderer_createForOfIteratorHelper(hideElementsWithPaths),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          const pathRegExp = _step2.value;

          if (pathRegExp.test(fileName)) {
            return true;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }

    return false;
  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods


  function getElementTypeForFiber(fiber) {
    const type = fiber.type,
          tag = fiber.tag;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
        return types["e" /* ElementTypeClass */];

      case FunctionComponent:
      case IndeterminateComponent:
        return types["h" /* ElementTypeFunction */];

      case ForwardRef:
        return types["g" /* ElementTypeForwardRef */];

      case HostRoot:
        return types["m" /* ElementTypeRoot */];

      case HostComponent:
        return types["i" /* ElementTypeHostComponent */];

      case HostPortal:
      case HostText:
      case Fragment:
        return types["k" /* ElementTypeOtherOrUnknown */];

      case MemoComponent:
      case SimpleMemoComponent:
        return types["j" /* ElementTypeMemo */];

      case SuspenseComponent:
        return types["n" /* ElementTypeSuspense */];

      case SuspenseListComponent:
        return types["o" /* ElementTypeSuspenseList */];

      default:
        const typeSymbol = getTypeSymbol(type);

        switch (typeSymbol) {
          case CONCURRENT_MODE_NUMBER:
          case CONCURRENT_MODE_SYMBOL_STRING:
          case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:
            return types["k" /* ElementTypeOtherOrUnknown */];

          case PROVIDER_NUMBER:
          case PROVIDER_SYMBOL_STRING:
            return types["f" /* ElementTypeContext */];

          case CONTEXT_NUMBER:
          case CONTEXT_SYMBOL_STRING:
            return types["f" /* ElementTypeContext */];

          case STRICT_MODE_NUMBER:
          case STRICT_MODE_SYMBOL_STRING:
            return types["k" /* ElementTypeOtherOrUnknown */];

          case PROFILER_NUMBER:
          case PROFILER_SYMBOL_STRING:
            return types["l" /* ElementTypeProfiler */];

          default:
            return types["k" /* ElementTypeOtherOrUnknown */];
        }

    }
  } // This is a slightly annoying indirection.
  // It is currently necessary because DevTools wants to use unique objects as keys for instances.
  // However fibers have two versions.
  // We use this set to remember first encountered fiber for each conceptual instance.


  function getPrimaryFiber(fiber) {
    if (primaryFibers.has(fiber)) {
      return fiber;
    }

    const alternate = fiber.alternate;

    if (alternate != null && primaryFibers.has(alternate)) {
      return alternate;
    }

    primaryFibers.add(fiber);
    return fiber;
  }

  const fiberToIDMap = new Map();
  const idToFiberMap = new Map();
  const primaryFibers = new Set(); // When profiling is supported, we store the latest tree base durations for each Fiber.
  // This is so that we can quickly capture a snapshot of those values if profiling starts.
  // If we didn't store these values, we'd have to crawl the tree when profiling started,
  // and use a slow path to find each of the current Fibers.

  const idToTreeBaseDurationMap = new Map(); // When profiling is supported, we store the latest tree base durations for each Fiber.
  // This map enables us to filter these times by root when sending them to the frontend.

  const idToRootMap = new Map(); // When a mount or update is in progress, this value tracks the root that is being operated on.

  let currentRootID = -1;

  function getFiberID(primaryFiber) {
    if (!fiberToIDMap.has(primaryFiber)) {
      const id = Object(utils["l" /* getUID */])();
      fiberToIDMap.set(primaryFiber, id);
      idToFiberMap.set(id, primaryFiber);
    }

    return fiberToIDMap.get(primaryFiber);
  }

  function getChangeDescription(prevFiber, nextFiber) {
    switch (getElementTypeForFiber(nextFiber)) {
      case types["e" /* ElementTypeClass */]:
      case types["h" /* ElementTypeFunction */]:
      case types["j" /* ElementTypeMemo */]:
      case types["g" /* ElementTypeForwardRef */]:
        if (prevFiber === null) {
          return {
            context: null,
            didHooksChange: false,
            isFirstMount: true,
            props: null,
            state: null
          };
        } else {
          return {
            context: getContextChangedKeys(nextFiber),
            didHooksChange: didHooksChange(prevFiber.memoizedState, nextFiber.memoizedState),
            isFirstMount: false,
            props: getChangedKeys(prevFiber.memoizedProps, nextFiber.memoizedProps),
            state: getChangedKeys(prevFiber.memoizedState, nextFiber.memoizedState)
          };
        }

      default:
        return null;
    }
  }

  function updateContextsForFiber(fiber) {
    switch (getElementTypeForFiber(fiber)) {
      case types["e" /* ElementTypeClass */]:
        if (idToContextsMap !== null) {
          const id = getFiberID(getPrimaryFiber(fiber));
          const contexts = getContextsForFiber(fiber);

          if (contexts !== null) {
            idToContextsMap.set(id, contexts);
          }
        }

        break;

      default:
        break;
    }
  } // Differentiates between a null context value and no context.


  const NO_CONTEXT = {};

  function getContextsForFiber(fiber) {
    switch (getElementTypeForFiber(fiber)) {
      case types["e" /* ElementTypeClass */]:
        const instance = fiber.stateNode;
        let legacyContext = NO_CONTEXT;
        let modernContext = NO_CONTEXT;

        if (instance != null) {
          if (instance.constructor && instance.constructor.contextType != null) {
            modernContext = instance.context;
          } else {
            legacyContext = instance.context;

            if (legacyContext && Object.keys(legacyContext).length === 0) {
              legacyContext = NO_CONTEXT;
            }
          }
        }

        return [legacyContext, modernContext];

      default:
        return null;
    }
  } // Record all contexts at the time profiling is started.
  // Fibers only store the current context value,
  // so we need to track them separately in order to determine changed keys.


  function crawlToInitializeContextsMap(fiber) {
    updateContextsForFiber(fiber);
    let current = fiber.child;

    while (current !== null) {
      crawlToInitializeContextsMap(current);
      current = current.sibling;
    }
  }

  function getContextChangedKeys(fiber) {
    switch (getElementTypeForFiber(fiber)) {
      case types["e" /* ElementTypeClass */]:
        if (idToContextsMap !== null) {
          const id = getFiberID(getPrimaryFiber(fiber));
          const prevContexts = idToContextsMap.has(id) ? idToContextsMap.get(id) : null;
          const nextContexts = getContextsForFiber(fiber);

          if (prevContexts == null || nextContexts == null) {
            return null;
          }

          const _prevContexts = _slicedToArray(prevContexts, 2),
                prevLegacyContext = _prevContexts[0],
                prevModernContext = _prevContexts[1];

          const _nextContexts = _slicedToArray(nextContexts, 2),
                nextLegacyContext = _nextContexts[0],
                nextModernContext = _nextContexts[1];

          if (nextLegacyContext !== NO_CONTEXT) {
            return getChangedKeys(prevLegacyContext, nextLegacyContext);
          } else if (nextModernContext !== NO_CONTEXT) {
            return prevModernContext !== nextModernContext;
          }
        }

        break;

      default:
        break;
    }

    return null;
  }

  function didHooksChange(prev, next) {
    if (prev == null || next == null) {
      return false;
    } // We can't report anything meaningful for hooks changes.


    if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {
      while (next !== null) {
        if (next.memoizedState !== prev.memoizedState) {
          return true;
        } else {
          next = next.next;
          prev = prev.next;
        }
      }
    }

    return false;
  }

  function getChangedKeys(prev, next) {
    if (prev == null || next == null) {
      return null;
    } // We can't report anything meaningful for hooks changes.


    if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {
      return null;
    }

    const keys = new Set([...Object.keys(prev), ...Object.keys(next)]);
    const changedKeys = []; // eslint-disable-next-line no-for-of-loops/no-for-of-loops

    var _iterator3 = renderer_createForOfIteratorHelper(keys),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        const key = _step3.value;

        if (prev[key] !== next[key]) {
          changedKeys.push(key);
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    return changedKeys;
  } // eslint-disable-next-line no-unused-vars


  function didFiberRender(prevFiber, nextFiber) {
    switch (nextFiber.tag) {
      case ClassComponent:
      case FunctionComponent:
      case ContextConsumer:
      case MemoComponent:
      case SimpleMemoComponent:
        // For types that execute user code, we check PerformedWork effect.
        // We don't reflect bailouts (either referential or sCU) in DevTools.
        // eslint-disable-next-line no-bitwise
        return (getFiberFlags(nextFiber) & PerformedWork) === PerformedWork;
      // Note: ContextConsumer only gets PerformedWork effect in 16.3.3+
      // so it won't get highlighted with React 16.3.0 to 16.3.2.

      default:
        // For host components and other types, we compare inputs
        // to determine whether something is an update.
        return prevFiber.memoizedProps !== nextFiber.memoizedProps || prevFiber.memoizedState !== nextFiber.memoizedState || prevFiber.ref !== nextFiber.ref;
    }
  }

  const pendingOperations = [];
  const pendingRealUnmountedIDs = [];
  const pendingSimulatedUnmountedIDs = [];
  let pendingOperationsQueue = [];
  const pendingStringTable = new Map();
  let pendingStringTableLength = 0;
  let pendingUnmountedRootID = null;

  function pushOperation(op) {
    if (false) {}

    pendingOperations.push(op);
  }

  function flushPendingEvents(root) {
    if (pendingOperations.length === 0 && pendingRealUnmountedIDs.length === 0 && pendingSimulatedUnmountedIDs.length === 0 && pendingUnmountedRootID === null) {
      // If we aren't profiling, we can just bail out here.
      // No use sending an empty update over the bridge.
      //
      // The Profiler stores metadata for each commit and reconstructs the app tree per commit using:
      // (1) an initial tree snapshot and
      // (2) the operations array for each commit
      // Because of this, it's important that the operations and metadata arrays align,
      // So it's important not to omit even empty operations while profiling is active.
      if (!isProfiling) {
        return;
      }
    }

    const numUnmountIDs = pendingRealUnmountedIDs.length + pendingSimulatedUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);
    const operations = new Array( // Identify which renderer this update is coming from.
    2 + // [rendererID, rootFiberID]
    // How big is the string table?
    1 + // [stringTableLength]
    // Then goes the actual string table.
    pendingStringTableLength + ( // All unmounts are batched in a single message.
    // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]
    numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Regular operations
    pendingOperations.length); // Identify which renderer this update is coming from.
    // This enables roots to be mapped to renderers,
    // Which in turn enables fiber props, states, and hooks to be inspected.

    let i = 0;
    operations[i++] = rendererID;
    operations[i++] = currentRootID; // Use this ID in case the root was unmounted!
    // Now fill in the string table.
    // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]

    operations[i++] = pendingStringTableLength;
    pendingStringTable.forEach((value, key) => {
      operations[i++] = key.length;
      const encodedKey = Object(utils["t" /* utfEncodeString */])(key);

      for (let j = 0; j < encodedKey.length; j++) {
        operations[i + j] = encodedKey[j];
      }

      i += key.length;
    });

    if (numUnmountIDs > 0) {
      // All unmounts except roots are batched in a single message.
      operations[i++] = constants["m" /* TREE_OPERATION_REMOVE */]; // The first number is how many unmounted IDs we're gonna send.

      operations[i++] = numUnmountIDs; // Fill in the real unmounts in the reverse order.
      // They were inserted parents-first by React, but we want children-first.
      // So we traverse our array backwards.

      for (let j = pendingRealUnmountedIDs.length - 1; j >= 0; j--) {
        operations[i++] = pendingRealUnmountedIDs[j];
      } // Fill in the simulated unmounts (hidden Suspense subtrees) in their order.
      // (We want children to go before parents.)
      // They go *after* the real unmounts because we know for sure they won't be
      // children of already pushed "real" IDs. If they were, we wouldn't be able
      // to discover them during the traversal, as they would have been deleted.


      for (let j = 0; j < pendingSimulatedUnmountedIDs.length; j++) {
        operations[i + j] = pendingSimulatedUnmountedIDs[j];
      }

      i += pendingSimulatedUnmountedIDs.length; // The root ID should always be unmounted last.

      if (pendingUnmountedRootID !== null) {
        operations[i] = pendingUnmountedRootID;
        i++;
      }
    } // Fill in the rest of the operations.


    for (let j = 0; j < pendingOperations.length; j++) {
      operations[i + j] = pendingOperations[j];
    }

    i += pendingOperations.length; // Let the frontend know about tree operations.
    // The first value in this array will identify which root it corresponds to,
    // so we do no longer need to dispatch a separate root-committed event.

    if (pendingOperationsQueue !== null) {
      // Until the frontend has been connected, store the tree operations.
      // This will let us avoid walking the tree later when the frontend connects,
      // and it enables the Profiler's reload-and-profile functionality to work as well.
      pendingOperationsQueue.push(operations);
    } else {
      // If we've already connected to the frontend, just pass the operations through.
      hook.emit('operations', operations);
    }

    pendingOperations.length = 0;
    pendingRealUnmountedIDs.length = 0;
    pendingSimulatedUnmountedIDs.length = 0;
    pendingUnmountedRootID = null;
    pendingStringTable.clear();
    pendingStringTableLength = 0;
  }

  function getStringID(str) {
    if (str === null) {
      return 0;
    }

    const existingID = pendingStringTable.get(str);

    if (existingID !== undefined) {
      return existingID;
    }

    const stringID = pendingStringTable.size + 1;
    pendingStringTable.set(str, stringID); // The string table total length needs to account
    // both for the string length, and for the array item
    // that contains the length itself. Hence + 1.

    pendingStringTableLength += str.length + 1;
    return stringID;
  }

  function recordMount(fiber, parentFiber) {
    if (constants["q" /* __DEBUG__ */]) {
      debug('recordMount()', fiber, parentFiber);
    }

    const isRoot = fiber.tag === HostRoot;
    const id = getFiberID(getPrimaryFiber(fiber));
    const hasOwnerMetadata = fiber.hasOwnProperty('_debugOwner');
    const isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration');

    if (isRoot) {
      pushOperation(constants["l" /* TREE_OPERATION_ADD */]);
      pushOperation(id);
      pushOperation(types["m" /* ElementTypeRoot */]);
      pushOperation(isProfilingSupported ? 1 : 0);
      pushOperation(hasOwnerMetadata ? 1 : 0);

      if (isProfiling) {
        if (displayNamesByRootID !== null) {
          displayNamesByRootID.set(id, getDisplayNameForRoot(fiber));
        }
      }
    } else {
      const key = fiber.key;
      const displayName = getDisplayNameForFiber(fiber);
      const elementType = getElementTypeForFiber(fiber);
      const _debugOwner = fiber._debugOwner;
      const ownerID = _debugOwner != null ? getFiberID(getPrimaryFiber(_debugOwner)) : 0;
      const parentID = parentFiber ? getFiberID(getPrimaryFiber(parentFiber)) : 0;
      const displayNameStringID = getStringID(displayName); // This check is a guard to handle a React element that has been modified
      // in such a way as to bypass the default stringification of the "key" property.

      const keyString = key === null ? null : '' + key;
      const keyStringID = getStringID(keyString);
      pushOperation(constants["l" /* TREE_OPERATION_ADD */]);
      pushOperation(id);
      pushOperation(elementType);
      pushOperation(parentID);
      pushOperation(ownerID);
      pushOperation(displayNameStringID);
      pushOperation(keyStringID);
    }

    if (isProfilingSupported) {
      idToRootMap.set(id, currentRootID);
      recordProfilingDurations(fiber);
    }
  }

  function recordUnmount(fiber, isSimulated) {
    if (constants["q" /* __DEBUG__ */]) {
      debug('recordUnmount()', fiber);
    }

    if (trackedPathMatchFiber !== null) {
      // We're in the process of trying to restore previous selection.
      // If this fiber matched but is being unmounted, there's no use trying.
      // Reset the state so we don't keep holding onto it.
      if (fiber === trackedPathMatchFiber || fiber === trackedPathMatchFiber.alternate) {
        setTrackedPath(null);
      }
    }

    const isRoot = fiber.tag === HostRoot;
    const primaryFiber = getPrimaryFiber(fiber);

    if (!fiberToIDMap.has(primaryFiber)) {
      // If we've never seen this Fiber, it might be because
      // it is inside a non-current Suspense fragment tree,
      // and so the store is not even aware of it.
      // In that case we can just ignore it, or otherwise
      // there will be errors later on.
      primaryFibers.delete(primaryFiber); // TODO: this is fragile and can obscure actual bugs.

      return;
    }

    const id = getFiberID(primaryFiber);

    if (isRoot) {
      // Roots must be removed only after all children (pending and simulated) have been removed.
      // So we track it separately.
      pendingUnmountedRootID = id;
    } else if (!shouldFilterFiber(fiber)) {
      // To maintain child-first ordering,
      // we'll push it into one of these queues,
      // and later arrange them in the correct order.
      if (isSimulated) {
        pendingSimulatedUnmountedIDs.push(id);
      } else {
        pendingRealUnmountedIDs.push(id);
      }
    }

    fiberToIDMap.delete(primaryFiber);
    idToFiberMap.delete(id);
    primaryFibers.delete(primaryFiber);
    const isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration');

    if (isProfilingSupported) {
      idToRootMap.delete(id);
      idToTreeBaseDurationMap.delete(id);
    }
  }

  function mountFiberRecursively(fiber, parentFiber, traverseSiblings, traceNearestHostComponentUpdate) {
    if (constants["q" /* __DEBUG__ */]) {
      debug('mountFiberRecursively()', fiber, parentFiber);
    } // If we have the tree selection from previous reload, try to match this Fiber.
    // Also remember whether to do the same for siblings.


    const mightSiblingsBeOnTrackedPath = updateTrackedPathStateBeforeMount(fiber);
    const shouldIncludeInTree = !shouldFilterFiber(fiber);

    if (shouldIncludeInTree) {
      recordMount(fiber, parentFiber);
    }

    if (traceUpdatesEnabled) {
      if (traceNearestHostComponentUpdate) {
        const elementType = getElementTypeForFiber(fiber); // If an ancestor updated, we should mark the nearest host nodes for highlighting.

        if (elementType === types["i" /* ElementTypeHostComponent */]) {
          traceUpdatesForNodes.add(fiber.stateNode);
          traceNearestHostComponentUpdate = false;
        }
      } // We intentionally do not re-enable the traceNearestHostComponentUpdate flag in this branch,
      // because we don't want to highlight every host node inside of a newly mounted subtree.

    }

    const isSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent;

    if (isSuspense) {
      const isTimedOut = fiber.memoizedState !== null;

      if (isTimedOut) {
        // Special case: if Suspense mounts in a timed-out state,
        // get the fallback child from the inner fragment and mount
        // it as if it was our own child. Updates handle this too.
        const primaryChildFragment = fiber.child;
        const fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;
        const fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;

        if (fallbackChild !== null) {
          mountFiberRecursively(fallbackChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);
        }
      } else {
        let primaryChild = null;
        const areSuspenseChildrenConditionallyWrapped = OffscreenComponent === -1;

        if (areSuspenseChildrenConditionallyWrapped) {
          primaryChild = fiber.child;
        } else if (fiber.child !== null) {
          primaryChild = fiber.child.child;
        }

        if (primaryChild !== null) {
          mountFiberRecursively(primaryChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);
        }
      }
    } else {
      if (fiber.child !== null) {
        mountFiberRecursively(fiber.child, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);
      }
    } // We're exiting this Fiber now, and entering its siblings.
    // If we have selection to restore, we might need to re-activate tracking.


    updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath);

    if (traverseSiblings && fiber.sibling !== null) {
      mountFiberRecursively(fiber.sibling, parentFiber, true, traceNearestHostComponentUpdate);
    }
  } // We use this to simulate unmounting for Suspense trees
  // when we switch from primary to fallback.


  function unmountFiberChildrenRecursively(fiber) {
    if (constants["q" /* __DEBUG__ */]) {
      debug('unmountFiberChildrenRecursively()', fiber);
    } // We might meet a nested Suspense on our way.


    const isTimedOutSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent && fiber.memoizedState !== null;
    let child = fiber.child;

    if (isTimedOutSuspense) {
      // If it's showing fallback tree, let's traverse it instead.
      const primaryChildFragment = fiber.child;
      const fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null; // Skip over to the real Fiber child.

      child = fallbackChildFragment ? fallbackChildFragment.child : null;
    }

    while (child !== null) {
      // Record simulated unmounts children-first.
      // We skip nodes without return because those are real unmounts.
      if (child.return !== null) {
        unmountFiberChildrenRecursively(child);
        recordUnmount(child, true);
      }

      child = child.sibling;
    }
  }

  function recordProfilingDurations(fiber) {
    const id = getFiberID(getPrimaryFiber(fiber));
    const actualDuration = fiber.actualDuration,
          treeBaseDuration = fiber.treeBaseDuration;
    idToTreeBaseDurationMap.set(id, treeBaseDuration || 0);

    if (isProfiling) {
      const alternate = fiber.alternate; // It's important to update treeBaseDuration even if the current Fiber did not render,
      // because it's possible that one of its descendants did.

      if (alternate == null || treeBaseDuration !== alternate.treeBaseDuration) {
        // Tree base duration updates are included in the operations typed array.
        // So we have to convert them from milliseconds to microseconds so we can send them as ints.
        const convertedTreeBaseDuration = Math.floor((treeBaseDuration || 0) * 1000);
        pushOperation(constants["o" /* TREE_OPERATION_UPDATE_TREE_BASE_DURATION */]);
        pushOperation(id);
        pushOperation(convertedTreeBaseDuration);
      }

      if (alternate == null || didFiberRender(alternate, fiber)) {
        if (actualDuration != null) {
          // The actual duration reported by React includes time spent working on children.
          // This is useful information, but it's also useful to be able to exclude child durations.
          // The frontend can't compute this, since the immediate children may have been filtered out.
          // So we need to do this on the backend.
          // Note that this calculated self duration is not the same thing as the base duration.
          // The two are calculated differently (tree duration does not accumulate).
          let selfDuration = actualDuration;
          let child = fiber.child;

          while (child !== null) {
            selfDuration -= child.actualDuration || 0;
            child = child.sibling;
          } // If profiling is active, store durations for elements that were rendered during the commit.
          // Note that we should do this for any fiber we performed work on, regardless of its actualDuration value.
          // In some cases actualDuration might be 0 for fibers we worked on (particularly if we're using Date.now)
          // In other cases (e.g. Memo) actualDuration might be greater than 0 even if we "bailed out".


          const metadata = currentCommitProfilingMetadata;
          metadata.durations.push(id, actualDuration, selfDuration);
          metadata.maxActualDuration = Math.max(metadata.maxActualDuration, actualDuration);

          if (recordChangeDescriptions) {
            const changeDescription = getChangeDescription(alternate, fiber);

            if (changeDescription !== null) {
              if (metadata.changeDescriptions !== null) {
                metadata.changeDescriptions.set(id, changeDescription);
              }
            }

            updateContextsForFiber(fiber);
          }
        }
      }
    }
  }

  function recordResetChildren(fiber, childSet) {
    if (constants["q" /* __DEBUG__ */]) {
      debug('recordResetChildren()', childSet, fiber);
    } // The frontend only really cares about the displayName, key, and children.
    // The first two don't really change, so we are only concerned with the order of children here.
    // This is trickier than a simple comparison though, since certain types of fibers are filtered.


    const nextChildren = []; // This is a naive implementation that shallowly recourses children.
    // We might want to revisit this if it proves to be too inefficient.

    let child = childSet;

    while (child !== null) {
      findReorderedChildrenRecursively(child, nextChildren);
      child = child.sibling;
    }

    const numChildren = nextChildren.length;

    if (numChildren < 2) {
      // No need to reorder.
      return;
    }

    pushOperation(constants["n" /* TREE_OPERATION_REORDER_CHILDREN */]);
    pushOperation(getFiberID(getPrimaryFiber(fiber)));
    pushOperation(numChildren);

    for (let i = 0; i < nextChildren.length; i++) {
      pushOperation(nextChildren[i]);
    }
  }

  function findReorderedChildrenRecursively(fiber, nextChildren) {
    if (!shouldFilterFiber(fiber)) {
      nextChildren.push(getFiberID(getPrimaryFiber(fiber)));
    } else {
      let child = fiber.child;
      const isTimedOutSuspense = fiber.tag === SuspenseComponent && fiber.memoizedState !== null;

      if (isTimedOutSuspense) {
        // Special case: if Suspense mounts in a timed-out state,
        // get the fallback child from the inner fragment,
        // and skip over the primary child.
        const primaryChildFragment = fiber.child;
        const fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;
        const fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;

        if (fallbackChild !== null) {
          child = fallbackChild;
        }
      }

      while (child !== null) {
        findReorderedChildrenRecursively(child, nextChildren);
        child = child.sibling;
      }
    }
  } // Returns whether closest unfiltered fiber parent needs to reset its child list.


  function updateFiberRecursively(nextFiber, prevFiber, parentFiber, traceNearestHostComponentUpdate) {
    if (constants["q" /* __DEBUG__ */]) {
      debug('updateFiberRecursively()', nextFiber, parentFiber);
    }

    if (traceUpdatesEnabled) {
      const elementType = getElementTypeForFiber(nextFiber);

      if (traceNearestHostComponentUpdate) {
        // If an ancestor updated, we should mark the nearest host nodes for highlighting.
        if (elementType === types["i" /* ElementTypeHostComponent */]) {
          traceUpdatesForNodes.add(nextFiber.stateNode);
          traceNearestHostComponentUpdate = false;
        }
      } else {
        if (elementType === types["h" /* ElementTypeFunction */] || elementType === types["e" /* ElementTypeClass */] || elementType === types["f" /* ElementTypeContext */]) {
          // Otherwise if this is a traced ancestor, flag for the nearest host descendant(s).
          traceNearestHostComponentUpdate = didFiberRender(prevFiber, nextFiber);
        }
      }
    }

    if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === getFiberID(getPrimaryFiber(nextFiber)) && didFiberRender(prevFiber, nextFiber)) {
      // If this Fiber has updated, clear cached inspected data.
      // If it is inspected again, it may need to be re-run to obtain updated hooks values.
      hasElementUpdatedSinceLastInspected = true;
    }

    const shouldIncludeInTree = !shouldFilterFiber(nextFiber);
    const isSuspense = nextFiber.tag === SuspenseComponent;
    let shouldResetChildren = false; // The behavior of timed-out Suspense trees is unique.
    // Rather than unmount the timed out content (and possibly lose important state),
    // React re-parents this content within a hidden Fragment while the fallback is showing.
    // This behavior doesn't need to be observable in the DevTools though.
    // It might even result in a bad user experience for e.g. node selection in the Elements panel.
    // The easiest fix is to strip out the intermediate Fragment fibers,
    // so the Elements panel and Profiler don't need to special case them.
    // Suspense components only have a non-null memoizedState if they're timed-out.

    const prevDidTimeout = isSuspense && prevFiber.memoizedState !== null;
    const nextDidTimeOut = isSuspense && nextFiber.memoizedState !== null; // The logic below is inspired by the code paths in updateSuspenseComponent()
    // inside ReactFiberBeginWork in the React source code.

    if (prevDidTimeout && nextDidTimeOut) {
      // Fallback -> Fallback:
      // 1. Reconcile fallback set.
      const nextFiberChild = nextFiber.child;
      const nextFallbackChildSet = nextFiberChild ? nextFiberChild.sibling : null; // Note: We can't use nextFiber.child.sibling.alternate
      // because the set is special and alternate may not exist.

      const prevFiberChild = prevFiber.child;
      const prevFallbackChildSet = prevFiberChild ? prevFiberChild.sibling : null;

      if (nextFallbackChildSet != null && prevFallbackChildSet != null && updateFiberRecursively(nextFallbackChildSet, prevFallbackChildSet, nextFiber, traceNearestHostComponentUpdate)) {
        shouldResetChildren = true;
      }
    } else if (prevDidTimeout && !nextDidTimeOut) {
      // Fallback -> Primary:
      // 1. Unmount fallback set
      // Note: don't emulate fallback unmount because React actually did it.
      // 2. Mount primary set
      const nextPrimaryChildSet = nextFiber.child;

      if (nextPrimaryChildSet !== null) {
        mountFiberRecursively(nextPrimaryChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);
      }

      shouldResetChildren = true;
    } else if (!prevDidTimeout && nextDidTimeOut) {
      // Primary -> Fallback:
      // 1. Hide primary set
      // This is not a real unmount, so it won't get reported by React.
      // We need to manually walk the previous tree and record unmounts.
      unmountFiberChildrenRecursively(prevFiber); // 2. Mount fallback set

      const nextFiberChild = nextFiber.child;
      const nextFallbackChildSet = nextFiberChild ? nextFiberChild.sibling : null;

      if (nextFallbackChildSet != null) {
        mountFiberRecursively(nextFallbackChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);
        shouldResetChildren = true;
      }
    } else {
      // Common case: Primary -> Primary.
      // This is the same code path as for non-Suspense fibers.
      if (nextFiber.child !== prevFiber.child) {
        // If the first child is different, we need to traverse them.
        // Each next child will be either a new child (mount) or an alternate (update).
        let nextChild = nextFiber.child;
        let prevChildAtSameIndex = prevFiber.child;

        while (nextChild) {
          // We already know children will be referentially different because
          // they are either new mounts or alternates of previous children.
          // Schedule updates and mounts depending on whether alternates exist.
          // We don't track deletions here because they are reported separately.
          if (nextChild.alternate) {
            const prevChild = nextChild.alternate;

            if (updateFiberRecursively(nextChild, prevChild, shouldIncludeInTree ? nextFiber : parentFiber, traceNearestHostComponentUpdate)) {
              // If a nested tree child order changed but it can't handle its own
              // child order invalidation (e.g. because it's filtered out like host nodes),
              // propagate the need to reset child order upwards to this Fiber.
              shouldResetChildren = true;
            } // However we also keep track if the order of the children matches
            // the previous order. They are always different referentially, but
            // if the instances line up conceptually we'll want to know that.


            if (prevChild !== prevChildAtSameIndex) {
              shouldResetChildren = true;
            }
          } else {
            mountFiberRecursively(nextChild, shouldIncludeInTree ? nextFiber : parentFiber, false, traceNearestHostComponentUpdate);
            shouldResetChildren = true;
          } // Try the next child.


          nextChild = nextChild.sibling; // Advance the pointer in the previous list so that we can
          // keep comparing if they line up.

          if (!shouldResetChildren && prevChildAtSameIndex !== null) {
            prevChildAtSameIndex = prevChildAtSameIndex.sibling;
          }
        } // If we have no more children, but used to, they don't line up.


        if (prevChildAtSameIndex !== null) {
          shouldResetChildren = true;
        }
      } else {
        if (traceUpdatesEnabled) {
          // If we're tracing updates and we've bailed out before reaching a host node,
          // we should fall back to recursively marking the nearest host descendants for highlight.
          if (traceNearestHostComponentUpdate) {
            const hostFibers = findAllCurrentHostFibers(getFiberID(getPrimaryFiber(nextFiber)));
            hostFibers.forEach(hostFiber => {
              traceUpdatesForNodes.add(hostFiber.stateNode);
            });
          }
        }
      }
    }

    if (shouldIncludeInTree) {
      const isProfilingSupported = nextFiber.hasOwnProperty('treeBaseDuration');

      if (isProfilingSupported) {
        recordProfilingDurations(nextFiber);
      }
    }

    if (shouldResetChildren) {
      // We need to crawl the subtree for closest non-filtered Fibers
      // so that we can display them in a flat children set.
      if (shouldIncludeInTree) {
        // Normally, search for children from the rendered child.
        let nextChildSet = nextFiber.child;

        if (nextDidTimeOut) {
          // Special case: timed-out Suspense renders the fallback set.
          const nextFiberChild = nextFiber.child;
          nextChildSet = nextFiberChild ? nextFiberChild.sibling : null;
        }

        if (nextChildSet != null) {
          recordResetChildren(nextFiber, nextChildSet);
        } // We've handled the child order change for this Fiber.
        // Since it's included, there's no need to invalidate parent child order.


        return false;
      } else {
        // Let the closest unfiltered parent Fiber reset its child order instead.
        return true;
      }
    } else {
      return false;
    }
  }

  function cleanup() {// We don't patch any methods so there is no cleanup.
  }

  function flushInitialOperations() {
    const localPendingOperationsQueue = pendingOperationsQueue;
    pendingOperationsQueue = null;

    if (localPendingOperationsQueue !== null && localPendingOperationsQueue.length > 0) {
      // We may have already queued up some operations before the frontend connected
      // If so, let the frontend know about them.
      localPendingOperationsQueue.forEach(operations => {
        hook.emit('operations', operations);
      });
    } else {
      // Before the traversals, remember to start tracking
      // our path in case we have selection to restore.
      if (trackedPath !== null) {
        mightBeOnTrackedPath = true;
      } // If we have not been profiling, then we can just walk the tree and build up its current state as-is.


      hook.getFiberRoots(rendererID).forEach(root => {
        currentRootID = getFiberID(getPrimaryFiber(root.current));
        setRootPseudoKey(currentRootID, root.current); // Checking root.memoizedInteractions handles multi-renderer edge-case-
        // where some v16 renderers support profiling and others don't.

        if (isProfiling && root.memoizedInteractions != null) {
          // If profiling is active, store commit time and duration, and the current interactions.
          // The frontend may request this information after profiling has stopped.
          currentCommitProfilingMetadata = {
            changeDescriptions: recordChangeDescriptions ? new Map() : null,
            durations: [],
            commitTime: renderer_getCurrentTime() - profilingStartTime,
            interactions: Array.from(root.memoizedInteractions).map(interaction => renderer_objectSpread(renderer_objectSpread({}, interaction), {}, {
              timestamp: interaction.timestamp - profilingStartTime
            })),
            maxActualDuration: 0,
            priorityLevel: null
          };
        }

        mountFiberRecursively(root.current, null, false, false);
        flushPendingEvents(root);
        currentRootID = -1;
      });
    }
  }

  function handleCommitFiberUnmount(fiber) {
    // This is not recursive.
    // We can't traverse fibers after unmounting so instead
    // we rely on React telling us about each unmount.
    recordUnmount(fiber, false);
  }

  function handleCommitFiberRoot(root, priorityLevel) {
    const current = root.current;
    const alternate = current.alternate;
    currentRootID = getFiberID(getPrimaryFiber(current)); // Before the traversals, remember to start tracking
    // our path in case we have selection to restore.

    if (trackedPath !== null) {
      mightBeOnTrackedPath = true;
    }

    if (traceUpdatesEnabled) {
      traceUpdatesForNodes.clear();
    } // Checking root.memoizedInteractions handles multi-renderer edge-case-
    // where some v16 renderers support profiling and others don't.


    const isProfilingSupported = root.memoizedInteractions != null;

    if (isProfiling && isProfilingSupported) {
      // If profiling is active, store commit time and duration, and the current interactions.
      // The frontend may request this information after profiling has stopped.
      currentCommitProfilingMetadata = {
        changeDescriptions: recordChangeDescriptions ? new Map() : null,
        durations: [],
        commitTime: renderer_getCurrentTime() - profilingStartTime,
        interactions: Array.from(root.memoizedInteractions).map(interaction => renderer_objectSpread(renderer_objectSpread({}, interaction), {}, {
          timestamp: interaction.timestamp - profilingStartTime
        })),
        maxActualDuration: 0,
        priorityLevel: priorityLevel == null ? null : formatPriorityLevel(priorityLevel)
      };
    }

    if (alternate) {
      // TODO: relying on this seems a bit fishy.
      const wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;
      const isMounted = current.memoizedState != null && current.memoizedState.element != null;

      if (!wasMounted && isMounted) {
        // Mount a new root.
        setRootPseudoKey(currentRootID, current);
        mountFiberRecursively(current, null, false, false);
      } else if (wasMounted && isMounted) {
        // Update an existing root.
        updateFiberRecursively(current, alternate, null, false);
      } else if (wasMounted && !isMounted) {
        // Unmount an existing root.
        removeRootPseudoKey(currentRootID);
        recordUnmount(current, false);
      }
    } else {
      // Mount a new root.
      setRootPseudoKey(currentRootID, current);
      mountFiberRecursively(current, null, false, false);
    }

    if (isProfiling && isProfilingSupported) {
      const commitProfilingMetadata = rootToCommitProfilingMetadataMap.get(currentRootID);

      if (commitProfilingMetadata != null) {
        commitProfilingMetadata.push(currentCommitProfilingMetadata);
      } else {
        rootToCommitProfilingMetadataMap.set(currentRootID, [currentCommitProfilingMetadata]);
      }
    } // We're done here.


    flushPendingEvents(root);

    if (traceUpdatesEnabled) {
      hook.emit('traceUpdates', traceUpdatesForNodes);
    }

    currentRootID = -1;
  }

  function findAllCurrentHostFibers(id) {
    const fibers = [];
    const fiber = findCurrentFiberUsingSlowPathById(id);

    if (!fiber) {
      return fibers;
    } // Next we'll drill down this component to find all HostComponent/Text.


    let node = fiber;

    while (true) {
      if (node.tag === HostComponent || node.tag === HostText) {
        fibers.push(node);
      } else if (node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === fiber) {
        return fibers;
      }

      while (!node.sibling) {
        if (!node.return || node.return === fiber) {
          return fibers;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    } // Flow needs the return here, but ESLint complains about it.
    // eslint-disable-next-line no-unreachable


    return fibers;
  }

  function findNativeNodesForFiberID(id) {
    try {
      let fiber = findCurrentFiberUsingSlowPathById(id);

      if (fiber === null) {
        return null;
      } // Special case for a timed-out Suspense.


      const isTimedOutSuspense = fiber.tag === SuspenseComponent && fiber.memoizedState !== null;

      if (isTimedOutSuspense) {
        // A timed-out Suspense's findDOMNode is useless.
        // Try our best to find the fallback directly.
        const maybeFallbackFiber = fiber.child && fiber.child.sibling;

        if (maybeFallbackFiber != null) {
          fiber = maybeFallbackFiber;
        }
      }

      const hostFibers = findAllCurrentHostFibers(id);
      return hostFibers.map(hostFiber => hostFiber.stateNode).filter(Boolean);
    } catch (err) {
      // The fiber might have unmounted by now.
      return null;
    }
  }

  function getDisplayNameForFiberID(id) {
    const fiber = idToFiberMap.get(id);
    return fiber != null ? getDisplayNameForFiber(fiber) : null;
  }

  function getFiberIDForNative(hostInstance, findNearestUnfilteredAncestor = false) {
    let fiber = renderer.findFiberByHostInstance(hostInstance);

    if (fiber != null) {
      if (findNearestUnfilteredAncestor) {
        while (fiber !== null && shouldFilterFiber(fiber)) {
          fiber = fiber.return;
        }
      }

      return getFiberID(getPrimaryFiber(fiber));
    }

    return null;
  }

  const MOUNTING = 1;
  const MOUNTED = 2;
  const UNMOUNTED = 3; // This function is copied from React and should be kept in sync:
  // https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberTreeReflection.js

  function isFiberMountedImpl(fiber) {
    let node = fiber;

    if (!fiber.alternate) {
      // If there is no alternate, this might be a new tree that isn't inserted
      // yet. If it is, then it will have a pending insertion effect on it.
      if ((getFiberFlags(node) & Placement) !== NoFlags) {
        return MOUNTING;
      }

      while (node.return) {
        node = node.return;

        if ((getFiberFlags(node) & Placement) !== NoFlags) {
          return MOUNTING;
        }
      }
    } else {
      while (node.return) {
        node = node.return;
      }
    }

    if (node.tag === HostRoot) {
      // TODO: Check if this was a nested HostRoot when used with
      // renderContainerIntoSubtree.
      return MOUNTED;
    } // If we didn't hit the root, that means that we're in an disconnected tree
    // that has been unmounted.


    return UNMOUNTED;
  } // This function is copied from React and should be kept in sync:
  // https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberTreeReflection.js
  // It would be nice if we updated React to inject this function directly (vs just indirectly via findDOMNode).
  // BEGIN copied code


  function findCurrentFiberUsingSlowPathById(id) {
    const fiber = idToFiberMap.get(id);

    if (fiber == null) {
      console.warn(`Could not find Fiber with id "${id}"`);
      return null;
    }

    const alternate = fiber.alternate;

    if (!alternate) {
      // If there is no alternate, then we only need to check if it is mounted.
      const state = isFiberMountedImpl(fiber);

      if (state === UNMOUNTED) {
        throw Error('Unable to find node on an unmounted component.');
      }

      if (state === MOUNTING) {
        return null;
      }

      return fiber;
    } // If we have two possible branches, we'll walk backwards up to the root
    // to see what path the root points to. On the way we may hit one of the
    // special cases and we'll deal with them.


    let a = fiber;
    let b = alternate;

    while (true) {
      const parentA = a.return;

      if (parentA === null) {
        // We're at the root.
        break;
      }

      const parentB = parentA.alternate;

      if (parentB === null) {
        // There is no alternate. This is an unusual case. Currently, it only
        // happens when a Suspense component is hidden. An extra fragment fiber
        // is inserted in between the Suspense fiber and its children. Skip
        // over this extra fragment fiber and proceed to the next parent.
        const nextParent = parentA.return;

        if (nextParent !== null) {
          a = b = nextParent;
          continue;
        } // If there's no parent, we're at the root.


        break;
      } // If both copies of the parent fiber point to the same child, we can
      // assume that the child is current. This happens when we bailout on low
      // priority: the bailed out fiber's child reuses the current child.


      if (parentA.child === parentB.child) {
        let child = parentA.child;

        while (child) {
          if (child === a) {
            // We've determined that A is the current branch.
            if (isFiberMountedImpl(parentA) !== MOUNTED) {
              throw Error('Unable to find node on an unmounted component.');
            }

            return fiber;
          }

          if (child === b) {
            // We've determined that B is the current branch.
            if (isFiberMountedImpl(parentA) !== MOUNTED) {
              throw Error('Unable to find node on an unmounted component.');
            }

            return alternate;
          }

          child = child.sibling;
        } // We should never have an alternate for any mounting node. So the only
        // way this could possibly happen is if this was unmounted, if at all.


        throw Error('Unable to find node on an unmounted component.');
      }

      if (a.return !== b.return) {
        // The return pointer of A and the return pointer of B point to different
        // fibers. We assume that return pointers never criss-cross, so A must
        // belong to the child set of A.return, and B must belong to the child
        // set of B.return.
        a = parentA;
        b = parentB;
      } else {
        // The return pointers point to the same fiber. We'll have to use the
        // default, slow path: scan the child sets of each parent alternate to see
        // which child belongs to which set.
        //
        // Search parent A's child set
        let didFindChild = false;
        let child = parentA.child;

        while (child) {
          if (child === a) {
            didFindChild = true;
            a = parentA;
            b = parentB;
            break;
          }

          if (child === b) {
            didFindChild = true;
            b = parentA;
            a = parentB;
            break;
          }

          child = child.sibling;
        }

        if (!didFindChild) {
          // Search parent B's child set
          child = parentB.child;

          while (child) {
            if (child === a) {
              didFindChild = true;
              a = parentB;
              b = parentA;
              break;
            }

            if (child === b) {
              didFindChild = true;
              b = parentB;
              a = parentA;
              break;
            }

            child = child.sibling;
          }

          if (!didFindChild) {
            throw Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');
          }
        }
      }

      if (a.alternate !== b) {
        throw Error("Return fibers should always be each others' alternates. " + 'This error is likely caused by a bug in React. Please file an issue.');
      }
    } // If the root is not a host container, we're in a disconnected tree. I.e.
    // unmounted.


    if (a.tag !== HostRoot) {
      throw Error('Unable to find node on an unmounted component.');
    }

    if (a.stateNode.current === a) {
      // We've determined that A is the current branch.
      return fiber;
    } // Otherwise B has to be current branch.


    return alternate;
  } // END copied code


  function prepareViewAttributeSource(id, path) {
    const isCurrent = isMostRecentlyInspectedElementCurrent(id);

    if (isCurrent) {
      window.$attribute = Object(utils["j" /* getInObject */])(mostRecentlyInspectedElement, path);
    }
  }

  function prepareViewElementSource(id) {
    const fiber = idToFiberMap.get(id);

    if (fiber == null) {
      console.warn(`Could not find Fiber with id "${id}"`);
      return;
    }

    const elementType = fiber.elementType,
          tag = fiber.tag,
          type = fiber.type;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
      case IndeterminateComponent:
      case FunctionComponent:
        global.$type = type;
        break;

      case ForwardRef:
        global.$type = type.render;
        break;

      case MemoComponent:
      case SimpleMemoComponent:
        global.$type = elementType != null && elementType.type != null ? elementType.type : type;
        break;

      default:
        global.$type = null;
        break;
    }
  }

  function getOwnersList(id) {
    const fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber == null) {
      return null;
    }

    const _debugOwner = fiber._debugOwner;
    const owners = [{
      displayName: getDisplayNameForFiber(fiber) || 'Anonymous',
      id,
      type: getElementTypeForFiber(fiber)
    }];

    if (_debugOwner) {
      let owner = _debugOwner;

      while (owner !== null) {
        owners.unshift({
          displayName: getDisplayNameForFiber(owner) || 'Anonymous',
          id: getFiberID(getPrimaryFiber(owner)),
          type: getElementTypeForFiber(owner)
        });
        owner = owner._debugOwner || null;
      }
    }

    return owners;
  } // Fast path props lookup for React Native style editor.
  // Could use inspectElementRaw() but that would require shallow rendering hooks components,
  // and could also mess with memoization.


  function getInstanceAndStyle(id) {
    let instance = null;
    let style = null;
    const fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      instance = fiber.stateNode;

      if (fiber.memoizedProps !== null) {
        style = fiber.memoizedProps.style;
      }
    }

    return {
      instance,
      style
    };
  }

  function inspectElementRaw(id) {
    const fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber == null) {
      return null;
    }

    const _debugOwner = fiber._debugOwner,
          _debugSource = fiber._debugSource,
          stateNode = fiber.stateNode,
          key = fiber.key,
          memoizedProps = fiber.memoizedProps,
          memoizedState = fiber.memoizedState,
          dependencies = fiber.dependencies,
          tag = fiber.tag,
          type = fiber.type;
    const elementType = getElementTypeForFiber(fiber);
    const usesHooks = (tag === FunctionComponent || tag === SimpleMemoComponent || tag === ForwardRef) && (!!memoizedState || !!dependencies);
    const typeSymbol = getTypeSymbol(type);
    let canViewSource = false;
    let context = null;

    if (tag === ClassComponent || tag === FunctionComponent || tag === IncompleteClassComponent || tag === IndeterminateComponent || tag === MemoComponent || tag === ForwardRef || tag === SimpleMemoComponent) {
      canViewSource = true;

      if (stateNode && stateNode.context != null) {
        // Don't show an empty context object for class components that don't use the context API.
        const shouldHideContext = elementType === types["e" /* ElementTypeClass */] && !(type.contextTypes || type.contextType);

        if (!shouldHideContext) {
          context = stateNode.context;
        }
      }
    } else if (typeSymbol === CONTEXT_NUMBER || typeSymbol === CONTEXT_SYMBOL_STRING) {
      // 16.3-16.5 read from "type" because the Consumer is the actual context object.
      // 16.6+ should read from "type._context" because Consumer can be different (in DEV).
      // NOTE Keep in sync with getDisplayNameForFiber()
      const consumerResolvedContext = type._context || type; // Global context value.

      context = consumerResolvedContext._currentValue || null; // Look for overridden value.

      let current = fiber.return;

      while (current !== null) {
        const currentType = current.type;
        const currentTypeSymbol = getTypeSymbol(currentType);

        if (currentTypeSymbol === PROVIDER_NUMBER || currentTypeSymbol === PROVIDER_SYMBOL_STRING) {
          // 16.3.0 exposed the context object as "context"
          // PR #12501 changed it to "_context" for 16.3.1+
          // NOTE Keep in sync with getDisplayNameForFiber()
          const providerResolvedContext = currentType._context || currentType.context;

          if (providerResolvedContext === consumerResolvedContext) {
            context = current.memoizedProps.value;
            break;
          }
        }

        current = current.return;
      }
    }

    let hasLegacyContext = false;

    if (context !== null) {
      hasLegacyContext = !!type.contextTypes; // To simplify hydration and display logic for context, wrap in a value object.
      // Otherwise simple values (e.g. strings, booleans) become harder to handle.

      context = {
        value: context
      };
    }

    let owners = null;

    if (_debugOwner) {
      owners = [];
      let owner = _debugOwner;

      while (owner !== null) {
        owners.push({
          displayName: getDisplayNameForFiber(owner) || 'Anonymous',
          id: getFiberID(getPrimaryFiber(owner)),
          type: getElementTypeForFiber(owner)
        });
        owner = owner._debugOwner || null;
      }
    }

    const isTimedOutSuspense = tag === SuspenseComponent && memoizedState !== null;
    let hooks = null;

    if (usesHooks) {
      const originalConsoleMethods = {}; // Temporarily disable all console logging before re-running the hook.

      for (const method in console) {
        try {
          originalConsoleMethods[method] = console[method]; // $FlowFixMe property error|warn is not writable.

          console[method] = () => {};
        } catch (error) {}
      }

      try {
        hooks = inspectHooksOfFiber(fiber, renderer.currentDispatcherRef);
      } finally {
        // Restore original console functionality.
        for (const method in originalConsoleMethods) {
          try {
            // $FlowFixMe property error|warn is not writable.
            console[method] = originalConsoleMethods[method];
          } catch (error) {}
        }
      }
    }

    let rootType = null;
    let current = fiber;

    while (current.return !== null) {
      current = current.return;
    }

    const fiberRoot = current.stateNode;

    if (fiberRoot != null && fiberRoot._debugRootType !== null) {
      rootType = fiberRoot._debugRootType;
    }

    return {
      id,
      // Does the current renderer support editable hooks and function props?
      canEditHooks: typeof overrideHookState === 'function',
      canEditFunctionProps: typeof overrideProps === 'function',
      // Does the current renderer support advanced editing interface?
      canEditHooksAndDeletePaths: typeof overrideHookStateDeletePath === 'function',
      canEditHooksAndRenamePaths: typeof overrideHookStateRenamePath === 'function',
      canEditFunctionPropsDeletePaths: typeof overridePropsDeletePath === 'function',
      canEditFunctionPropsRenamePaths: typeof overridePropsRenamePath === 'function',
      canToggleSuspense: supportsTogglingSuspense && ( // If it's showing the real content, we can always flip fallback.
      !isTimedOutSuspense || // If it's showing fallback because we previously forced it to,
      // allow toggling it back to remove the fallback override.
      forceFallbackForSuspenseIDs.has(id)),
      // Can view component source location.
      canViewSource,
      // Does the component have legacy context attached to it.
      hasLegacyContext,
      key: key != null ? key : null,
      displayName: getDisplayNameForFiber(fiber),
      type: elementType,
      // Inspectable properties.
      // TODO Review sanitization approach for the below inspectable values.
      context,
      hooks,
      props: memoizedProps,
      state: usesHooks ? null : memoizedState,
      // List of owners
      owners,
      // Location of component in source code.
      source: _debugSource || null,
      rootType,
      rendererPackageName: renderer.rendererPackageName,
      rendererVersion: renderer.version
    };
  }

  let mostRecentlyInspectedElement = null;
  let hasElementUpdatedSinceLastInspected = false;
  let currentlyInspectedPaths = {};

  function isMostRecentlyInspectedElementCurrent(id) {
    return mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id && !hasElementUpdatedSinceLastInspected;
  } // Track the intersection of currently inspected paths,
  // so that we can send their data along if the element is re-rendered.


  function mergeInspectedPaths(path) {
    let current = currentlyInspectedPaths;
    path.forEach(key => {
      if (!current[key]) {
        current[key] = {};
      }

      current = current[key];
    });
  }

  function createIsPathAllowed(key, secondaryCategory) {
    // This function helps prevent previously-inspected paths from being dehydrated in updates.
    // This is important to avoid a bad user experience where expanded toggles collapse on update.
    return function isPathAllowed(path) {
      switch (secondaryCategory) {
        case 'hooks':
          if (path.length === 1) {
            // Never dehydrate the "hooks" object at the top levels.
            return true;
          }

          if (path[path.length - 1] === 'subHooks' || path[path.length - 2] === 'subHooks') {
            // Dehydrating the 'subHooks' property makes the HooksTree UI a lot more complicated,
            // so it's easiest for now if we just don't break on this boundary.
            // We can always dehydrate a level deeper (in the value object).
            return true;
          }

          break;

        default:
          break;
      }

      let current = key === null ? currentlyInspectedPaths : currentlyInspectedPaths[key];

      if (!current) {
        return false;
      }

      for (let i = 0; i < path.length; i++) {
        current = current[path[i]];

        if (!current) {
          return false;
        }
      }

      return true;
    };
  }

  function updateSelectedElement(inspectedElement) {
    const hooks = inspectedElement.hooks,
          id = inspectedElement.id,
          props = inspectedElement.props;
    const fiber = idToFiberMap.get(id);

    if (fiber == null) {
      console.warn(`Could not find Fiber with id "${id}"`);
      return;
    }

    const elementType = fiber.elementType,
          stateNode = fiber.stateNode,
          tag = fiber.tag,
          type = fiber.type;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
      case IndeterminateComponent:
        global.$r = stateNode;
        break;

      case FunctionComponent:
        global.$r = {
          hooks,
          props,
          type
        };
        break;

      case ForwardRef:
        global.$r = {
          props,
          type: type.render
        };
        break;

      case MemoComponent:
      case SimpleMemoComponent:
        global.$r = {
          props,
          type: elementType != null && elementType.type != null ? elementType.type : type
        };
        break;

      default:
        global.$r = null;
        break;
    }
  }

  function storeAsGlobal(id, path, count) {
    const isCurrent = isMostRecentlyInspectedElementCurrent(id);

    if (isCurrent) {
      const value = Object(utils["j" /* getInObject */])(mostRecentlyInspectedElement, path);
      const key = `$reactTemp${count}`;
      window[key] = value;
      console.log(key);
      console.log(value);
    }
  }

  function copyElementPath(id, path) {
    const isCurrent = isMostRecentlyInspectedElementCurrent(id);

    if (isCurrent) {
      copyToClipboard(Object(utils["j" /* getInObject */])(mostRecentlyInspectedElement, path));
    }
  }

  function inspectElement(id, path) {
    const isCurrent = isMostRecentlyInspectedElementCurrent(id);

    if (isCurrent) {
      if (path != null) {
        mergeInspectedPaths(path);
        let secondaryCategory = null;

        if (path[0] === 'hooks') {
          secondaryCategory = 'hooks';
        } // If this element has not been updated since it was last inspected,
        // we can just return the subset of data in the newly-inspected path.


        return {
          id,
          type: 'hydrated-path',
          path,
          value: cleanForBridge(Object(utils["j" /* getInObject */])(mostRecentlyInspectedElement, path), createIsPathAllowed(null, secondaryCategory), path)
        };
      } else {
        // If this element has not been updated since it was last inspected, we don't need to re-run it.
        // Instead we can just return the ID to indicate that it has not changed.
        return {
          id,
          type: 'no-change'
        };
      }
    } else {
      hasElementUpdatedSinceLastInspected = false;

      if (mostRecentlyInspectedElement === null || mostRecentlyInspectedElement.id !== id) {
        currentlyInspectedPaths = {};
      }

      mostRecentlyInspectedElement = inspectElementRaw(id);

      if (mostRecentlyInspectedElement === null) {
        return {
          id,
          type: 'not-found'
        };
      }

      if (path != null) {
        mergeInspectedPaths(path);
      } // Any time an inspected element has an update,
      // we should update the selected $r value as wel.
      // Do this before dehydration (cleanForBridge).


      updateSelectedElement(mostRecentlyInspectedElement); // Clone before cleaning so that we preserve the full data.
      // This will enable us to send patches without re-inspecting if hydrated paths are requested.
      // (Reducing how often we shallow-render is a better DX for function components that use hooks.)

      const cleanedInspectedElement = renderer_objectSpread({}, mostRecentlyInspectedElement);

      cleanedInspectedElement.context = cleanForBridge(cleanedInspectedElement.context, createIsPathAllowed('context', null));
      cleanedInspectedElement.hooks = cleanForBridge(cleanedInspectedElement.hooks, createIsPathAllowed('hooks', 'hooks'));
      cleanedInspectedElement.props = cleanForBridge(cleanedInspectedElement.props, createIsPathAllowed('props', null));
      cleanedInspectedElement.state = cleanForBridge(cleanedInspectedElement.state, createIsPathAllowed('state', null));
      return {
        id,
        type: 'full-data',
        value: cleanedInspectedElement
      };
    }
  }

  function logElementToConsole(id) {
    const result = isMostRecentlyInspectedElementCurrent(id) ? mostRecentlyInspectedElement : inspectElementRaw(id);

    if (result === null) {
      console.warn(`Could not find Fiber with id "${id}"`);
      return;
    }

    const supportsGroup = typeof console.groupCollapsed === 'function';

    if (supportsGroup) {
      console.groupCollapsed(`[Click to expand] %c<${result.displayName || 'Component'} />`, // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.
      'color: var(--dom-tag-name-color); font-weight: normal;');
    }

    if (result.props !== null) {
      console.log('Props:', result.props);
    }

    if (result.state !== null) {
      console.log('State:', result.state);
    }

    if (result.hooks !== null) {
      console.log('Hooks:', result.hooks);
    }

    const nativeNodes = findNativeNodesForFiberID(id);

    if (nativeNodes !== null) {
      console.log('Nodes:', nativeNodes);
    }

    if (result.source !== null) {
      console.log('Location:', result.source);
    }

    if (window.chrome || /firefox/i.test(navigator.userAgent)) {
      console.log('Right-click any value to save it as a global variable for further inspection.');
    }

    if (supportsGroup) {
      console.groupEnd();
    }
  }

  function deletePath(type, id, hookID, path) {
    const fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      const instance = fiber.stateNode;

      switch (type) {
        case 'context':
          // To simplify hydration and display of primitive context values (e.g. number, string)
          // the inspectElement() method wraps context in a {value: ...} object.
          // We need to remove the first part of the path (the "value") before continuing.
          path = path.slice(1);

          switch (fiber.tag) {
            case ClassComponent:
              if (path.length === 0) {// Simple context value (noop)
              } else {
                Object(utils["a" /* deletePathInObject */])(instance.context, path);
              }

              instance.forceUpdate();
              break;

            case FunctionComponent:
              // Function components using legacy context are not editable
              // because there's no instance on which to create a cloned, mutated context.
              break;
          }

          break;

        case 'hooks':
          if (typeof overrideHookStateDeletePath === 'function') {
            overrideHookStateDeletePath(fiber, hookID, path);
          }

          break;

        case 'props':
          if (instance === null) {
            if (typeof overridePropsDeletePath === 'function') {
              overridePropsDeletePath(fiber, path);
            }
          } else {
            fiber.pendingProps = copyWithDelete(instance.props, path);
            instance.forceUpdate();
          }

          break;

        case 'state':
          Object(utils["a" /* deletePathInObject */])(instance.state, path);
          instance.forceUpdate();
          break;
      }
    }
  }

  function renamePath(type, id, hookID, oldPath, newPath) {
    const fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      const instance = fiber.stateNode;

      switch (type) {
        case 'context':
          // To simplify hydration and display of primitive context values (e.g. number, string)
          // the inspectElement() method wraps context in a {value: ...} object.
          // We need to remove the first part of the path (the "value") before continuing.
          oldPath = oldPath.slice(1);
          newPath = newPath.slice(1);

          switch (fiber.tag) {
            case ClassComponent:
              if (oldPath.length === 0) {// Simple context value (noop)
              } else {
                Object(utils["n" /* renamePathInObject */])(instance.context, oldPath, newPath);
              }

              instance.forceUpdate();
              break;

            case FunctionComponent:
              // Function components using legacy context are not editable
              // because there's no instance on which to create a cloned, mutated context.
              break;
          }

          break;

        case 'hooks':
          if (typeof overrideHookStateRenamePath === 'function') {
            overrideHookStateRenamePath(fiber, hookID, oldPath, newPath);
          }

          break;

        case 'props':
          if (instance === null) {
            if (typeof overridePropsRenamePath === 'function') {
              overridePropsRenamePath(fiber, oldPath, newPath);
            }
          } else {
            fiber.pendingProps = copyWithRename(instance.props, oldPath, newPath);
            instance.forceUpdate();
          }

          break;

        case 'state':
          Object(utils["n" /* renamePathInObject */])(instance.state, oldPath, newPath);
          instance.forceUpdate();
          break;
      }
    }
  }

  function overrideValueAtPath(type, id, hookID, path, value) {
    const fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      const instance = fiber.stateNode;

      switch (type) {
        case 'context':
          // To simplify hydration and display of primitive context values (e.g. number, string)
          // the inspectElement() method wraps context in a {value: ...} object.
          // We need to remove the first part of the path (the "value") before continuing.
          path = path.slice(1);

          switch (fiber.tag) {
            case ClassComponent:
              if (path.length === 0) {
                // Simple context value
                instance.context = value;
              } else {
                Object(utils["q" /* setInObject */])(instance.context, path, value);
              }

              instance.forceUpdate();
              break;

            case FunctionComponent:
              // Function components using legacy context are not editable
              // because there's no instance on which to create a cloned, mutated context.
              break;
          }

          break;

        case 'hooks':
          if (typeof overrideHookState === 'function') {
            overrideHookState(fiber, hookID, path, value);
          }

          break;

        case 'props':
          switch (fiber.tag) {
            case ClassComponent:
              fiber.pendingProps = copyWithSet(instance.props, path, value);
              instance.forceUpdate();
              break;

            default:
              if (typeof overrideProps === 'function') {
                overrideProps(fiber, path, value);
              }

              break;
          }

          break;

        case 'state':
          switch (fiber.tag) {
            case ClassComponent:
              Object(utils["q" /* setInObject */])(instance.state, path, value);
              instance.forceUpdate();
              break;
          }

          break;
      }
    }
  }

  let currentCommitProfilingMetadata = null;
  let displayNamesByRootID = null;
  let idToContextsMap = null;
  let initialTreeBaseDurationsMap = null;
  let initialIDToRootMap = null;
  let isProfiling = false;
  let profilingStartTime = 0;
  let recordChangeDescriptions = false;
  let rootToCommitProfilingMetadataMap = null;

  function getProfilingData() {
    const dataForRoots = [];

    if (rootToCommitProfilingMetadataMap === null) {
      throw Error('getProfilingData() called before any profiling data was recorded');
    }

    rootToCommitProfilingMetadataMap.forEach((commitProfilingMetadata, rootID) => {
      const commitData = [];
      const initialTreeBaseDurations = [];
      const allInteractions = new Map();
      const interactionCommits = new Map();
      const displayName = displayNamesByRootID !== null && displayNamesByRootID.get(rootID) || 'Unknown';

      if (initialTreeBaseDurationsMap != null) {
        initialTreeBaseDurationsMap.forEach((treeBaseDuration, id) => {
          if (initialIDToRootMap != null && initialIDToRootMap.get(id) === rootID) {
            // We don't need to convert milliseconds to microseconds in this case,
            // because the profiling summary is JSON serialized.
            initialTreeBaseDurations.push([id, treeBaseDuration]);
          }
        });
      }

      commitProfilingMetadata.forEach((commitProfilingData, commitIndex) => {
        const changeDescriptions = commitProfilingData.changeDescriptions,
              durations = commitProfilingData.durations,
              interactions = commitProfilingData.interactions,
              maxActualDuration = commitProfilingData.maxActualDuration,
              priorityLevel = commitProfilingData.priorityLevel,
              commitTime = commitProfilingData.commitTime;
        const interactionIDs = [];
        interactions.forEach(interaction => {
          if (!allInteractions.has(interaction.id)) {
            allInteractions.set(interaction.id, interaction);
          }

          interactionIDs.push(interaction.id);
          const commitIndices = interactionCommits.get(interaction.id);

          if (commitIndices != null) {
            commitIndices.push(commitIndex);
          } else {
            interactionCommits.set(interaction.id, [commitIndex]);
          }
        });
        const fiberActualDurations = [];
        const fiberSelfDurations = [];

        for (let i = 0; i < durations.length; i += 3) {
          const fiberID = durations[i];
          fiberActualDurations.push([fiberID, durations[i + 1]]);
          fiberSelfDurations.push([fiberID, durations[i + 2]]);
        }

        commitData.push({
          changeDescriptions: changeDescriptions !== null ? Array.from(changeDescriptions.entries()) : null,
          duration: maxActualDuration,
          fiberActualDurations,
          fiberSelfDurations,
          interactionIDs,
          priorityLevel,
          timestamp: commitTime
        });
      });
      dataForRoots.push({
        commitData,
        displayName,
        initialTreeBaseDurations,
        interactionCommits: Array.from(interactionCommits.entries()),
        interactions: Array.from(allInteractions.entries()),
        rootID
      });
    });
    return {
      dataForRoots,
      rendererID
    };
  }

  function startProfiling(shouldRecordChangeDescriptions) {
    if (isProfiling) {
      return;
    }

    recordChangeDescriptions = shouldRecordChangeDescriptions; // Capture initial values as of the time profiling starts.
    // It's important we snapshot both the durations and the id-to-root map,
    // since either of these may change during the profiling session
    // (e.g. when a fiber is re-rendered or when a fiber gets removed).

    displayNamesByRootID = new Map();
    initialTreeBaseDurationsMap = new Map(idToTreeBaseDurationMap);
    initialIDToRootMap = new Map(idToRootMap);
    idToContextsMap = new Map();
    hook.getFiberRoots(rendererID).forEach(root => {
      const rootID = getFiberID(getPrimaryFiber(root.current));
      displayNamesByRootID.set(rootID, getDisplayNameForRoot(root.current));

      if (shouldRecordChangeDescriptions) {
        // Record all contexts at the time profiling is started.
        // Fibers only store the current context value,
        // so we need to track them separately in order to determine changed keys.
        crawlToInitializeContextsMap(root.current);
      }
    });
    isProfiling = true;
    profilingStartTime = renderer_getCurrentTime();
    rootToCommitProfilingMetadataMap = new Map();
  }

  function stopProfiling() {
    isProfiling = false;
    recordChangeDescriptions = false;
  } // Automatically start profiling so that we don't miss timing info from initial "mount".


  if (Object(storage["c" /* sessionStorageGetItem */])(constants["k" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */]) === 'true') {
    startProfiling(Object(storage["c" /* sessionStorageGetItem */])(constants["j" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */]) === 'true');
  } // React will switch between these implementations depending on whether
  // we have any manually suspended Fibers or not.


  function shouldSuspendFiberAlwaysFalse() {
    return false;
  }

  const forceFallbackForSuspenseIDs = new Set();

  function shouldSuspendFiberAccordingToSet(fiber) {
    const id = getFiberID(getPrimaryFiber(fiber));
    return forceFallbackForSuspenseIDs.has(id);
  }

  function overrideSuspense(id, forceFallback) {
    if (typeof setSuspenseHandler !== 'function' || typeof scheduleUpdate !== 'function') {
      throw new Error('Expected overrideSuspense() to not get called for earlier React versions.');
    }

    if (forceFallback) {
      forceFallbackForSuspenseIDs.add(id);

      if (forceFallbackForSuspenseIDs.size === 1) {
        // First override is added. Switch React to slower path.
        setSuspenseHandler(shouldSuspendFiberAccordingToSet);
      }
    } else {
      forceFallbackForSuspenseIDs.delete(id);

      if (forceFallbackForSuspenseIDs.size === 0) {
        // Last override is gone. Switch React back to fast path.
        setSuspenseHandler(shouldSuspendFiberAlwaysFalse);
      }
    }

    const fiber = idToFiberMap.get(id);

    if (fiber != null) {
      scheduleUpdate(fiber);
    }
  } // Remember if we're trying to restore the selection after reload.
  // In that case, we'll do some extra checks for matching mounts.


  let trackedPath = null;
  let trackedPathMatchFiber = null;
  let trackedPathMatchDepth = -1;
  let mightBeOnTrackedPath = false;

  function setTrackedPath(path) {
    if (path === null) {
      trackedPathMatchFiber = null;
      trackedPathMatchDepth = -1;
      mightBeOnTrackedPath = false;
    }

    trackedPath = path;
  } // We call this before traversing a new mount.
  // It remembers whether this Fiber is the next best match for tracked path.
  // The return value signals whether we should keep matching siblings or not.


  function updateTrackedPathStateBeforeMount(fiber) {
    if (trackedPath === null || !mightBeOnTrackedPath) {
      // Fast path: there's nothing to track so do nothing and ignore siblings.
      return false;
    }

    const returnFiber = fiber.return;
    const returnAlternate = returnFiber !== null ? returnFiber.alternate : null; // By now we know there's some selection to restore, and this is a new Fiber.
    // Is this newly mounted Fiber a direct child of the current best match?
    // (This will also be true for new roots if we haven't matched anything yet.)

    if (trackedPathMatchFiber === returnFiber || trackedPathMatchFiber === returnAlternate && returnAlternate !== null) {
      // Is this the next Fiber we should select? Let's compare the frames.
      const actualFrame = getPathFrame(fiber);
      const expectedFrame = trackedPath[trackedPathMatchDepth + 1];

      if (expectedFrame === undefined) {
        throw new Error('Expected to see a frame at the next depth.');
      }

      if (actualFrame.index === expectedFrame.index && actualFrame.key === expectedFrame.key && actualFrame.displayName === expectedFrame.displayName) {
        // We have our next match.
        trackedPathMatchFiber = fiber;
        trackedPathMatchDepth++; // Are we out of frames to match?

        if (trackedPathMatchDepth === trackedPath.length - 1) {
          // There's nothing that can possibly match afterwards.
          // Don't check the children.
          mightBeOnTrackedPath = false;
        } else {
          // Check the children, as they might reveal the next match.
          mightBeOnTrackedPath = true;
        } // In either case, since we have a match, we don't need
        // to check the siblings. They'll never match.


        return false;
      }
    } // This Fiber's parent is on the path, but this Fiber itself isn't.
    // There's no need to check its children--they won't be on the path either.


    mightBeOnTrackedPath = false; // However, one of its siblings may be on the path so keep searching.

    return true;
  }

  function updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath) {
    // updateTrackedPathStateBeforeMount() told us whether to match siblings.
    // Now that we're entering siblings, let's use that information.
    mightBeOnTrackedPath = mightSiblingsBeOnTrackedPath;
  } // Roots don't have a real persistent identity.
  // A root's "pseudo key" is "childDisplayName:indexWithThatName".
  // For example, "App:0" or, in case of similar roots, "Story:0", "Story:1", etc.
  // We will use this to try to disambiguate roots when restoring selection between reloads.


  const rootPseudoKeys = new Map();
  const rootDisplayNameCounter = new Map();

  function setRootPseudoKey(id, fiber) {
    const name = getDisplayNameForRoot(fiber);
    const counter = rootDisplayNameCounter.get(name) || 0;
    rootDisplayNameCounter.set(name, counter + 1);
    const pseudoKey = `${name}:${counter}`;
    rootPseudoKeys.set(id, pseudoKey);
  }

  function removeRootPseudoKey(id) {
    const pseudoKey = rootPseudoKeys.get(id);

    if (pseudoKey === undefined) {
      throw new Error('Expected root pseudo key to be known.');
    }

    const name = pseudoKey.substring(0, pseudoKey.lastIndexOf(':'));
    const counter = rootDisplayNameCounter.get(name);

    if (counter === undefined) {
      throw new Error('Expected counter to be known.');
    }

    if (counter > 1) {
      rootDisplayNameCounter.set(name, counter - 1);
    } else {
      rootDisplayNameCounter.delete(name);
    }

    rootPseudoKeys.delete(id);
  }

  function getDisplayNameForRoot(fiber) {
    let preferredDisplayName = null;
    let fallbackDisplayName = null;
    let child = fiber.child; // Go at most three levels deep into direct children
    // while searching for a child that has a displayName.

    for (let i = 0; i < 3; i++) {
      if (child === null) {
        break;
      }

      const displayName = getDisplayNameForFiber(child);

      if (displayName !== null) {
        // Prefer display names that we get from user-defined components.
        // We want to avoid using e.g. 'Suspense' unless we find nothing else.
        if (typeof child.type === 'function') {
          // There's a few user-defined tags, but we'll prefer the ones
          // that are usually explicitly named (function or class components).
          preferredDisplayName = displayName;
        } else if (fallbackDisplayName === null) {
          fallbackDisplayName = displayName;
        }
      }

      if (preferredDisplayName !== null) {
        break;
      }

      child = child.child;
    }

    return preferredDisplayName || fallbackDisplayName || 'Anonymous';
  }

  function getPathFrame(fiber) {
    const key = fiber.key;
    let displayName = getDisplayNameForFiber(fiber);
    const index = fiber.index;

    switch (fiber.tag) {
      case HostRoot:
        // Roots don't have a real displayName, index, or key.
        // Instead, we'll use the pseudo key (childDisplayName:indexWithThatName).
        const id = getFiberID(getPrimaryFiber(fiber));
        const pseudoKey = rootPseudoKeys.get(id);

        if (pseudoKey === undefined) {
          throw new Error('Expected mounted root to have known pseudo key.');
        }

        displayName = pseudoKey;
        break;

      case HostComponent:
        displayName = fiber.type;
        break;

      default:
        break;
    }

    return {
      displayName,
      key,
      index
    };
  } // Produces a serializable representation that does a best effort
  // of identifying a particular Fiber between page reloads.
  // The return path will contain Fibers that are "invisible" to the store
  // because their keys and indexes are important to restoring the selection.


  function getPathForElement(id) {
    let fiber = idToFiberMap.get(id);

    if (fiber == null) {
      return null;
    }

    const keyPath = [];

    while (fiber !== null) {
      keyPath.push(getPathFrame(fiber));
      fiber = fiber.return;
    }

    keyPath.reverse();
    return keyPath;
  }

  function getBestMatchForTrackedPath() {
    if (trackedPath === null) {
      // Nothing to match.
      return null;
    }

    if (trackedPathMatchFiber === null) {
      // We didn't find anything.
      return null;
    } // Find the closest Fiber store is aware of.


    let fiber = trackedPathMatchFiber;

    while (fiber !== null && shouldFilterFiber(fiber)) {
      fiber = fiber.return;
    }

    if (fiber === null) {
      return null;
    }

    return {
      id: getFiberID(getPrimaryFiber(fiber)),
      isFullMatch: trackedPathMatchDepth === trackedPath.length - 1
    };
  }

  const formatPriorityLevel = priorityLevel => {
    if (priorityLevel == null) {
      return 'Unknown';
    }

    switch (priorityLevel) {
      case ImmediatePriority:
        return 'Immediate';

      case UserBlockingPriority:
        return 'User-Blocking';

      case NormalPriority:
        return 'Normal';

      case LowPriority:
        return 'Low';

      case IdlePriority:
        return 'Idle';

      case NoPriority:
      default:
        return 'Unknown';
    }
  };

  function setTraceUpdatesEnabled(isEnabled) {
    traceUpdatesEnabled = isEnabled;
  }

  return {
    cleanup,
    copyElementPath,
    deletePath,
    findNativeNodesForFiberID,
    flushInitialOperations,
    getBestMatchForTrackedPath,
    getDisplayNameForFiberID,
    getFiberIDForNative,
    getInstanceAndStyle,
    getOwnersList,
    getPathForElement,
    getProfilingData,
    handleCommitFiberRoot,
    handleCommitFiberUnmount,
    inspectElement,
    logElementToConsole,
    prepareViewAttributeSource,
    prepareViewElementSource,
    overrideSuspense,
    overrideValueAtPath,
    renamePath,
    renderer,
    setTraceUpdatesEnabled,
    setTrackedPath,
    startProfiling,
    stopProfiling,
    storeAsGlobal,
    updateComponentFilters
  };
}
// CONCATENATED MODULE: ../shared/ConsolePatchingDev.js
function ConsolePatchingDev_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function ConsolePatchingDev_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ConsolePatchingDev_ownKeys(Object(source), true).forEach(function (key) { ConsolePatchingDev_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ConsolePatchingDev_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ConsolePatchingDev_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
let disabledDepth = 0;
let prevLog;
let prevInfo;
let prevWarn;
let prevError;
let prevGroup;
let prevGroupCollapsed;
let prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  if (false) {}
}
function reenableLogs() {
  if (false) {}
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsComponentStackFrame.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This is a DevTools fork of ReactComponentStackFrame.
// This fork enables DevTools to use the same "native" component stack format,
// while still maintaining support for multiple renderer versions
// (which use different values for ReactTypeOfWork).
 // These methods are safe to import from shared;
// there is no React-specific logic here.


let prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  if (prefix === undefined) {
    // Extract the VM specific prefix used by each line.
    try {
      throw Error();
    } catch (x) {
      const match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = match && match[1] || '';
    }
  } // We use the prefix to ensure our stacks line up with native stack frames.


  return '\n' + prefix + name;
}
let reentry = false;
let componentFrameCache;

if (false) {}

function describeNativeComponentFrame(fn, construct, currentDispatcherRef) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  if (false) {}

  let control;
  const previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  reentry = true; // Override the dispatcher so effects scheduled by this shallow render are thrown away.
  //
  // Note that unlike the code this was forked from (in ReactComponentStackFrame)
  // DevTools should override the dispatcher even when DevTools is compiled in production mode,
  // because the app itself may be in development mode and log errors/warnings.

  const previousDispatcher = currentDispatcherRef.current;
  currentDispatcherRef.current = null;
  disableLogs();

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      const Fake = function Fake() {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function set() {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      const sampleLines = sample.stack.split('\n');
      const controlLines = control.stack.split('\n');
      let s = sampleLines.length - 1;
      let c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                const frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                if (false) {} // Return the line we found.


                return frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;
    Error.prepareStackTrace = previousPrepareStackTrace;
    currentDispatcherRef.current = previousDispatcher;
    reenableLogs();
  } // Fallback to just using the name if we couldn't make it throw.


  const name = fn ? fn.displayName || fn.name : '';
  const syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  if (false) {}

  return syntheticFrame;
}
function describeClassComponentFrame(ctor, source, ownerFn, currentDispatcherRef) {
  return describeNativeComponentFrame(ctor, true, currentDispatcherRef);
}
function describeFunctionComponentFrame(fn, source, ownerFn, currentDispatcherRef) {
  return describeNativeComponentFrame(fn, false, currentDispatcherRef);
}

function shouldConstruct(Component) {
  const prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn, currentDispatcherRef) {
  if (true) {
    return '';
  }

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    return describeNativeComponentFrame(type, shouldConstruct(type), currentDispatcherRef);
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type, source, ownerFn);
  }

  switch (type) {
    case SUSPENSE_NUMBER:
    case SUSPENSE_SYMBOL_STRING:
      return describeBuiltInComponentFrame('Suspense', source, ownerFn);

    case SUSPENSE_LIST_NUMBER:
    case SUSPENSE_LIST_SYMBOL_STRING:
      return describeBuiltInComponentFrame('SuspenseList', source, ownerFn);
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case FORWARD_REF_NUMBER:
      case FORWARD_REF_SYMBOL_STRING:
        return describeFunctionComponentFrame(type.render, source, ownerFn, currentDispatcherRef);

      case MEMO_NUMBER:
      case MEMO_SYMBOL_STRING:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn, currentDispatcherRef);

      case LAZY_NUMBER:
      case LAZY_SYMBOL_STRING:
        {
          const lazyComponent = type;
          const payload = lazyComponent._payload;
          const init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn, currentDispatcherRef);
          } catch (x) {}
        }
    }
  }

  return '';
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This is a DevTools fork of ReactFiberComponentStack.
// This fork enables DevTools to use the same "native" component stack format,
// while still maintaining support for multiple renderer versions
// (which use different values for ReactTypeOfWork).


function describeFiber(workTagMap, workInProgress, currentDispatcherRef) {
  const HostComponent = workTagMap.HostComponent,
        LazyComponent = workTagMap.LazyComponent,
        SuspenseComponent = workTagMap.SuspenseComponent,
        SuspenseListComponent = workTagMap.SuspenseListComponent,
        FunctionComponent = workTagMap.FunctionComponent,
        IndeterminateComponent = workTagMap.IndeterminateComponent,
        SimpleMemoComponent = workTagMap.SimpleMemoComponent,
        ForwardRef = workTagMap.ForwardRef,
        ClassComponent = workTagMap.ClassComponent;
  const owner =  false ? undefined : null;
  const source =  false ? undefined : null;

  switch (workInProgress.tag) {
    case HostComponent:
      return describeBuiltInComponentFrame(workInProgress.type, source, owner);

    case LazyComponent:
      return describeBuiltInComponentFrame('Lazy', source, owner);

    case SuspenseComponent:
      return describeBuiltInComponentFrame('Suspense', source, owner);

    case SuspenseListComponent:
      return describeBuiltInComponentFrame('SuspenseList', source, owner);

    case FunctionComponent:
    case IndeterminateComponent:
    case SimpleMemoComponent:
      return describeFunctionComponentFrame(workInProgress.type, source, owner, currentDispatcherRef);

    case ForwardRef:
      return describeFunctionComponentFrame(workInProgress.type.render, source, owner, currentDispatcherRef);

    case ClassComponent:
      return describeClassComponentFrame(workInProgress.type, source, owner, currentDispatcherRef);

    default:
      return '';
  }
}

function getStackByFiberInDevAndProd(workTagMap, workInProgress, currentDispatcherRef) {
  try {
    let info = '';
    let node = workInProgress;

    do {
      info += describeFiber(workTagMap, node, currentDispatcherRef);
      node = node.return;
    } while (node);

    return info;
  } catch (x) {
    return '\nError generating stack: ' + x.message + '\n' + x.stack;
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/console.js
function console_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = console_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function console_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return console_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return console_arrayLikeToArray(o, minLen); }

function console_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


const APPEND_STACK_TO_METHODS = ['error', 'trace', 'warn']; // React's custom built component stack strings match "\s{4}in"
// Chrome's prefix matches "\s{4}at"

const PREFIX_REGEX = /\s{4}(in|at)\s{1}/; // Firefox and Safari have no prefix ("")
// but we can fallback to looking for location info (e.g. "foo.js:12:345")

const ROW_COLUMN_NUMBER_REGEX = /:\d+:\d+(\n|$)/;
const injectedRenderers = new Map();
let targetConsole = console;
let targetConsoleMethods = {};

for (const method in console) {
  targetConsoleMethods[method] = console[method];
}

let unpatchFn = null; // Enables e.g. Jest tests to inject a mock console object.

function dangerous_setTargetConsoleForTesting(targetConsoleForTesting) {
  targetConsole = targetConsoleForTesting;
  targetConsoleMethods = {};

  for (const method in targetConsole) {
    targetConsoleMethods[method] = console[method];
  }
} // v16 renderers should use this method to inject internals necessary to generate a component stack.
// These internals will be used if the console is patched.
// Injecting them separately allows the console to easily be patched or un-patched later (at runtime).

function registerRenderer(renderer) {
  const currentDispatcherRef = renderer.currentDispatcherRef,
        getCurrentFiber = renderer.getCurrentFiber,
        findFiberByHostInstance = renderer.findFiberByHostInstance,
        version = renderer.version; // Ignore React v15 and older because they don't expose a component stack anyway.

  if (typeof findFiberByHostInstance !== 'function') {
    return;
  } // currentDispatcherRef gets injected for v16.8+ to support hooks inspection.
  // getCurrentFiber gets injected for v16.9+.


  if (currentDispatcherRef != null && typeof getCurrentFiber === 'function') {
    const _getInternalReactCons = getInternalReactConstants(version),
          ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork;

    injectedRenderers.set(renderer, {
      currentDispatcherRef,
      getCurrentFiber,
      workTagMap: ReactTypeOfWork
    });
  }
}
const consoleSettingsRef = {
  appendComponentStack: false,
  breakOnConsoleErrors: false
}; // Patches console methods to append component stack for the current fiber.
// Call unpatch() to remove the injected behavior.

function patch({
  appendComponentStack,
  breakOnConsoleErrors
}) {
  // Settings may change after we've patched the console.
  // Using a shared ref allows the patch function to read the latest values.
  consoleSettingsRef.appendComponentStack = appendComponentStack;
  consoleSettingsRef.breakOnConsoleErrors = breakOnConsoleErrors;

  if (unpatchFn !== null) {
    // Don't patch twice.
    return;
  }

  const originalConsoleMethods = {};

  unpatchFn = () => {
    for (const method in originalConsoleMethods) {
      try {
        // $FlowFixMe property error|warn is not writable.
        targetConsole[method] = originalConsoleMethods[method];
      } catch (error) {}
    }
  };

  APPEND_STACK_TO_METHODS.forEach(method => {
    try {
      const originalMethod = originalConsoleMethods[method] = targetConsole[method];

      const overrideMethod = (...args) => {
        const latestAppendComponentStack = consoleSettingsRef.appendComponentStack;
        const latestBreakOnConsoleErrors = consoleSettingsRef.breakOnConsoleErrors;

        if (latestAppendComponentStack) {
          try {
            // If we are ever called with a string that already has a component stack, e.g. a React error/warning,
            // don't append a second stack.
            const lastArg = args.length > 0 ? args[args.length - 1] : null;
            const alreadyHasComponentStack = lastArg !== null && (PREFIX_REGEX.test(lastArg) || ROW_COLUMN_NUMBER_REGEX.test(lastArg));

            if (!alreadyHasComponentStack) {
              // If there's a component stack for at least one of the injected renderers, append it.
              // We don't handle the edge case of stacks for more than one (e.g. interleaved renderers?)
              // eslint-disable-next-line no-for-of-loops/no-for-of-loops
              var _iterator = console_createForOfIteratorHelper(injectedRenderers.values()),
                  _step;

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  const _step$value = _step.value,
                        currentDispatcherRef = _step$value.currentDispatcherRef,
                        getCurrentFiber = _step$value.getCurrentFiber,
                        workTagMap = _step$value.workTagMap;
                  const current = getCurrentFiber();

                  if (current != null) {
                    const componentStack = getStackByFiberInDevAndProd(workTagMap, current, currentDispatcherRef);

                    if (componentStack !== '') {
                      args.push(componentStack);
                    }

                    break;
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            }
          } catch (error) {// Don't let a DevTools or React internal error interfere with logging.
          }
        }

        if (latestBreakOnConsoleErrors) {
          // --- Welcome to debugging with React DevTools ---
          // This debugger statement means that you've enabled the "break on warnings" feature.
          // Use the browser's Call Stack panel to step out of this override function-
          // to where the original warning or error was logged.
          // eslint-disable-next-line no-debugger
          debugger;
        }

        originalMethod(...args);
      };

      overrideMethod.__REACT_DEVTOOLS_ORIGINAL_METHOD__ = originalMethod; // $FlowFixMe property error|warn is not writable.

      targetConsole[method] = overrideMethod;
    } catch (error) {}
  });
} // Removed component stack patch from console methods.

function unpatch() {
  if (unpatchFn !== null) {
    unpatchFn();
    unpatchFn = null;
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/agent.js
function agent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */








const agent_debug = (methodName, ...args) => {
  if (constants["q" /* __DEBUG__ */]) {
    console.log(`%cAgent %c${methodName}`, 'color: purple; font-weight: bold;', 'font-weight: bold;', ...args);
  }
};

class agent_Agent extends events["a" /* default */] {
  constructor(bridge) {
    super();

    agent_defineProperty(this, "_isProfiling", false);

    agent_defineProperty(this, "_recordChangeDescriptions", false);

    agent_defineProperty(this, "_rendererInterfaces", {});

    agent_defineProperty(this, "_persistedSelection", null);

    agent_defineProperty(this, "_persistedSelectionMatch", null);

    agent_defineProperty(this, "_traceUpdatesEnabled", false);

    agent_defineProperty(this, "copyElementPath", ({
      id,
      path,
      rendererID
    }) => {
      const renderer = this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn(`Invalid renderer id "${rendererID}" for element "${id}"`);
      } else {
        renderer.copyElementPath(id, path);
      }
    });

    agent_defineProperty(this, "deletePath", ({
      hookID,
      id,
      path,
      rendererID,
      type
    }) => {
      const renderer = this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn(`Invalid renderer id "${rendererID}" for element "${id}"`);
      } else {
        renderer.deletePath(type, id, hookID, path);
      }
    });

    agent_defineProperty(this, "getProfilingData", ({
      rendererID
    }) => {
      const renderer = this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn(`Invalid renderer id "${rendererID}"`);
      }

      this._bridge.send('profilingData', renderer.getProfilingData());
    });

    agent_defineProperty(this, "getProfilingStatus", () => {
      this._bridge.send('profilingStatus', this._isProfiling);
    });

    agent_defineProperty(this, "getOwnersList", ({
      id,
      rendererID
    }) => {
      const renderer = this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn(`Invalid renderer id "${rendererID}" for element "${id}"`);
      } else {
        const owners = renderer.getOwnersList(id);

        this._bridge.send('ownersList', {
          id,
          owners
        });
      }
    });

    agent_defineProperty(this, "inspectElement", ({
      id,
      path,
      rendererID
    }) => {
      const renderer = this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn(`Invalid renderer id "${rendererID}" for element "${id}"`);
      } else {
        this._bridge.send('inspectedElement', renderer.inspectElement(id, path)); // When user selects an element, stop trying to restore the selection,
        // and instead remember the current selection for the next reload.


        if (this._persistedSelectionMatch === null || this._persistedSelectionMatch.id !== id) {
          this._persistedSelection = null;
          this._persistedSelectionMatch = null;
          renderer.setTrackedPath(null);

          this._throttledPersistSelection(rendererID, id);
        } // TODO: If there was a way to change the selected DOM element
        // in native Elements tab without forcing a switch to it, we'd do it here.
        // For now, it doesn't seem like there is a way to do that:
        // https://github.com/bvaughn/react-devtools-experimental/issues/102
        // (Setting $0 doesn't work, and calling inspect() switches the tab.)

      }
    });

    agent_defineProperty(this, "logElementToConsole", ({
      id,
      rendererID
    }) => {
      const renderer = this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn(`Invalid renderer id "${rendererID}" for element "${id}"`);
      } else {
        renderer.logElementToConsole(id);
      }
    });

    agent_defineProperty(this, "overrideSuspense", ({
      id,
      rendererID,
      forceFallback
    }) => {
      const renderer = this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn(`Invalid renderer id "${rendererID}" for element "${id}"`);
      } else {
        renderer.overrideSuspense(id, forceFallback);
      }
    });

    agent_defineProperty(this, "overrideValueAtPath", ({
      hookID,
      id,
      path,
      rendererID,
      type,
      value
    }) => {
      const renderer = this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn(`Invalid renderer id "${rendererID}" for element "${id}"`);
      } else {
        renderer.overrideValueAtPath(type, id, hookID, path, value);
      }
    });

    agent_defineProperty(this, "overrideContext", ({
      id,
      path,
      rendererID,
      wasForwarded,
      value
    }) => {
      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        this.overrideValueAtPath({
          id,
          path,
          rendererID,
          type: 'context',
          value
        });
      }
    });

    agent_defineProperty(this, "overrideHookState", ({
      id,
      hookID,
      path,
      rendererID,
      wasForwarded,
      value
    }) => {
      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        this.overrideValueAtPath({
          id,
          path,
          rendererID,
          type: 'hooks',
          value
        });
      }
    });

    agent_defineProperty(this, "overrideProps", ({
      id,
      path,
      rendererID,
      wasForwarded,
      value
    }) => {
      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        this.overrideValueAtPath({
          id,
          path,
          rendererID,
          type: 'props',
          value
        });
      }
    });

    agent_defineProperty(this, "overrideState", ({
      id,
      path,
      rendererID,
      wasForwarded,
      value
    }) => {
      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        this.overrideValueAtPath({
          id,
          path,
          rendererID,
          type: 'state',
          value
        });
      }
    });

    agent_defineProperty(this, "reloadAndProfile", recordChangeDescriptions => {
      Object(storage["e" /* sessionStorageSetItem */])(constants["k" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */], 'true');
      Object(storage["e" /* sessionStorageSetItem */])(constants["j" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */], recordChangeDescriptions ? 'true' : 'false'); // This code path should only be hit if the shell has explicitly told the Store that it supports profiling.
      // In that case, the shell must also listen for this specific message to know when it needs to reload the app.
      // The agent can't do this in a way that is renderer agnostic.

      this._bridge.send('reloadAppForProfiling');
    });

    agent_defineProperty(this, "renamePath", ({
      hookID,
      id,
      newPath,
      oldPath,
      rendererID,
      type
    }) => {
      const renderer = this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn(`Invalid renderer id "${rendererID}" for element "${id}"`);
      } else {
        renderer.renamePath(type, id, hookID, oldPath, newPath);
      }
    });

    agent_defineProperty(this, "setTraceUpdatesEnabled", traceUpdatesEnabled => {
      this._traceUpdatesEnabled = traceUpdatesEnabled;
      toggleEnabled(traceUpdatesEnabled);

      for (const rendererID in this._rendererInterfaces) {
        const renderer = this._rendererInterfaces[rendererID];
        renderer.setTraceUpdatesEnabled(traceUpdatesEnabled);
      }
    });

    agent_defineProperty(this, "syncSelectionFromNativeElementsPanel", () => {
      const target = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;

      if (target == null) {
        return;
      }

      this.selectNode(target);
    });

    agent_defineProperty(this, "shutdown", () => {
      // Clean up the overlay if visible, and associated events.
      this.emit('shutdown');
    });

    agent_defineProperty(this, "startProfiling", recordChangeDescriptions => {
      this._recordChangeDescriptions = recordChangeDescriptions;
      this._isProfiling = true;

      for (const rendererID in this._rendererInterfaces) {
        const renderer = this._rendererInterfaces[rendererID];
        renderer.startProfiling(recordChangeDescriptions);
      }

      this._bridge.send('profilingStatus', this._isProfiling);
    });

    agent_defineProperty(this, "stopProfiling", () => {
      this._isProfiling = false;
      this._recordChangeDescriptions = false;

      for (const rendererID in this._rendererInterfaces) {
        const renderer = this._rendererInterfaces[rendererID];
        renderer.stopProfiling();
      }

      this._bridge.send('profilingStatus', this._isProfiling);
    });

    agent_defineProperty(this, "storeAsGlobal", ({
      count,
      id,
      path,
      rendererID
    }) => {
      const renderer = this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn(`Invalid renderer id "${rendererID}" for element "${id}"`);
      } else {
        renderer.storeAsGlobal(id, path, count);
      }
    });

    agent_defineProperty(this, "updateConsolePatchSettings", ({
      appendComponentStack,
      breakOnConsoleErrors
    }) => {
      // If the frontend preference has change,
      // or in the case of React Native- if the backend is just finding out the preference-
      // then install or uninstall the console overrides.
      // It's safe to call these methods multiple times, so we don't need to worry about that.
      if (appendComponentStack || breakOnConsoleErrors) {
        patch({
          appendComponentStack,
          breakOnConsoleErrors
        });
      } else {
        unpatch();
      }
    });

    agent_defineProperty(this, "updateComponentFilters", componentFilters => {
      for (const rendererID in this._rendererInterfaces) {
        const renderer = this._rendererInterfaces[rendererID];
        renderer.updateComponentFilters(componentFilters);
      }
    });

    agent_defineProperty(this, "viewAttributeSource", ({
      id,
      path,
      rendererID
    }) => {
      const renderer = this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn(`Invalid renderer id "${rendererID}" for element "${id}"`);
      } else {
        renderer.prepareViewAttributeSource(id, path);
      }
    });

    agent_defineProperty(this, "viewElementSource", ({
      id,
      rendererID
    }) => {
      const renderer = this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn(`Invalid renderer id "${rendererID}" for element "${id}"`);
      } else {
        renderer.prepareViewElementSource(id);
      }
    });

    agent_defineProperty(this, "onTraceUpdates", nodes => {
      this.emit('traceUpdates', nodes);
    });

    agent_defineProperty(this, "onHookOperations", operations => {
      if (constants["q" /* __DEBUG__ */]) {
        agent_debug('onHookOperations', operations);
      } // TODO:
      // The chrome.runtime does not currently support transferables; it forces JSON serialization.
      // See bug https://bugs.chromium.org/p/chromium/issues/detail?id=927134
      //
      // Regarding transferables, the postMessage doc states:
      // If the ownership of an object is transferred, it becomes unusable (neutered)
      // in the context it was sent from and becomes available only to the worker it was sent to.
      //
      // Even though Chrome is eventually JSON serializing the array buffer,
      // using the transferable approach also sometimes causes it to throw:
      //   DOMException: Failed to execute 'postMessage' on 'Window': ArrayBuffer at index 0 is already neutered.
      //
      // See bug https://github.com/bvaughn/react-devtools-experimental/issues/25
      //
      // The Store has a fallback in place that parses the message as JSON if the type isn't an array.
      // For now the simplest fix seems to be to not transfer the array.
      // This will negatively impact performance on Firefox so it's unfortunate,
      // but until we're able to fix the Chrome error mentioned above, it seems necessary.
      //
      // this._bridge.send('operations', operations, [operations.buffer]);


      this._bridge.send('operations', operations);

      if (this._persistedSelection !== null) {
        const rendererID = operations[0];

        if (this._persistedSelection.rendererID === rendererID) {
          // Check if we can select a deeper match for the persisted selection.
          const renderer = this._rendererInterfaces[rendererID];

          if (renderer == null) {
            console.warn(`Invalid renderer id "${rendererID}"`);
          } else {
            const prevMatch = this._persistedSelectionMatch;
            const nextMatch = renderer.getBestMatchForTrackedPath();
            this._persistedSelectionMatch = nextMatch;
            const prevMatchID = prevMatch !== null ? prevMatch.id : null;
            const nextMatchID = nextMatch !== null ? nextMatch.id : null;

            if (prevMatchID !== nextMatchID) {
              if (nextMatchID !== null) {
                // We moved forward, unlocking a deeper node.
                this._bridge.send('selectFiber', nextMatchID);
              }
            }

            if (nextMatch !== null && nextMatch.isFullMatch) {
              // We've just unlocked the innermost selected node.
              // There's no point tracking it further.
              this._persistedSelection = null;
              this._persistedSelectionMatch = null;
              renderer.setTrackedPath(null);
            }
          }
        }
      }
    });

    agent_defineProperty(this, "_throttledPersistSelection", lodash_throttle_default()((rendererID, id) => {
      // This is throttled, so both renderer and selected ID
      // might not be available by the time we read them.
      // This is why we need the defensive checks here.
      const renderer = this._rendererInterfaces[rendererID];
      const path = renderer != null ? renderer.getPathForElement(id) : null;

      if (path !== null) {
        Object(storage["e" /* sessionStorageSetItem */])(constants["i" /* SESSION_STORAGE_LAST_SELECTION_KEY */], JSON.stringify({
          rendererID,
          path
        }));
      } else {
        Object(storage["d" /* sessionStorageRemoveItem */])(constants["i" /* SESSION_STORAGE_LAST_SELECTION_KEY */]);
      }
    }, 1000));

    if (Object(storage["c" /* sessionStorageGetItem */])(constants["k" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */]) === 'true') {
      this._recordChangeDescriptions = Object(storage["c" /* sessionStorageGetItem */])(constants["j" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */]) === 'true';
      this._isProfiling = true;
      Object(storage["d" /* sessionStorageRemoveItem */])(constants["j" /* SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY */]);
      Object(storage["d" /* sessionStorageRemoveItem */])(constants["k" /* SESSION_STORAGE_RELOAD_AND_PROFILE_KEY */]);
    }

    const persistedSelectionString = Object(storage["c" /* sessionStorageGetItem */])(constants["i" /* SESSION_STORAGE_LAST_SELECTION_KEY */]);

    if (persistedSelectionString != null) {
      this._persistedSelection = JSON.parse(persistedSelectionString);
    }

    this._bridge = bridge;
    bridge.addListener('copyElementPath', this.copyElementPath);
    bridge.addListener('deletePath', this.deletePath);
    bridge.addListener('getProfilingData', this.getProfilingData);
    bridge.addListener('getProfilingStatus', this.getProfilingStatus);
    bridge.addListener('getOwnersList', this.getOwnersList);
    bridge.addListener('inspectElement', this.inspectElement);
    bridge.addListener('logElementToConsole', this.logElementToConsole);
    bridge.addListener('overrideSuspense', this.overrideSuspense);
    bridge.addListener('overrideValueAtPath', this.overrideValueAtPath);
    bridge.addListener('reloadAndProfile', this.reloadAndProfile);
    bridge.addListener('renamePath', this.renamePath);
    bridge.addListener('setTraceUpdatesEnabled', this.setTraceUpdatesEnabled);
    bridge.addListener('startProfiling', this.startProfiling);
    bridge.addListener('stopProfiling', this.stopProfiling);
    bridge.addListener('storeAsGlobal', this.storeAsGlobal);
    bridge.addListener('syncSelectionFromNativeElementsPanel', this.syncSelectionFromNativeElementsPanel);
    bridge.addListener('shutdown', this.shutdown);
    bridge.addListener('updateConsolePatchSettings', this.updateConsolePatchSettings);
    bridge.addListener('updateComponentFilters', this.updateComponentFilters);
    bridge.addListener('viewAttributeSource', this.viewAttributeSource);
    bridge.addListener('viewElementSource', this.viewElementSource); // Temporarily support older standalone front-ends sending commands to newer embedded backends.
    // We do this because React Native embeds the React DevTools backend,
    // but cannot control which version of the frontend users use.

    bridge.addListener('overrideContext', this.overrideContext);
    bridge.addListener('overrideHookState', this.overrideHookState);
    bridge.addListener('overrideProps', this.overrideProps);
    bridge.addListener('overrideState', this.overrideState);

    if (this._isProfiling) {
      bridge.send('profilingStatus', true);
    } // Notify the frontend if the backend supports the Storage API (e.g. localStorage).
    // If not, features like reload-and-profile will not work correctly and must be disabled.


    let isBackendStorageAPISupported = false;

    try {
      localStorage.getItem('test');
      isBackendStorageAPISupported = true;
    } catch (error) {}

    bridge.send('isBackendStorageAPISupported', isBackendStorageAPISupported);
    setupHighlighter(bridge, this);
    TraceUpdates_initialize(this);
  }

  get rendererInterfaces() {
    return this._rendererInterfaces;
  }

  getInstanceAndStyle({
    id,
    rendererID
  }) {
    const renderer = this._rendererInterfaces[rendererID];

    if (renderer == null) {
      console.warn(`Invalid renderer id "${rendererID}"`);
      return null;
    }

    return renderer.getInstanceAndStyle(id);
  }

  getIDForNode(node) {
    for (const rendererID in this._rendererInterfaces) {
      const renderer = this._rendererInterfaces[rendererID];

      try {
        const id = renderer.getFiberIDForNative(node, true);

        if (id !== null) {
          return id;
        }
      } catch (error) {// Some old React versions might throw if they can't find a match.
        // If so we should ignore it...
      }
    }

    return null;
  }

  selectNode(target) {
    const id = this.getIDForNode(target);

    if (id !== null) {
      this._bridge.send('selectFiber', id);
    }
  }

  setRendererInterface(rendererID, rendererInterface) {
    this._rendererInterfaces[rendererID] = rendererInterface;

    if (this._isProfiling) {
      rendererInterface.startProfiling(this._recordChangeDescriptions);
    }

    rendererInterface.setTraceUpdatesEnabled(this._traceUpdatesEnabled); // When the renderer is attached, we need to tell it whether
    // we remember the previous selection that we'd like to restore.
    // It'll start tracking mounts for matches to the last selection path.

    const selection = this._persistedSelection;

    if (selection !== null && selection.rendererID === rendererID) {
      rendererInterface.setTrackedPath(selection.path);
    }
  }

  onUnsupportedRenderer(rendererID) {
    this._bridge.send('unsupportedRendererVersion', rendererID);
  }

}
// EXTERNAL MODULE: ../react-devtools-shared/src/bridge.js
var src_bridge = __webpack_require__(48);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/legacy/utils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function decorate(object, attr, fn) {
  const old = object[attr];

  object[attr] = function (instance) {
    return fn.call(this, old, arguments);
  };

  return old;
}
function decorateMany(source, fns) {
  const olds = {};

  for (const name in fns) {
    olds[name] = decorate(source, name, fns[name]);
  }

  return olds;
}
function restoreMany(source, olds) {
  for (const name in olds) {
    source[name] = olds[name];
  }
}
function forceUpdate(instance) {
  if (typeof instance.forceUpdate === 'function') {
    instance.forceUpdate();
  } else if (instance.updater != null && typeof instance.updater.enqueueForceUpdate === 'function') {
    instance.updater.enqueueForceUpdate(this, () => {}, 'forceUpdate');
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/legacy/renderer.js
function legacy_renderer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function legacy_renderer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { legacy_renderer_ownKeys(Object(source), true).forEach(function (key) { legacy_renderer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { legacy_renderer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function legacy_renderer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */







function getData(internalInstance) {
  let displayName = null;
  let key = null; // != used deliberately here to catch undefined and null

  if (internalInstance._currentElement != null) {
    if (internalInstance._currentElement.key) {
      key = '' + internalInstance._currentElement.key;
    }

    const elementType = internalInstance._currentElement.type;

    if (typeof elementType === 'string') {
      displayName = elementType;
    } else if (typeof elementType === 'function') {
      displayName = Object(utils["h" /* getDisplayName */])(elementType);
    }
  }

  return {
    displayName,
    key
  };
}

function getElementType(internalInstance) {
  // != used deliberately here to catch undefined and null
  if (internalInstance._currentElement != null) {
    const elementType = internalInstance._currentElement.type;

    if (typeof elementType === 'function') {
      const publicInstance = internalInstance.getPublicInstance();

      if (publicInstance !== null) {
        return types["e" /* ElementTypeClass */];
      } else {
        return types["h" /* ElementTypeFunction */];
      }
    } else if (typeof elementType === 'string') {
      return types["i" /* ElementTypeHostComponent */];
    }
  }

  return types["k" /* ElementTypeOtherOrUnknown */];
}

function getChildren(internalInstance) {
  const children = []; // If the parent is a native node without rendered children, but with
  // multiple string children, then the `element` that gets passed in here is
  // a plain value -- a string or number.

  if (typeof internalInstance !== 'object') {// No children
  } else if (internalInstance._currentElement === null || internalInstance._currentElement === false) {// No children
  } else if (internalInstance._renderedComponent) {
    const child = internalInstance._renderedComponent;

    if (getElementType(child) !== types["k" /* ElementTypeOtherOrUnknown */]) {
      children.push(child);
    }
  } else if (internalInstance._renderedChildren) {
    const renderedChildren = internalInstance._renderedChildren;

    for (const name in renderedChildren) {
      const child = renderedChildren[name];

      if (getElementType(child) !== types["k" /* ElementTypeOtherOrUnknown */]) {
        children.push(child);
      }
    }
  } // Note: we skip the case where children are just strings or numbers
  // because the new DevTools skips over host text nodes anyway.


  return children;
}

function legacy_renderer_attach(hook, rendererID, renderer, global) {
  const idToInternalInstanceMap = new Map();
  const internalInstanceToIDMap = new WeakMap();
  const internalInstanceToRootIDMap = new WeakMap();
  let getInternalIDForNative = null;
  let findNativeNodeForInternalID;

  if (renderer.ComponentTree) {
    getInternalIDForNative = (node, findNearestUnfilteredAncestor) => {
      const internalInstance = renderer.ComponentTree.getClosestInstanceFromNode(node);
      return internalInstanceToIDMap.get(internalInstance) || null;
    };

    findNativeNodeForInternalID = id => {
      const internalInstance = idToInternalInstanceMap.get(id);
      return renderer.ComponentTree.getNodeFromInstance(internalInstance);
    };
  } else if (renderer.Mount.getID && renderer.Mount.getNode) {
    getInternalIDForNative = (node, findNearestUnfilteredAncestor) => {
      // Not implemented.
      return null;
    };

    findNativeNodeForInternalID = id => {
      // Not implemented.
      return null;
    };
  }

  function getDisplayNameForFiberID(id) {
    const internalInstance = idToInternalInstanceMap.get(id);
    return internalInstance ? getData(internalInstance).displayName : null;
  }

  function getID(internalInstance) {
    if (typeof internalInstance !== 'object' || internalInstance === null) {
      throw new Error('Invalid internal instance: ' + internalInstance);
    }

    if (!internalInstanceToIDMap.has(internalInstance)) {
      const id = Object(utils["l" /* getUID */])();
      internalInstanceToIDMap.set(internalInstance, id);
      idToInternalInstanceMap.set(id, internalInstance);
    }

    return internalInstanceToIDMap.get(internalInstance);
  }

  function areEqualArrays(a, b) {
    if (a.length !== b.length) {
      return false;
    }

    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }

    return true;
  } // This is shared mutable state that lets us keep track of where we are.


  let parentIDStack = [];
  let oldReconcilerMethods = null;

  if (renderer.Reconciler) {
    // React 15
    oldReconcilerMethods = decorateMany(renderer.Reconciler, {
      mountComponent(fn, args) {
        const internalInstance = args[0];
        const hostContainerInfo = args[3];

        if (getElementType(internalInstance) === types["k" /* ElementTypeOtherOrUnknown */]) {
          return fn.apply(this, args);
        }

        if (hostContainerInfo._topLevelWrapper === undefined) {
          // SSR
          return fn.apply(this, args);
        }

        const id = getID(internalInstance); // Push the operation.

        const parentID = parentIDStack.length > 0 ? parentIDStack[parentIDStack.length - 1] : 0;
        recordMount(internalInstance, id, parentID);
        parentIDStack.push(id); // Remember the root.

        internalInstanceToRootIDMap.set(internalInstance, getID(hostContainerInfo._topLevelWrapper));

        try {
          const result = fn.apply(this, args);
          parentIDStack.pop();
          return result;
        } catch (err) {
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            const rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      },

      performUpdateIfNecessary(fn, args) {
        const internalInstance = args[0];

        if (getElementType(internalInstance) === types["k" /* ElementTypeOtherOrUnknown */]) {
          return fn.apply(this, args);
        }

        const id = getID(internalInstance);
        parentIDStack.push(id);
        const prevChildren = getChildren(internalInstance);

        try {
          const result = fn.apply(this, args);
          const nextChildren = getChildren(internalInstance);

          if (!areEqualArrays(prevChildren, nextChildren)) {
            // Push the operation
            recordReorder(internalInstance, id, nextChildren);
          }

          parentIDStack.pop();
          return result;
        } catch (err) {
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            const rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      },

      receiveComponent(fn, args) {
        const internalInstance = args[0];

        if (getElementType(internalInstance) === types["k" /* ElementTypeOtherOrUnknown */]) {
          return fn.apply(this, args);
        }

        const id = getID(internalInstance);
        parentIDStack.push(id);
        const prevChildren = getChildren(internalInstance);

        try {
          const result = fn.apply(this, args);
          const nextChildren = getChildren(internalInstance);

          if (!areEqualArrays(prevChildren, nextChildren)) {
            // Push the operation
            recordReorder(internalInstance, id, nextChildren);
          }

          parentIDStack.pop();
          return result;
        } catch (err) {
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            const rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      },

      unmountComponent(fn, args) {
        const internalInstance = args[0];

        if (getElementType(internalInstance) === types["k" /* ElementTypeOtherOrUnknown */]) {
          return fn.apply(this, args);
        }

        const id = getID(internalInstance);
        parentIDStack.push(id);

        try {
          const result = fn.apply(this, args);
          parentIDStack.pop(); // Push the operation.

          recordUnmount(internalInstance, id);
          return result;
        } catch (err) {
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            const rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      }

    });
  }

  function cleanup() {
    if (oldReconcilerMethods !== null) {
      if (renderer.Component) {
        restoreMany(renderer.Component.Mixin, oldReconcilerMethods);
      } else {
        restoreMany(renderer.Reconciler, oldReconcilerMethods);
      }
    }

    oldReconcilerMethods = null;
  }

  function recordMount(internalInstance, id, parentID) {
    const isRoot = parentID === 0;

    if (constants["q" /* __DEBUG__ */]) {
      console.log('%crecordMount()', 'color: green; font-weight: bold;', id, getData(internalInstance).displayName);
    }

    if (isRoot) {
      // TODO Is this right? For all versions?
      const hasOwnerMetadata = internalInstance._currentElement != null && internalInstance._currentElement._owner != null;
      pushOperation(constants["l" /* TREE_OPERATION_ADD */]);
      pushOperation(id);
      pushOperation(types["m" /* ElementTypeRoot */]);
      pushOperation(0); // isProfilingSupported?

      pushOperation(hasOwnerMetadata ? 1 : 0);
    } else {
      const type = getElementType(internalInstance);

      const _getData = getData(internalInstance),
            displayName = _getData.displayName,
            key = _getData.key;

      const ownerID = internalInstance._currentElement != null && internalInstance._currentElement._owner != null ? getID(internalInstance._currentElement._owner) : 0;
      const displayNameStringID = getStringID(displayName);
      const keyStringID = getStringID(key);
      pushOperation(constants["l" /* TREE_OPERATION_ADD */]);
      pushOperation(id);
      pushOperation(type);
      pushOperation(parentID);
      pushOperation(ownerID);
      pushOperation(displayNameStringID);
      pushOperation(keyStringID);
    }
  }

  function recordReorder(internalInstance, id, nextChildren) {
    pushOperation(constants["n" /* TREE_OPERATION_REORDER_CHILDREN */]);
    pushOperation(id);
    const nextChildIDs = nextChildren.map(getID);
    pushOperation(nextChildIDs.length);

    for (let i = 0; i < nextChildIDs.length; i++) {
      pushOperation(nextChildIDs[i]);
    }
  }

  function recordUnmount(internalInstance, id) {
    pendingUnmountedIDs.push(id);
    idToInternalInstanceMap.delete(id);
  }

  function crawlAndRecordInitialMounts(id, parentID, rootID) {
    if (constants["q" /* __DEBUG__ */]) {
      console.group('crawlAndRecordInitialMounts() id:', id);
    }

    const internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      internalInstanceToRootIDMap.set(internalInstance, rootID);
      recordMount(internalInstance, id, parentID);
      getChildren(internalInstance).forEach(child => crawlAndRecordInitialMounts(getID(child), id, rootID));
    }

    if (constants["q" /* __DEBUG__ */]) {
      console.groupEnd();
    }
  }

  function flushInitialOperations() {
    // Crawl roots though and register any nodes that mounted before we were injected.
    const roots = renderer.Mount._instancesByReactRootID || renderer.Mount._instancesByContainerID;

    for (const key in roots) {
      const internalInstance = roots[key];
      const id = getID(internalInstance);
      crawlAndRecordInitialMounts(id, 0, id);
      flushPendingEvents(id);
    }
  }

  const pendingOperations = [];
  const pendingStringTable = new Map();
  let pendingUnmountedIDs = [];
  let pendingStringTableLength = 0;
  let pendingUnmountedRootID = null;

  function flushPendingEvents(rootID) {
    if (pendingOperations.length === 0 && pendingUnmountedIDs.length === 0 && pendingUnmountedRootID === null) {
      return;
    }

    const numUnmountIDs = pendingUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);
    const operations = new Array( // Identify which renderer this update is coming from.
    2 + // [rendererID, rootFiberID]
    // How big is the string table?
    1 + // [stringTableLength]
    // Then goes the actual string table.
    pendingStringTableLength + ( // All unmounts are batched in a single message.
    // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]
    numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Mount operations
    pendingOperations.length); // Identify which renderer this update is coming from.
    // This enables roots to be mapped to renderers,
    // Which in turn enables fiber properations, states, and hooks to be inspected.

    let i = 0;
    operations[i++] = rendererID;
    operations[i++] = rootID; // Now fill in the string table.
    // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]

    operations[i++] = pendingStringTableLength;
    pendingStringTable.forEach((value, key) => {
      operations[i++] = key.length;
      const encodedKey = Object(utils["t" /* utfEncodeString */])(key);

      for (let j = 0; j < encodedKey.length; j++) {
        operations[i + j] = encodedKey[j];
      }

      i += key.length;
    });

    if (numUnmountIDs > 0) {
      // All unmounts except roots are batched in a single message.
      operations[i++] = constants["m" /* TREE_OPERATION_REMOVE */]; // The first number is how many unmounted IDs we're gonna send.

      operations[i++] = numUnmountIDs; // Fill in the unmounts

      for (let j = 0; j < pendingUnmountedIDs.length; j++) {
        operations[i++] = pendingUnmountedIDs[j];
      } // The root ID should always be unmounted last.


      if (pendingUnmountedRootID !== null) {
        operations[i] = pendingUnmountedRootID;
        i++;
      }
    } // Fill in the rest of the operations.


    for (let j = 0; j < pendingOperations.length; j++) {
      operations[i + j] = pendingOperations[j];
    }

    i += pendingOperations.length;

    if (constants["q" /* __DEBUG__ */]) {
      Object(utils["m" /* printOperationsArray */])(operations);
    } // If we've already connected to the frontend, just pass the operations through.


    hook.emit('operations', operations);
    pendingOperations.length = 0;
    pendingUnmountedIDs = [];
    pendingUnmountedRootID = null;
    pendingStringTable.clear();
    pendingStringTableLength = 0;
  }

  function pushOperation(op) {
    if (false) {}

    pendingOperations.push(op);
  }

  function getStringID(str) {
    if (str === null) {
      return 0;
    }

    const existingID = pendingStringTable.get(str);

    if (existingID !== undefined) {
      return existingID;
    }

    const stringID = pendingStringTable.size + 1;
    pendingStringTable.set(str, stringID); // The string table total length needs to account
    // both for the string length, and for the array item
    // that contains the length itself. Hence + 1.

    pendingStringTableLength += str.length + 1;
    return stringID;
  }

  let currentlyInspectedElementID = null;
  let currentlyInspectedPaths = {}; // Track the intersection of currently inspected paths,
  // so that we can send their data along if the element is re-rendered.

  function mergeInspectedPaths(path) {
    let current = currentlyInspectedPaths;
    path.forEach(key => {
      if (!current[key]) {
        current[key] = {};
      }

      current = current[key];
    });
  }

  function createIsPathAllowed(key) {
    // This function helps prevent previously-inspected paths from being dehydrated in updates.
    // This is important to avoid a bad user experience where expanded toggles collapse on update.
    return function isPathAllowed(path) {
      let current = currentlyInspectedPaths[key];

      if (!current) {
        return false;
      }

      for (let i = 0; i < path.length; i++) {
        current = current[path[i]];

        if (!current) {
          return false;
        }
      }

      return true;
    };
  } // Fast path props lookup for React Native style editor.


  function getInstanceAndStyle(id) {
    let instance = null;
    let style = null;
    const internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      instance = internalInstance._instance || null;
      const element = internalInstance._currentElement;

      if (element != null && element.props != null) {
        style = element.props.style || null;
      }
    }

    return {
      instance,
      style
    };
  }

  function updateSelectedElement(id) {
    const internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance == null) {
      console.warn(`Could not find instance with id "${id}"`);
      return;
    }

    switch (getElementType(internalInstance)) {
      case types["e" /* ElementTypeClass */]:
        global.$r = internalInstance._instance;
        break;

      case types["h" /* ElementTypeFunction */]:
        const element = internalInstance._currentElement;

        if (element == null) {
          console.warn(`Could not find element with id "${id}"`);
          return;
        }

        global.$r = {
          props: element.props,
          type: element.type
        };
        break;

      default:
        global.$r = null;
        break;
    }
  }

  function storeAsGlobal(id, path, count) {
    const inspectedElement = inspectElementRaw(id);

    if (inspectedElement !== null) {
      const value = Object(utils["j" /* getInObject */])(inspectedElement, path);
      const key = `$reactTemp${count}`;
      window[key] = value;
      console.log(key);
      console.log(value);
    }
  }

  function copyElementPath(id, path) {
    const inspectedElement = inspectElementRaw(id);

    if (inspectedElement !== null) {
      copyToClipboard(Object(utils["j" /* getInObject */])(inspectedElement, path));
    }
  }

  function inspectElement(id, path) {
    if (currentlyInspectedElementID !== id) {
      currentlyInspectedElementID = id;
      currentlyInspectedPaths = {};
    }

    const inspectedElement = inspectElementRaw(id);

    if (inspectedElement === null) {
      return {
        id,
        type: 'not-found'
      };
    }

    if (path != null) {
      mergeInspectedPaths(path);
    } // Any time an inspected element has an update,
    // we should update the selected $r value as wel.
    // Do this before dehyration (cleanForBridge).


    updateSelectedElement(id);
    inspectedElement.context = cleanForBridge(inspectedElement.context, createIsPathAllowed('context'));
    inspectedElement.props = cleanForBridge(inspectedElement.props, createIsPathAllowed('props'));
    inspectedElement.state = cleanForBridge(inspectedElement.state, createIsPathAllowed('state'));
    return {
      id,
      type: 'full-data',
      value: inspectedElement
    };
  }

  function inspectElementRaw(id) {
    const internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance == null) {
      return null;
    }

    const _getData2 = getData(internalInstance),
          displayName = _getData2.displayName,
          key = _getData2.key;

    const type = getElementType(internalInstance);
    let context = null;
    let owners = null;
    let props = null;
    let state = null;
    let source = null;
    const element = internalInstance._currentElement;

    if (element !== null) {
      props = element.props;
      source = element._source != null ? element._source : null;
      let owner = element._owner;

      if (owner) {
        owners = [];

        while (owner != null) {
          owners.push({
            displayName: getData(owner).displayName || 'Unknown',
            id: getID(owner),
            type: getElementType(owner)
          });

          if (owner._currentElement) {
            owner = owner._currentElement._owner;
          }
        }
      }
    }

    const publicInstance = internalInstance._instance;

    if (publicInstance != null) {
      context = publicInstance.context || null;
      state = publicInstance.state || null;
    }

    return {
      id,
      // Does the current renderer support editable hooks and function props?
      canEditHooks: false,
      canEditFunctionProps: false,
      // Does the current renderer support advanced editing interface?
      canEditHooksAndDeletePaths: false,
      canEditHooksAndRenamePaths: false,
      canEditFunctionPropsDeletePaths: false,
      canEditFunctionPropsRenamePaths: false,
      // Suspense did not exist in legacy versions
      canToggleSuspense: false,
      // Can view component source location.
      canViewSource: type === types["e" /* ElementTypeClass */] || type === types["h" /* ElementTypeFunction */],
      // Only legacy context exists in legacy versions.
      hasLegacyContext: true,
      displayName: displayName,
      type: type,
      key: key != null ? key : null,
      // Inspectable properties.
      context,
      hooks: null,
      props,
      state,
      // List of owners
      owners,
      // Location of component in source code.
      source,
      rootType: null,
      rendererPackageName: null,
      rendererVersion: null
    };
  }

  function logElementToConsole(id) {
    const result = inspectElementRaw(id);

    if (result === null) {
      console.warn(`Could not find element with id "${id}"`);
      return;
    }

    const supportsGroup = typeof console.groupCollapsed === 'function';

    if (supportsGroup) {
      console.groupCollapsed(`[Click to expand] %c<${result.displayName || 'Component'} />`, // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.
      'color: var(--dom-tag-name-color); font-weight: normal;');
    }

    if (result.props !== null) {
      console.log('Props:', result.props);
    }

    if (result.state !== null) {
      console.log('State:', result.state);
    }

    if (result.context !== null) {
      console.log('Context:', result.context);
    }

    const nativeNode = findNativeNodeForInternalID(id);

    if (nativeNode !== null) {
      console.log('Node:', nativeNode);
    }

    if (window.chrome || /firefox/i.test(navigator.userAgent)) {
      console.log('Right-click any value to save it as a global variable for further inspection.');
    }

    if (supportsGroup) {
      console.groupEnd();
    }
  }

  function prepareViewAttributeSource(id, path) {
    const inspectedElement = inspectElementRaw(id);

    if (inspectedElement !== null) {
      window.$attribute = Object(utils["j" /* getInObject */])(inspectedElement, path);
    }
  }

  function prepareViewElementSource(id) {
    const internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance == null) {
      console.warn(`Could not find instance with id "${id}"`);
      return;
    }

    const element = internalInstance._currentElement;

    if (element == null) {
      console.warn(`Could not find element with id "${id}"`);
      return;
    }

    global.$type = element.type;
  }

  function deletePath(type, id, hookID, path) {
    const internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      const publicInstance = internalInstance._instance;

      if (publicInstance != null) {
        switch (type) {
          case 'context':
            Object(utils["a" /* deletePathInObject */])(publicInstance.context, path);
            forceUpdate(publicInstance);
            break;

          case 'hooks':
            throw new Error('Hooks not supported by this renderer');

          case 'props':
            const element = internalInstance._currentElement;
            internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {
              props: copyWithDelete(element.props, path)
            });
            forceUpdate(publicInstance);
            break;

          case 'state':
            Object(utils["a" /* deletePathInObject */])(publicInstance.state, path);
            forceUpdate(publicInstance);
            break;
        }
      }
    }
  }

  function renamePath(type, id, hookID, oldPath, newPath) {
    const internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      const publicInstance = internalInstance._instance;

      if (publicInstance != null) {
        switch (type) {
          case 'context':
            Object(utils["n" /* renamePathInObject */])(publicInstance.context, oldPath, newPath);
            forceUpdate(publicInstance);
            break;

          case 'hooks':
            throw new Error('Hooks not supported by this renderer');

          case 'props':
            const element = internalInstance._currentElement;
            internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {
              props: copyWithRename(element.props, oldPath, newPath)
            });
            forceUpdate(publicInstance);
            break;

          case 'state':
            Object(utils["n" /* renamePathInObject */])(publicInstance.state, oldPath, newPath);
            forceUpdate(publicInstance);
            break;
        }
      }
    }
  }

  function overrideValueAtPath(type, id, hookID, path, value) {
    const internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      const publicInstance = internalInstance._instance;

      if (publicInstance != null) {
        switch (type) {
          case 'context':
            Object(utils["q" /* setInObject */])(publicInstance.context, path, value);
            forceUpdate(publicInstance);
            break;

          case 'hooks':
            throw new Error('Hooks not supported by this renderer');

          case 'props':
            const element = internalInstance._currentElement;
            internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {
              props: copyWithSet(element.props, path, value)
            });
            forceUpdate(publicInstance);
            break;

          case 'state':
            Object(utils["q" /* setInObject */])(publicInstance.state, path, value);
            forceUpdate(publicInstance);
            break;
        }
      }
    }
  } // v16+ only features


  const getProfilingData = () => {
    throw new Error('getProfilingData not supported by this renderer');
  };

  const handleCommitFiberRoot = () => {
    throw new Error('handleCommitFiberRoot not supported by this renderer');
  };

  const handleCommitFiberUnmount = () => {
    throw new Error('handleCommitFiberUnmount not supported by this renderer');
  };

  const overrideSuspense = () => {
    throw new Error('overrideSuspense not supported by this renderer');
  };

  const startProfiling = () => {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.
  };

  const stopProfiling = () => {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.
  };

  function getBestMatchForTrackedPath() {
    // Not implemented.
    return null;
  }

  function getPathForElement(id) {
    // Not implemented.
    return null;
  }

  function updateComponentFilters(componentFilters) {// Not implemented.
  }

  function setTraceUpdatesEnabled(enabled) {// Not implemented.
  }

  function setTrackedPath(path) {// Not implemented.
  }

  function getOwnersList(id) {
    // Not implemented.
    return null;
  }

  return {
    cleanup,
    copyElementPath,
    deletePath,
    flushInitialOperations,
    getBestMatchForTrackedPath,
    getDisplayNameForFiberID,
    getFiberIDForNative: getInternalIDForNative,
    getInstanceAndStyle,
    findNativeNodesForFiberID: id => {
      const nativeNode = findNativeNodeForInternalID(id);
      return nativeNode == null ? null : [nativeNode];
    },
    getOwnersList,
    getPathForElement,
    getProfilingData,
    handleCommitFiberRoot,
    handleCommitFiberUnmount,
    inspectElement,
    logElementToConsole,
    overrideSuspense,
    overrideValueAtPath,
    renamePath,
    prepareViewAttributeSource,
    prepareViewElementSource,
    renderer,
    setTraceUpdatesEnabled,
    setTrackedPath,
    startProfiling,
    stopProfiling,
    storeAsGlobal,
    updateComponentFilters
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



function initBackend(hook, agent, global) {
  if (hook == null) {
    // DevTools didn't get injected into this page (maybe b'c of the contentType).
    return () => {};
  }

  const subs = [hook.sub('renderer-attached', ({
    id,
    renderer,
    rendererInterface
  }) => {
    agent.setRendererInterface(id, rendererInterface); // Now that the Store and the renderer interface are connected,
    // it's time to flush the pending operation codes to the frontend.

    rendererInterface.flushInitialOperations();
  }), hook.sub('unsupported-renderer-version', id => {
    agent.onUnsupportedRenderer(id);
  }), hook.sub('operations', agent.onHookOperations), hook.sub('traceUpdates', agent.onTraceUpdates) // TODO Add additional subscriptions required for profiling mode
  ];

  const attachRenderer = (id, renderer) => {
    let rendererInterface = hook.rendererInterfaces.get(id); // Inject any not-yet-injected renderers (if we didn't reload-and-profile)

    if (rendererInterface == null) {
      if (typeof renderer.findFiberByHostInstance === 'function') {
        // react-reconciler v16+
        rendererInterface = renderer_attach(hook, id, renderer, global);
      } else if (renderer.ComponentTree) {
        // react-dom v15
        rendererInterface = legacy_renderer_attach(hook, id, renderer, global);
      } else {// Older react-dom or other unsupported renderer version
      }

      if (rendererInterface != null) {
        hook.rendererInterfaces.set(id, rendererInterface);
      }
    } // Notify the DevTools frontend about new renderers.
    // This includes any that were attached early (via __REACT_DEVTOOLS_ATTACH__).


    if (rendererInterface != null) {
      hook.emit('renderer-attached', {
        id,
        renderer,
        rendererInterface
      });
    } else {
      hook.emit('unsupported-renderer-version', id);
    }
  }; // Connect renderers that have already injected themselves.


  hook.renderers.forEach((renderer, id) => {
    attachRenderer(id, renderer);
  }); // Connect any new renderers that injected themselves.

  subs.push(hook.sub('renderer', ({
    id,
    renderer
  }) => {
    attachRenderer(id, renderer);
  }));
  hook.emit('react-devtools', agent);
  hook.reactDevtoolsAgent = agent;

  const onAgentShutdown = () => {
    subs.forEach(fn => fn());
    hook.rendererInterfaces.forEach(rendererInterface => {
      rendererInterface.cleanup();
    });
    hook.reactDevtoolsAgent = null;
  };

  agent.addListener('shutdown', onAgentShutdown);
  subs.push(() => {
    agent.removeListener('shutdown', onAgentShutdown);
  });
  return () => {
    subs.forEach(fn => fn());
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/hook.js
/**
 * Install the hook on window, which is an event emitter.
 * Note because Chrome content scripts cannot directly modify the window object,
 * we are evaling this function by inserting a script tag.
 * That's why we have to inline the whole event emitter implementation here.
 *
 * 
 */

function installHook(target) {
  if (target.hasOwnProperty('__REACT_DEVTOOLS_GLOBAL_HOOK__')) {
    return null;
  }

  function detectReactBuildType(renderer) {
    try {
      if (typeof renderer.version === 'string') {
        // React DOM Fiber (16+)
        if (renderer.bundleType > 0) {
          // This is not a production build.
          // We are currently only using 0 (PROD) and 1 (DEV)
          // but might add 2 (PROFILE) in the future.
          return 'development';
        } // React 16 uses flat bundles. If we report the bundle as production
        // version, it means we also minified and envified it ourselves.


        return 'production'; // Note: There is still a risk that the CommonJS entry point has not
        // been envified or uglified. In this case the user would have *both*
        // development and production bundle, but only the prod one would run.
        // This would be really bad. We have a separate check for this because
        // it happens *outside* of the renderer injection. See `checkDCE` below.
      }

      const toString = Function.prototype.toString;

      if (renderer.Mount && renderer.Mount._renderNewRootComponent) {
        // React DOM Stack
        const renderRootCode = toString.call(renderer.Mount._renderNewRootComponent); // Filter out bad results (if that is even possible):

        if (renderRootCode.indexOf('function') !== 0) {
          // Hope for the best if we're not sure.
          return 'production';
        } // Check for React DOM Stack < 15.1.0 in development.
        // If it contains "storedMeasure" call, it's wrapped in ReactPerf (DEV only).
        // This would be true even if it's minified, as method name still matches.


        if (renderRootCode.indexOf('storedMeasure') !== -1) {
          return 'development';
        } // For other versions (and configurations) it's not so easy.
        // Let's quickly exclude proper production builds.
        // If it contains a warning message, it's either a DEV build,
        // or an PROD build without proper dead code elimination.


        if (renderRootCode.indexOf('should be a pure function') !== -1) {
          // Now how do we tell a DEV build from a bad PROD build?
          // If we see NODE_ENV, we're going to assume this is a dev build
          // because most likely it is referring to an empty shim.
          if (renderRootCode.indexOf('NODE_ENV') !== -1) {
            return 'development';
          } // If we see "development", we're dealing with an envified DEV build
          // (such as the official React DEV UMD).


          if (renderRootCode.indexOf('development') !== -1) {
            return 'development';
          } // I've seen process.env.NODE_ENV !== 'production' being smartly
          // replaced by `true` in DEV by Webpack. I don't know how that
          // works but we can safely guard against it because `true` was
          // never used in the function source since it was written.


          if (renderRootCode.indexOf('true') !== -1) {
            return 'development';
          } // By now either it is a production build that has not been minified,
          // or (worse) this is a minified development build using non-standard
          // environment (e.g. "staging"). We're going to look at whether
          // the function argument name is mangled:


          if ( // 0.13 to 15
          renderRootCode.indexOf('nextElement') !== -1 || // 0.12
          renderRootCode.indexOf('nextComponent') !== -1) {
            // We can't be certain whether this is a development build or not,
            // but it is definitely unminified.
            return 'unminified';
          } else {
            // This is likely a minified development build.
            return 'development';
          }
        } // By now we know that it's envified and dead code elimination worked,
        // but what if it's still not minified? (Is this even possible?)
        // Let's check matches for the first argument name.


        if ( // 0.13 to 15
        renderRootCode.indexOf('nextElement') !== -1 || // 0.12
        renderRootCode.indexOf('nextComponent') !== -1) {
          return 'unminified';
        } // Seems like we're using the production version.
        // However, the branch above is Stack-only so this is 15 or earlier.


        return 'outdated';
      }
    } catch (err) {// Weird environments may exist.
      // This code needs a higher fault tolerance
      // because it runs even with closed DevTools.
      // TODO: should we catch errors in all injected code, and not just this part?
    }

    return 'production';
  }

  function checkDCE(fn) {
    // This runs for production versions of React.
    // Needs to be super safe.
    try {
      const toString = Function.prototype.toString;
      const code = toString.call(fn); // This is a string embedded in the passed function under DEV-only
      // condition. However the function executes only in PROD. Therefore,
      // if we see it, dead code elimination did not work.

      if (code.indexOf('^_^') > -1) {
        // Remember to report during next injection.
        hasDetectedBadDCE = true; // Bonus: throw an exception hoping that it gets picked up by a reporting system.
        // Not synchronously so that it doesn't break the calling code.

        setTimeout(function () {
          throw new Error('React is running in production mode, but dead code ' + 'elimination has not been applied. Read how to correctly ' + 'configure React for production: ' + 'https://reactjs.org/link/perf-use-production-build');
        });
      }
    } catch (err) {}
  }

  let uidCounter = 0;

  function inject(renderer) {
    const id = ++uidCounter;
    renderers.set(id, renderer);
    const reactBuildType = hasDetectedBadDCE ? 'deadcode' : detectReactBuildType(renderer); // Patching the console enables DevTools to do a few useful things:
    // * Append component stacks to warnings and error messages
    // * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)
    //
    // For React Native, we intentionally patch early (during injection).
    // This provides React Native developers with components stacks even if they don't run DevTools.
    // This won't work for DOM though, since this entire file is eval'ed and inserted as a script tag.
    // In that case, we'll patch later (when the frontend attaches).
    //
    // Don't patch in test environments because we don't want to interfere with Jest's own console overrides.
    //
    // Note that because this function is inlined, this conditional check must only use static booleans.
    // Otherwise the extension will throw with an undefined error.
    // (See comments in the try/catch below for more context on inlining.)

    if (true) {
      try {
        const appendComponentStack = window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ !== false;
        const breakOnConsoleErrors = window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ === true; // The installHook() function is injected by being stringified in the browser,
        // so imports outside of this function do not get included.
        //
        // Normally we could check "typeof patchConsole === 'function'",
        // but Webpack wraps imports with an object (e.g. _backend_console__WEBPACK_IMPORTED_MODULE_0__)
        // and the object itself will be undefined as well for the reasons mentioned above,
        // so we use try/catch instead.

        if (appendComponentStack || breakOnConsoleErrors) {
          registerRenderer(renderer);
          patch({
            appendComponentStack,
            breakOnConsoleErrors
          });
        }
      } catch (error) {}
    } // If we have just reloaded to profile, we need to inject the renderer interface before the app loads.
    // Otherwise the renderer won't yet exist and we can skip this step.


    const attach = target.__REACT_DEVTOOLS_ATTACH__;

    if (typeof attach === 'function') {
      const rendererInterface = attach(hook, id, renderer, target);
      hook.rendererInterfaces.set(id, rendererInterface);
    }

    hook.emit('renderer', {
      id,
      renderer,
      reactBuildType
    });
    return id;
  }

  let hasDetectedBadDCE = false;

  function sub(event, fn) {
    hook.on(event, fn);
    return () => hook.off(event, fn);
  }

  function on(event, fn) {
    if (!listeners[event]) {
      listeners[event] = [];
    }

    listeners[event].push(fn);
  }

  function off(event, fn) {
    if (!listeners[event]) {
      return;
    }

    const index = listeners[event].indexOf(fn);

    if (index !== -1) {
      listeners[event].splice(index, 1);
    }

    if (!listeners[event].length) {
      delete listeners[event];
    }
  }

  function emit(event, data) {
    if (listeners[event]) {
      listeners[event].map(fn => fn(data));
    }
  }

  function getFiberRoots(rendererID) {
    const roots = fiberRoots;

    if (!roots[rendererID]) {
      roots[rendererID] = new Set();
    }

    return roots[rendererID];
  }

  function onCommitFiberUnmount(rendererID, fiber) {
    const rendererInterface = rendererInterfaces.get(rendererID);

    if (rendererInterface != null) {
      rendererInterface.handleCommitFiberUnmount(fiber);
    }
  }

  function onCommitFiberRoot(rendererID, root, priorityLevel) {
    const mountedRoots = hook.getFiberRoots(rendererID);
    const current = root.current;
    const isKnownRoot = mountedRoots.has(root);
    const isUnmounting = current.memoizedState == null || current.memoizedState.element == null; // Keep track of mounted roots so we can hydrate when DevTools connect.

    if (!isKnownRoot && !isUnmounting) {
      mountedRoots.add(root);
    } else if (isKnownRoot && isUnmounting) {
      mountedRoots.delete(root);
    }

    const rendererInterface = rendererInterfaces.get(rendererID);

    if (rendererInterface != null) {
      rendererInterface.handleCommitFiberRoot(root, priorityLevel);
    }
  } // TODO: More meaningful names for "rendererInterfaces" and "renderers".


  const fiberRoots = {};
  const rendererInterfaces = new Map();
  const listeners = {};
  const renderers = new Map();
  const hook = {
    rendererInterfaces,
    listeners,
    // Fast Refresh for web relies on this.
    renderers,
    emit,
    getFiberRoots,
    inject,
    on,
    off,
    sub,
    // This is a legacy flag.
    // React v16 checks the hook for this to ensure DevTools is new enough.
    supportsFiber: true,
    // React calls these methods.
    checkDCE,
    onCommitFiberUnmount,
    onCommitFiberRoot
  };
  Object.defineProperty(target, '__REACT_DEVTOOLS_GLOBAL_HOOK__', {
    // This property needs to be configurable for the test environment,
    // else we won't be able to delete and recreate it beween tests.
    configurable: false,
    enumerable: false,

    get() {
      return hook;
    }

  });
  return hook;
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/NativeStyleEditor/resolveBoxStyle.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * This mirrors react-native/Libraries/Inspector/resolveBoxStyle.js (but without RTL support).
 *
 * Resolve a style property into it's component parts, e.g.
 *
 * resolveBoxStyle('margin', {margin: 5, marginBottom: 10})
 * -> {top: 5, left: 5, right: 5, bottom: 10}
 */
function resolveBoxStyle(prefix, style) {
  let hasParts = false;
  const result = {
    bottom: 0,
    left: 0,
    right: 0,
    top: 0
  };
  const styleForAll = style[prefix];

  if (styleForAll != null) {
    // eslint-disable-next-line no-for-of-loops/no-for-of-loops
    for (var _i = 0, _Object$keys = Object.keys(result); _i < _Object$keys.length; _i++) {
      const key = _Object$keys[_i];
      result[key] = styleForAll;
    }

    hasParts = true;
  }

  const styleForHorizontal = style[prefix + 'Horizontal'];

  if (styleForHorizontal != null) {
    result.left = styleForHorizontal;
    result.right = styleForHorizontal;
    hasParts = true;
  } else {
    const styleForLeft = style[prefix + 'Left'];

    if (styleForLeft != null) {
      result.left = styleForLeft;
      hasParts = true;
    }

    const styleForRight = style[prefix + 'Right'];

    if (styleForRight != null) {
      result.right = styleForRight;
      hasParts = true;
    }

    const styleForEnd = style[prefix + 'End'];

    if (styleForEnd != null) {
      // TODO RTL support
      result.right = styleForEnd;
      hasParts = true;
    }

    const styleForStart = style[prefix + 'Start'];

    if (styleForStart != null) {
      // TODO RTL support
      result.left = styleForStart;
      hasParts = true;
    }
  }

  const styleForVertical = style[prefix + 'Vertical'];

  if (styleForVertical != null) {
    result.bottom = styleForVertical;
    result.top = styleForVertical;
    hasParts = true;
  } else {
    const styleForBottom = style[prefix + 'Bottom'];

    if (styleForBottom != null) {
      result.bottom = styleForBottom;
      hasParts = true;
    }

    const styleForTop = style[prefix + 'Top'];

    if (styleForTop != null) {
      result.top = styleForTop;
      hasParts = true;
    }
  }

  return hasParts ? result : null;
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


function setupNativeStyleEditor(bridge, agent, resolveNativeStyle, validAttributes) {
  bridge.addListener('NativeStyleEditor_measure', ({
    id,
    rendererID
  }) => {
    measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);
  });
  bridge.addListener('NativeStyleEditor_renameAttribute', ({
    id,
    rendererID,
    oldName,
    newName,
    value
  }) => {
    renameStyle(agent, id, rendererID, oldName, newName, value);
    setTimeout(() => measureStyle(agent, bridge, resolveNativeStyle, id, rendererID));
  });
  bridge.addListener('NativeStyleEditor_setValue', ({
    id,
    rendererID,
    name,
    value
  }) => {
    setStyle(agent, id, rendererID, name, value);
    setTimeout(() => measureStyle(agent, bridge, resolveNativeStyle, id, rendererID));
  });
  bridge.send('isNativeStyleEditorSupported', {
    isSupported: true,
    validAttributes
  });
}
const EMPTY_BOX_STYLE = {
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
};
const componentIDToStyleOverrides = new Map();

function measureStyle(agent, bridge, resolveNativeStyle, id, rendererID) {
  const data = agent.getInstanceAndStyle({
    id,
    rendererID
  });

  if (!data || !data.style) {
    bridge.send('NativeStyleEditor_styleAndLayout', {
      id,
      layout: null,
      style: null
    });
    return;
  }

  const instance = data.instance,
        style = data.style;
  let resolvedStyle = resolveNativeStyle(style); // If it's a host component we edited before, amend styles.

  const styleOverrides = componentIDToStyleOverrides.get(id);

  if (styleOverrides != null) {
    resolvedStyle = Object.assign({}, resolvedStyle, styleOverrides);
  }

  if (!instance || typeof instance.measure !== 'function') {
    bridge.send('NativeStyleEditor_styleAndLayout', {
      id,
      layout: null,
      style: resolvedStyle || null
    });
    return;
  } // $FlowFixMe the parameter types of an unknown function are unknown


  instance.measure((x, y, width, height, left, top) => {
    // RN Android sometimes returns undefined here. Don't send measurements in this case.
    // https://github.com/jhen0409/react-native-debugger/issues/84#issuecomment-304611817
    if (typeof x !== 'number') {
      bridge.send('NativeStyleEditor_styleAndLayout', {
        id,
        layout: null,
        style: resolvedStyle || null
      });
      return;
    }

    const margin = resolvedStyle != null && resolveBoxStyle('margin', resolvedStyle) || EMPTY_BOX_STYLE;
    const padding = resolvedStyle != null && resolveBoxStyle('padding', resolvedStyle) || EMPTY_BOX_STYLE;
    bridge.send('NativeStyleEditor_styleAndLayout', {
      id,
      layout: {
        x,
        y,
        width,
        height,
        left,
        top,
        margin,
        padding
      },
      style: resolvedStyle || null
    });
  });
}

function shallowClone(object) {
  const cloned = {};

  for (const n in object) {
    cloned[n] = object[n];
  }

  return cloned;
}

function renameStyle(agent, id, rendererID, oldName, newName, value) {
  const data = agent.getInstanceAndStyle({
    id,
    rendererID
  });

  if (!data || !data.style) {
    return;
  }

  const instance = data.instance,
        style = data.style;
  const newStyle = newName ? {
    [oldName]: undefined,
    [newName]: value
  } : {
    [oldName]: undefined
  };
  let customStyle; // TODO It would be nice if the renderer interface abstracted this away somehow.

  if (instance !== null && typeof instance.setNativeProps === 'function') {
    // In the case of a host component, we need to use setNativeProps().
    // Remember to "correct" resolved styles when we read them next time.
    const styleOverrides = componentIDToStyleOverrides.get(id);

    if (!styleOverrides) {
      componentIDToStyleOverrides.set(id, newStyle);
    } else {
      Object.assign(styleOverrides, newStyle);
    } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli


    instance.setNativeProps({
      style: newStyle
    });
  } else if (Array.isArray(style)) {
    const lastIndex = style.length - 1;

    if (typeof style[lastIndex] === 'object' && !Array.isArray(style[lastIndex])) {
      customStyle = shallowClone(style[lastIndex]);
      delete customStyle[oldName];

      if (newName) {
        customStyle[newName] = value;
      } else {
        customStyle[oldName] = undefined;
      }

      agent.overrideValueAtPath({
        type: 'props',
        id,
        rendererID,
        path: ['style', lastIndex],
        value: customStyle
      });
    } else {
      agent.overrideValueAtPath({
        type: 'props',
        id,
        rendererID,
        path: ['style'],
        value: style.concat([newStyle])
      });
    }
  } else if (typeof style === 'object') {
    customStyle = shallowClone(style);
    delete customStyle[oldName];

    if (newName) {
      customStyle[newName] = value;
    } else {
      customStyle[oldName] = undefined;
    }

    agent.overrideValueAtPath({
      type: 'props',
      id,
      rendererID,
      path: ['style'],
      value: customStyle
    });
  } else {
    agent.overrideValueAtPath({
      type: 'props',
      id,
      rendererID,
      path: ['style'],
      value: [style, newStyle]
    });
  }

  agent.emit('hideNativeHighlight');
}

function setStyle(agent, id, rendererID, name, value) {
  const data = agent.getInstanceAndStyle({
    id,
    rendererID
  });

  if (!data || !data.style) {
    return;
  }

  const instance = data.instance,
        style = data.style;
  const newStyle = {
    [name]: value
  }; // TODO It would be nice if the renderer interface abstracted this away somehow.

  if (instance !== null && typeof instance.setNativeProps === 'function') {
    // In the case of a host component, we need to use setNativeProps().
    // Remember to "correct" resolved styles when we read them next time.
    const styleOverrides = componentIDToStyleOverrides.get(id);

    if (!styleOverrides) {
      componentIDToStyleOverrides.set(id, newStyle);
    } else {
      Object.assign(styleOverrides, newStyle);
    } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli


    instance.setNativeProps({
      style: newStyle
    });
  } else if (Array.isArray(style)) {
    const lastLength = style.length - 1;

    if (typeof style[lastLength] === 'object' && !Array.isArray(style[lastLength])) {
      agent.overrideValueAtPath({
        type: 'props',
        id,
        rendererID,
        path: ['style', lastLength, name],
        value
      });
    } else {
      agent.overrideValueAtPath({
        type: 'props',
        id,
        rendererID,
        path: ['style'],
        value: style.concat([newStyle])
      });
    }
  } else {
    agent.overrideValueAtPath({
      type: 'props',
      id,
      rendererID,
      path: ['style'],
      value: [style, newStyle]
    });
  }

  agent.emit('hideNativeHighlight');
}
// EXTERNAL MODULE: ./src/constants.js
var src_constants = __webpack_require__(38);

// CONCATENATED MODULE: ./src/backend.js







function startActivation(contentWindow) {
  const parent = contentWindow.parent;

  const onMessage = ({
    data
  }) => {
    switch (data.type) {
      case src_constants["b" /* MESSAGE_TYPE_SAVED_PREFERENCES */]:
        // This is the only message we're listening for,
        // so it's safe to cleanup after we've received it.
        contentWindow.removeEventListener('message', onMessage);
        const appendComponentStack = data.appendComponentStack,
              breakOnConsoleErrors = data.breakOnConsoleErrors,
              componentFilters = data.componentFilters;
        contentWindow.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ = appendComponentStack;
        contentWindow.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ = breakOnConsoleErrors;
        contentWindow.__REACT_DEVTOOLS_COMPONENT_FILTERS__ = componentFilters; // TRICKY
        // The backend entry point may be required in the context of an iframe or the parent window.
        // If it's required within the parent window, store the saved values on it as well,
        // since the injected renderer interface will read from window.
        // Technically we don't need to store them on the contentWindow in this case,
        // but it doesn't really hurt anything to store them there too.

        if (contentWindow !== window) {
          window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ = appendComponentStack;
          window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ = breakOnConsoleErrors;
          window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ = componentFilters;
        }

        finishActivation(contentWindow);
        break;

      default:
        break;
    }
  };

  contentWindow.addEventListener('message', onMessage); // The backend may be unable to read saved preferences directly,
  // because they are stored in localStorage within the context of the extension (on the frontend).
  // Instead it relies on the extension to pass preferences through.
  // Because we might be in a sandboxed iframe, we have to ask for them by way of postMessage().

  parent.postMessage({
    type: src_constants["a" /* MESSAGE_TYPE_GET_SAVED_PREFERENCES */]
  }, '*');
}

function finishActivation(contentWindow) {
  const parent = contentWindow.parent;
  const bridge = new src_bridge["a" /* default */]({
    listen(fn) {
      const onMessage = event => {
        fn(event.data);
      };

      contentWindow.addEventListener('message', onMessage);
      return () => {
        contentWindow.removeEventListener('message', onMessage);
      };
    },

    send(event, payload, transferable) {
      parent.postMessage({
        event,
        payload
      }, '*', transferable);
    }

  });
  const agent = new agent_Agent(bridge);
  const hook = contentWindow.__REACT_DEVTOOLS_GLOBAL_HOOK__;

  if (hook) {
    initBackend(hook, agent, contentWindow); // Setup React Native style editor if a renderer like react-native-web has injected it.

    if (hook.resolveRNStyle) {
      setupNativeStyleEditor(bridge, agent, hook.resolveRNStyle, hook.nativeStyleEditorValidAttributes);
    }
  }
}

function activate(contentWindow) {
  startActivation(contentWindow);
}
function backend_initialize(contentWindow) {
  installHook(contentWindow);
}

/***/ }),

/***/ 17:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate) {//  Import support https://stackoverflow.com/questions/13673346/supporting-both-commonjs-and-amd
(function (name, definition) {
  if (true) {
    module.exports = definition();
  } else {}
})("clipboard", function () {
  if (typeof document === 'undefined' || !document.addEventListener) {
    return null;
  }

  var clipboard = {};

  clipboard.copy = function () {
    var _intercept = false;
    var _data = null; // Map from data type (e.g. "text/html") to value.

    var _bogusSelection = false;

    function cleanup() {
      _intercept = false;
      _data = null;

      if (_bogusSelection) {
        window.getSelection().removeAllRanges();
      }

      _bogusSelection = false;
    }

    document.addEventListener("copy", function (e) {
      if (_intercept) {
        for (var key in _data) {
          e.clipboardData.setData(key, _data[key]);
        }

        e.preventDefault();
      }
    }); // Workaround for Safari: https://bugs.webkit.org/show_bug.cgi?id=156529

    function bogusSelect() {
      var sel = document.getSelection(); // If "nothing" is selected...

      if (!document.queryCommandEnabled("copy") && sel.isCollapsed) {
        // ... temporarily select the entire body.
        //
        // We select the entire body because:
        // - it's guaranteed to exist,
        // - it works (unlike, say, document.head, or phantom element that is
        //   not inserted into the DOM),
        // - it doesn't seem to flicker (due to the synchronous copy event), and
        // - it avoids modifying the DOM (can trigger mutation observers).
        //
        // Because we can't do proper feature detection (we already checked
        // document.queryCommandEnabled("copy") , which actually gives a false
        // negative for Blink when nothing is selected) and UA sniffing is not
        // reliable (a lot of UA strings contain "Safari"), this will also
        // happen for some browsers other than Safari. :-()
        var range = document.createRange();
        range.selectNodeContents(document.body);
        sel.removeAllRanges();
        sel.addRange(range);
        _bogusSelection = true;
      }
    }

    ;
    return function (data) {
      return new Promise(function (resolve, reject) {
        _intercept = true;

        if (typeof data === "string") {
          _data = {
            "text/plain": data
          };
        } else if (data instanceof Node) {
          _data = {
            "text/html": new XMLSerializer().serializeToString(data)
          };
        } else if (data instanceof Object) {
          _data = data;
        } else {
          reject("Invalid data type. Must be string, DOM node, or an object mapping MIME types to strings.");
        }

        function triggerCopy(tryBogusSelect) {
          try {
            if (document.execCommand("copy")) {
              // document.execCommand is synchronous: http://www.w3.org/TR/2015/WD-clipboard-apis-20150421/#integration-with-rich-text-editing-apis
              // So we can call resolve() back here.
              cleanup();
              resolve();
            } else {
              if (!tryBogusSelect) {
                bogusSelect();
                triggerCopy(true);
              } else {
                cleanup();
                throw new Error("Unable to copy. Perhaps it's not available in your browser?");
              }
            }
          } catch (e) {
            cleanup();
            reject(e);
          }
        }

        triggerCopy(false);
      });
    };
  }();

  clipboard.paste = function () {
    var _intercept = false;

    var _resolve;

    var _dataType;

    document.addEventListener("paste", function (e) {
      if (_intercept) {
        _intercept = false;
        e.preventDefault();
        var resolve = _resolve;
        _resolve = null;
        resolve(e.clipboardData.getData(_dataType));
      }
    });
    return function (dataType) {
      return new Promise(function (resolve, reject) {
        _intercept = true;
        _resolve = resolve;
        _dataType = dataType || "text/plain";

        try {
          if (!document.execCommand("paste")) {
            _intercept = false;
            reject(new Error("Unable to paste. Pasting only works in Internet Explorer at the moment."));
          }
        } catch (e) {
          _intercept = false;
          reject(new Error(e));
        }
      });
    };
  }(); // Handle IE behaviour.


  if (typeof ClipboardEvent === "undefined" && typeof window.clipboardData !== "undefined" && typeof window.clipboardData.setData !== "undefined") {
    /*! promise-polyfill 2.0.1 */
    (function (a) {
      function b(a, b) {
        return function () {
          a.apply(b, arguments);
        };
      }

      function c(a) {
        if ("object" != typeof this) throw new TypeError("Promises must be constructed via new");
        if ("function" != typeof a) throw new TypeError("not a function");
        this._state = null, this._value = null, this._deferreds = [], i(a, b(e, this), b(f, this));
      }

      function d(a) {
        var b = this;
        return null === this._state ? void this._deferreds.push(a) : void j(function () {
          var c = b._state ? a.onFulfilled : a.onRejected;
          if (null === c) return void (b._state ? a.resolve : a.reject)(b._value);
          var d;

          try {
            d = c(b._value);
          } catch (e) {
            return void a.reject(e);
          }

          a.resolve(d);
        });
      }

      function e(a) {
        try {
          if (a === this) throw new TypeError("A promise cannot be resolved with itself.");

          if (a && ("object" == typeof a || "function" == typeof a)) {
            var c = a.then;
            if ("function" == typeof c) return void i(b(c, a), b(e, this), b(f, this));
          }

          this._state = !0, this._value = a, g.call(this);
        } catch (d) {
          f.call(this, d);
        }
      }

      function f(a) {
        this._state = !1, this._value = a, g.call(this);
      }

      function g() {
        for (var a = 0, b = this._deferreds.length; b > a; a++) d.call(this, this._deferreds[a]);

        this._deferreds = null;
      }

      function h(a, b, c, d) {
        this.onFulfilled = "function" == typeof a ? a : null, this.onRejected = "function" == typeof b ? b : null, this.resolve = c, this.reject = d;
      }

      function i(a, b, c) {
        var d = !1;

        try {
          a(function (a) {
            d || (d = !0, b(a));
          }, function (a) {
            d || (d = !0, c(a));
          });
        } catch (e) {
          if (d) return;
          d = !0, c(e);
        }
      }

      var j = c.immediateFn || "function" == typeof setImmediate && setImmediate || function (a) {
        setTimeout(a, 1);
      },
          k = Array.isArray || function (a) {
        return "[object Array]" === Object.prototype.toString.call(a);
      };

      c.prototype["catch"] = function (a) {
        return this.then(null, a);
      }, c.prototype.then = function (a, b) {
        var e = this;
        return new c(function (c, f) {
          d.call(e, new h(a, b, c, f));
        });
      }, c.all = function () {
        var a = Array.prototype.slice.call(1 === arguments.length && k(arguments[0]) ? arguments[0] : arguments);
        return new c(function (b, c) {
          function d(f, g) {
            try {
              if (g && ("object" == typeof g || "function" == typeof g)) {
                var h = g.then;
                if ("function" == typeof h) return void h.call(g, function (a) {
                  d(f, a);
                }, c);
              }

              a[f] = g, 0 === --e && b(a);
            } catch (i) {
              c(i);
            }
          }

          if (0 === a.length) return b([]);

          for (var e = a.length, f = 0; f < a.length; f++) d(f, a[f]);
        });
      }, c.resolve = function (a) {
        return a && "object" == typeof a && a.constructor === c ? a : new c(function (b) {
          b(a);
        });
      }, c.reject = function (a) {
        return new c(function (b, c) {
          c(a);
        });
      }, c.race = function (a) {
        return new c(function (b, c) {
          for (var d = 0, e = a.length; e > d; d++) a[d].then(b, c);
        });
      },   true && module.exports ? module.exports = c : a.Promise || (a.Promise = c);
    })(this);

    clipboard.copy = function (data) {
      return new Promise(function (resolve, reject) {
        // IE supports string and URL types: https://msdn.microsoft.com/en-us/library/ms536744(v=vs.85).aspx
        // We only support the string type for now.
        if (typeof data !== "string" && !("text/plain" in data)) {
          throw new Error("You must provide a text/plain type.");
        }

        var strData = typeof data === "string" ? data : data["text/plain"];
        var copySucceeded = window.clipboardData.setData("Text", strData);

        if (copySucceeded) {
          resolve();
        } else {
          reject(new Error("Copying was rejected."));
        }
      });
    };

    clipboard.paste = function () {
      return new Promise(function (resolve, reject) {
        var strData = window.clipboardData.getData("Text");

        if (strData) {
          resolve(strData);
        } else {
          // The user rejected the paste request.
          reject(new Error("Pasting was rejected."));
        }
      });
    };
  }

  return clipboard;
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(67).setImmediate))

/***/ }),

/***/ 2:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export alphaSortKeys */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getAllEnumerableKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return getDisplayName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return getUID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return utfDecodeString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return utfEncodeString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return printOperationsArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getDefaultComponentFilters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return getSavedComponentFilters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return saveComponentFilters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getAppendComponentStack; });
/* unused harmony export setAppendComponentStack */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getBreakOnConsoleErrors; });
/* unused harmony export setBreakOnConsoleErrors */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return separateDisplayNameAndHOCs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return shallowDiffers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return getInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return deletePathInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return renamePathInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return setInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return getDataType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return getDisplayNameForReactElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return formatDataForPreview; });
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_is__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/* harmony import */ var react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1);
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7);
/* harmony import */ var _hydration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */










const cachedDisplayNames = new WeakMap(); // On large trees, encoding takes significant time.
// Try to reuse the already encoded strings.

const encodedStringCache = new lru_cache__WEBPACK_IMPORTED_MODULE_0___default.a({
  max: 1000
});
function alphaSortKeys(a, b) {
  if (a.toString() > b.toString()) {
    return 1;
  } else if (b.toString() > a.toString()) {
    return -1;
  } else {
    return 0;
  }
}
function getAllEnumerableKeys(obj) {
  const keys = [];
  let current = obj;

  while (current != null) {
    const currentKeys = [...Object.keys(current), ...Object.getOwnPropertySymbols(current)];
    const descriptors = Object.getOwnPropertyDescriptors(current);
    currentKeys.forEach(key => {
      // $FlowFixMe: key can be a Symbol https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor
      if (descriptors[key].enumerable) {
        keys.push(key);
      }
    });
    current = Object.getPrototypeOf(current);
  }

  return keys;
}
function getDisplayName(type, fallbackName = 'Anonymous') {
  const nameFromCache = cachedDisplayNames.get(type);

  if (nameFromCache != null) {
    return nameFromCache;
  }

  let displayName = fallbackName; // The displayName property is not guaranteed to be a string.
  // It's only safe to use for our purposes if it's a string.
  // github.com/facebook/react-devtools/issues/803

  if (typeof type.displayName === 'string') {
    displayName = type.displayName;
  } else if (typeof type.name === 'string' && type.name !== '') {
    displayName = type.name;
  }

  cachedDisplayNames.set(type, displayName);
  return displayName;
}
let uidCounter = 0;
function getUID() {
  return ++uidCounter;
}
function utfDecodeString(array) {
  return String.fromCodePoint(...array);
}
function utfEncodeString(string) {
  const cached = encodedStringCache.get(string);

  if (cached !== undefined) {
    return cached;
  }

  const encoded = new Array(string.length);

  for (let i = 0; i < string.length; i++) {
    encoded[i] = string.codePointAt(i);
  }

  encodedStringCache.set(string, encoded);
  return encoded;
}
function printOperationsArray(operations) {
  // The first two values are always rendererID and rootID
  const rendererID = operations[0];
  const rootID = operations[1];
  const logs = [`operations for renderer:${rendererID} and root:${rootID}`];
  let i = 2; // Reassemble the string table.

  const stringTable = [null // ID = 0 corresponds to the null string.
  ];
  const stringTableSize = operations[i++];
  const stringTableEnd = i + stringTableSize;

  while (i < stringTableEnd) {
    const nextLength = operations[i++];
    const nextString = utfDecodeString(operations.slice(i, i + nextLength));
    stringTable.push(nextString);
    i += nextLength;
  }

  while (i < operations.length) {
    const operation = operations[i];

    switch (operation) {
      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_ADD */ "l"]:
        {
          const id = operations[i + 1];
          const type = operations[i + 2];
          i += 3;

          if (type === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeRoot */ "m"]) {
            logs.push(`Add new root node ${id}`);
            i++; // supportsProfiling

            i++; // hasOwnerMetadata
          } else {
            const parentID = operations[i];
            i++;
            i++; // ownerID

            const displayNameStringID = operations[i];
            const displayName = stringTable[displayNameStringID];
            i++;
            i++; // key

            logs.push(`Add node ${id} (${displayName || 'null'}) as child of ${parentID}`);
          }

          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_REMOVE */ "m"]:
        {
          const removeLength = operations[i + 1];
          i += 2;

          for (let removeIndex = 0; removeIndex < removeLength; removeIndex++) {
            const id = operations[i];
            i += 1;
            logs.push(`Remove node ${id}`);
          }

          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_REORDER_CHILDREN */ "n"]:
        {
          const id = operations[i + 1];
          const numChildren = operations[i + 2];
          i += 3;
          const children = operations.slice(i, i + numChildren);
          i += numChildren;
          logs.push(`Re-order node ${id} children ${children.join(',')}`);
          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_UPDATE_TREE_BASE_DURATION */ "o"]:
        // Base duration updates are only sent while profiling is in progress.
        // We can ignore them at this point.
        // The profiler UI uses them lazily in order to generate the tree.
        i += 3;
        break;

      default:
        throw Error(`Unsupported Bridge operation ${operation}`);
    }
  }

  console.log(logs.join('\n  '));
}
function getDefaultComponentFilters() {
  return [{
    type: react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ComponentFilterElementType */ "b"],
    value: react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeHostComponent */ "i"],
    isEnabled: true
  }];
}
function getSavedComponentFilters() {
  try {
    const raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_FILTER_PREFERENCES_KEY */ "d"]);

    if (raw != null) {
      return JSON.parse(raw);
    }
  } catch (error) {}

  return getDefaultComponentFilters();
}
function saveComponentFilters(componentFilters) {
  Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageSetItem */ "b"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_FILTER_PREFERENCES_KEY */ "d"], JSON.stringify(componentFilters));
}
function getAppendComponentStack() {
  try {
    const raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY */ "f"]);

    if (raw != null) {
      return JSON.parse(raw);
    }
  } catch (error) {}

  return true;
}
function setAppendComponentStack(value) {
  Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageSetItem */ "b"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY */ "f"], JSON.stringify(value));
}
function getBreakOnConsoleErrors() {
  try {
    const raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS */ "e"]);

    if (raw != null) {
      return JSON.parse(raw);
    }
  } catch (error) {}

  return false;
}
function setBreakOnConsoleErrors(value) {
  Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageSetItem */ "b"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS */ "e"], JSON.stringify(value));
}
function separateDisplayNameAndHOCs(displayName, type) {
  if (displayName === null) {
    return [null, null];
  }

  let hocDisplayNames = null;

  switch (type) {
    case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeClass */ "e"]:
    case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeForwardRef */ "g"]:
    case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeFunction */ "h"]:
    case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeMemo */ "j"]:
      if (displayName.indexOf('(') >= 0) {
        const matches = displayName.match(/[^()]+/g);

        if (matches != null) {
          displayName = matches.pop();
          hocDisplayNames = matches;
        }
      }

      break;

    default:
      break;
  }

  if (type === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeMemo */ "j"]) {
    if (hocDisplayNames === null) {
      hocDisplayNames = ['Memo'];
    } else {
      hocDisplayNames.unshift('Memo');
    }
  } else if (type === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeForwardRef */ "g"]) {
    if (hocDisplayNames === null) {
      hocDisplayNames = ['ForwardRef'];
    } else {
      hocDisplayNames.unshift('ForwardRef');
    }
  }

  return [displayName, hocDisplayNames];
} // Pulled from react-compat
// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349

function shallowDiffers(prev, next) {
  for (const attribute in prev) {
    if (!(attribute in next)) {
      return true;
    }
  }

  for (const attribute in next) {
    if (prev[attribute] !== next[attribute]) {
      return true;
    }
  }

  return false;
}
function getInObject(object, path) {
  return path.reduce((reduced, attr) => {
    if (reduced) {
      if (hasOwnProperty.call(reduced, attr)) {
        return reduced[attr];
      }

      if (typeof reduced[Symbol.iterator] === 'function') {
        // Convert iterable to array and return array[index]
        //
        // TRICKY
        // Don't use [...spread] syntax for this purpose.
        // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
        // Other types (e.g. typed arrays, Sets) will not spread correctly.
        return Array.from(reduced)[attr];
      }
    }

    return null;
  }, object);
}
function deletePathInObject(object, path) {
  const length = path.length;
  const last = path[length - 1];

  if (object != null) {
    const parent = getInObject(object, path.slice(0, length - 1));

    if (parent) {
      if (Array.isArray(parent)) {
        parent.splice(last, 1);
      } else {
        delete parent[last];
      }
    }
  }
}
function renamePathInObject(object, oldPath, newPath) {
  const length = oldPath.length;

  if (object != null) {
    const parent = getInObject(object, oldPath.slice(0, length - 1));

    if (parent) {
      const lastOld = oldPath[length - 1];
      const lastNew = newPath[length - 1];
      parent[lastNew] = parent[lastOld];

      if (Array.isArray(parent)) {
        parent.splice(lastOld, 1);
      } else {
        delete parent[lastOld];
      }
    }
  }
}
function setInObject(object, path, value) {
  const length = path.length;
  const last = path[length - 1];

  if (object != null) {
    const parent = getInObject(object, path.slice(0, length - 1));

    if (parent) {
      parent[last] = value;
    }
  }
}

/**
 * Get a enhanced/artificial type string based on the object instance
 */
function getDataType(data) {
  if (data === null) {
    return 'null';
  } else if (data === undefined) {
    return 'undefined';
  }

  if (Object(react_is__WEBPACK_IMPORTED_MODULE_1__["isElement"])(data)) {
    return 'react_element';
  }

  if (typeof HTMLElement !== 'undefined' && data instanceof HTMLElement) {
    return 'html_element';
  }

  const type = typeof data;

  switch (type) {
    case 'bigint':
      return 'bigint';

    case 'boolean':
      return 'boolean';

    case 'function':
      return 'function';

    case 'number':
      if (Number.isNaN(data)) {
        return 'nan';
      } else if (!Number.isFinite(data)) {
        return 'infinity';
      } else {
        return 'number';
      }

    case 'object':
      if (Array.isArray(data)) {
        return 'array';
      } else if (ArrayBuffer.isView(data)) {
        return hasOwnProperty.call(data.constructor, 'BYTES_PER_ELEMENT') ? 'typed_array' : 'data_view';
      } else if (data.constructor && data.constructor.name === 'ArrayBuffer') {
        // HACK This ArrayBuffer check is gross; is there a better way?
        // We could try to create a new DataView with the value.
        // If it doesn't error, we know it's an ArrayBuffer,
        // but this seems kind of awkward and expensive.
        return 'array_buffer';
      } else if (typeof data[Symbol.iterator] === 'function') {
        return data[Symbol.iterator]() === data ? 'opaque_iterator' : 'iterator';
      } else if (data.constructor && data.constructor.name === 'RegExp') {
        return 'regexp';
      } else {
        const toStringValue = Object.prototype.toString.call(data);

        if (toStringValue === '[object Date]') {
          return 'date';
        } else if (toStringValue === '[object HTMLAllCollection]') {
          return 'html_all_collection';
        }
      }

      return 'object';

    case 'string':
      return 'string';

    case 'symbol':
      return 'symbol';

    case 'undefined':
      if (Object.prototype.toString.call(data) === '[object HTMLAllCollection]') {
        return 'html_all_collection';
      }

      return 'undefined';

    default:
      return 'unknown';
  }
}
function getDisplayNameForReactElement(element) {
  const elementType = Object(react_is__WEBPACK_IMPORTED_MODULE_1__["typeOf"])(element);

  switch (elementType) {
    case react_is__WEBPACK_IMPORTED_MODULE_1__["ContextConsumer"]:
      return 'ContextConsumer';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["ContextProvider"]:
      return 'ContextProvider';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["ForwardRef"]:
      return 'ForwardRef';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Fragment"]:
      return 'Fragment';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Lazy"]:
      return 'Lazy';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Memo"]:
      return 'Memo';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Portal"]:
      return 'Portal';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Profiler"]:
      return 'Profiler';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["StrictMode"]:
      return 'StrictMode';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Suspense"]:
      return 'Suspense';

    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_2__[/* REACT_SUSPENSE_LIST_TYPE */ "b"]:
      return 'SuspenseList';

    default:
      const type = element.type;

      if (typeof type === 'string') {
        return type;
      } else if (typeof type === 'function') {
        return getDisplayName(type, 'Anonymous');
      } else if (type != null) {
        return 'NotImplementedInDevtools';
      } else {
        return 'Element';
      }

  }
}
const MAX_PREVIEW_STRING_LENGTH = 50;

function truncateForDisplay(string, length = MAX_PREVIEW_STRING_LENGTH) {
  if (string.length > length) {
    return string.substr(0, length) + 'â€¦';
  } else {
    return string;
  }
} // Attempts to mimic Chrome's inline preview for values.
// For example, the following value...
//   {
//      foo: 123,
//      bar: "abc",
//      baz: [true, false],
//      qux: { ab: 1, cd: 2 }
//   };
//
// Would show a preview of...
//   {foo: 123, bar: "abc", baz: Array(2), qux: {â€¦}}
//
// And the following value...
//   [
//     123,
//     "abc",
//     [true, false],
//     { foo: 123, bar: "abc" }
//   ];
//
// Would show a preview of...
//   [123, "abc", Array(2), {â€¦}]


function formatDataForPreview(data, showFormattedValue) {
  if (data != null && hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "d"].type)) {
    return showFormattedValue ? data[_hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "d"].preview_long] : data[_hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "d"].preview_short];
  }

  const type = getDataType(data);

  switch (type) {
    case 'html_element':
      return `<${truncateForDisplay(data.tagName.toLowerCase())} />`;

    case 'function':
      return truncateForDisplay(`Æ’ ${typeof data.name === 'function' ? '' : data.name}() {}`);

    case 'string':
      return `"${data}"`;

    case 'bigint':
      return truncateForDisplay(data.toString() + 'n');

    case 'regexp':
      return truncateForDisplay(data.toString());

    case 'symbol':
      return truncateForDisplay(data.toString());

    case 'react_element':
      return `<${truncateForDisplay(getDisplayNameForReactElement(data) || 'Unknown')} />`;

    case 'array_buffer':
      return `ArrayBuffer(${data.byteLength})`;

    case 'data_view':
      return `DataView(${data.buffer.byteLength})`;

    case 'array':
      if (showFormattedValue) {
        let formatted = '';

        for (let i = 0; i < data.length; i++) {
          if (i > 0) {
            formatted += ', ';
          }

          formatted += formatDataForPreview(data[i], false);

          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return `[${truncateForDisplay(formatted)}]`;
      } else {
        const length = hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "d"].size) ? data[_hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "d"].size] : data.length;
        return `Array(${length})`;
      }

    case 'typed_array':
      const shortName = `${data.constructor.name}(${data.length})`;

      if (showFormattedValue) {
        let formatted = '';

        for (let i = 0; i < data.length; i++) {
          if (i > 0) {
            formatted += ', ';
          }

          formatted += data[i];

          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return `${shortName} [${truncateForDisplay(formatted)}]`;
      } else {
        return shortName;
      }

    case 'iterator':
      const name = data.constructor.name;

      if (showFormattedValue) {
        // TRICKY
        // Don't use [...spread] syntax for this purpose.
        // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
        // Other types (e.g. typed arrays, Sets) will not spread correctly.
        const array = Array.from(data);
        let formatted = '';

        for (let i = 0; i < array.length; i++) {
          const entryOrEntries = array[i];

          if (i > 0) {
            formatted += ', ';
          } // TRICKY
          // Browsers display Maps and Sets differently.
          // To mimic their behavior, detect if we've been given an entries tuple.
          //   Map(2) {"abc" => 123, "def" => 123}
          //   Set(2) {"abc", 123}


          if (Array.isArray(entryOrEntries)) {
            const key = formatDataForPreview(entryOrEntries[0], true);
            const value = formatDataForPreview(entryOrEntries[1], false);
            formatted += `${key} => ${value}`;
          } else {
            formatted += formatDataForPreview(entryOrEntries, false);
          }

          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return `${name}(${data.size}) {${truncateForDisplay(formatted)}}`;
      } else {
        return `${name}(${data.size})`;
      }

    case 'opaque_iterator':
      {
        return data[Symbol.toStringTag];
      }

    case 'date':
      return data.toString();

    case 'object':
      if (showFormattedValue) {
        const keys = getAllEnumerableKeys(data).sort(alphaSortKeys);
        let formatted = '';

        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];

          if (i > 0) {
            formatted += ', ';
          }

          formatted += `${key.toString()}: ${formatDataForPreview(data[key], false)}`;

          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return `{${truncateForDisplay(formatted)}}`;
      } else {
        return '{â€¦}';
      }

    case 'boolean':
    case 'number':
    case 'infinity':
    case 'nan':
    case 'null':
    case 'undefined':
      return data;

    default:
      try {
        return truncateForDisplay('' + data);
      } catch (error) {
        return 'unserializable';
      }

  }
}

/***/ }),

/***/ 25:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EventEmitter; });
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class EventEmitter {
  constructor() {
    _defineProperty(this, "listenersMap", new Map());
  }

  addListener(event, listener) {
    const listeners = this.listenersMap.get(event);

    if (listeners === undefined) {
      this.listenersMap.set(event, [listener]);
    } else {
      const index = listeners.indexOf(listener);

      if (index < 0) {
        listeners.push(listener);
      }
    }
  }

  emit(event, ...args) {
    const listeners = this.listenersMap.get(event);

    if (listeners !== undefined) {
      if (listeners.length === 1) {
        // No need to clone or try/catch
        const listener = listeners[0];
        listener.apply(null, args);
      } else {
        let didThrow = false;
        let caughtError = null;
        const clonedListeners = Array.from(listeners);

        for (let i = 0; i < clonedListeners.length; i++) {
          const listener = clonedListeners[i];

          try {
            listener.apply(null, args);
          } catch (error) {
            if (caughtError === null) {
              didThrow = true;
              caughtError = error;
            }
          }
        }

        if (didThrow) {
          throw caughtError;
        }
      }
    }
  }

  removeAllListeners() {
    this.listenersMap.clear();
  }

  removeListener(event, listener) {
    const listeners = this.listenersMap.get(event);

    if (listeners !== undefined) {
      const index = listeners.indexOf(listener);

      if (index >= 0) {
        listeners.splice(index, 1);
      }
    }
  }

}

/***/ }),

/***/ 28:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var simpleIsEqual = function simpleIsEqual(a, b) {
  return a === b;
};

/* harmony default export */ __webpack_exports__["a"] = (function (resultFn) {
  var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : simpleIsEqual;
  var lastThis = void 0;
  var lastArgs = [];
  var lastResult = void 0;
  var calledOnce = false;

  var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) {
    return isEqual(newArg, lastArgs[index]);
  };

  var result = function result() {
    for (var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++) {
      newArgs[_key] = arguments[_key];
    }

    if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {
      return lastResult;
    }

    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    lastResult = resultFn.apply(this, newArgs);
    return lastResult;
  };

  return result;
});

/***/ }),

/***/ 3:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return __DEBUG__; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return TREE_OPERATION_ADD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return TREE_OPERATION_REMOVE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return TREE_OPERATION_REORDER_CHILDREN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return TREE_OPERATION_UPDATE_TREE_BASE_DURATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return LOCAL_STORAGE_FILTER_PREFERENCES_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return SESSION_STORAGE_LAST_SELECTION_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return SESSION_STORAGE_RELOAD_AND_PROFILE_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return PROFILER_EXPORT_VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CHANGE_LOG_URL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return UNSUPPORTED_VERSION_URL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return COMFORTABLE_LINE_HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return COMPACT_LINE_HEIGHT; });
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// Flip this flag to true to enable verbose console debug logging.
const __DEBUG__ = false;
const TREE_OPERATION_ADD = 1;
const TREE_OPERATION_REMOVE = 2;
const TREE_OPERATION_REORDER_CHILDREN = 3;
const TREE_OPERATION_UPDATE_TREE_BASE_DURATION = 4;
const LOCAL_STORAGE_FILTER_PREFERENCES_KEY = 'React::DevTools::componentFilters';
const SESSION_STORAGE_LAST_SELECTION_KEY = 'React::DevTools::lastSelection';
const SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = 'React::DevTools::recordChangeDescriptions';
const SESSION_STORAGE_RELOAD_AND_PROFILE_KEY = 'React::DevTools::reloadAndProfile';
const LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS = 'React::DevTools::breakOnConsoleErrors';
const LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY = 'React::DevTools::appendComponentStack';
const LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY = 'React::DevTools::traceUpdatesEnabled';
const PROFILER_EXPORT_VERSION = 4;
const CHANGE_LOG_URL = 'https://github.com/facebook/react/blob/master/packages/react-devtools/CHANGELOG.md';
const UNSUPPORTED_VERSION_URL = 'https://reactjs.org/blog/2019/08/15/new-react-devtools.html#how-do-i-get-the-old-version-back'; // HACK
//
// Extracting during build time avoids a temporarily invalid state for the inline target.
// Sometimes the inline target is rendered before root styles are applied,
// which would result in e.g. NaN itemSize being passed to react-window list.
//

let COMFORTABLE_LINE_HEIGHT;
let COMPACT_LINE_HEIGHT;

try {
  // $FlowFixMe
  const rawStyleString = __webpack_require__(64).default;

  const extractVar = varName => {
    const regExp = new RegExp(`${varName}: ([0-9]+)`);
    const match = rawStyleString.match(regExp);
    return parseInt(match[1], 10);
  };

  COMFORTABLE_LINE_HEIGHT = extractVar('comfortable-line-height-data');
  COMPACT_LINE_HEIGHT = extractVar('compact-line-height-data');
} catch (error) {
  // We can't use the Webpack loader syntax in the context of Jest,
  // so tests need some reasonably meaningful fallback value.
  COMFORTABLE_LINE_HEIGHT = 15;
  COMPACT_LINE_HEIGHT = 10;
}



/***/ }),

/***/ 30:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/***/ }),

/***/ 34:
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ 36:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';
/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */

var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */

var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
/** Used for built-in method references. */

var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */

var now = function now() {
  return root.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */


function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  wait = toNumber(wait) || 0;

  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;
    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */


function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */


function isObjectLike(value) {
  return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */


function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */


function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = throttle;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34)))

/***/ }),

/***/ 37:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export REACT_ELEMENT_TYPE */
/* unused harmony export REACT_PORTAL_TYPE */
/* unused harmony export REACT_FRAGMENT_TYPE */
/* unused harmony export REACT_STRICT_MODE_TYPE */
/* unused harmony export REACT_PROFILER_TYPE */
/* unused harmony export REACT_PROVIDER_TYPE */
/* unused harmony export REACT_CONTEXT_TYPE */
/* unused harmony export REACT_FORWARD_REF_TYPE */
/* unused harmony export REACT_SUSPENSE_TYPE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return REACT_SUSPENSE_LIST_TYPE; });
/* unused harmony export REACT_MEMO_TYPE */
/* unused harmony export REACT_LAZY_TYPE */
/* unused harmony export REACT_FUNDAMENTAL_TYPE */
/* unused harmony export REACT_SCOPE_TYPE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return REACT_OPAQUE_ID_TYPE; });
/* unused harmony export REACT_DEBUG_TRACING_MODE_TYPE */
/* unused harmony export REACT_OFFSCREEN_TYPE */
/* unused harmony export REACT_LEGACY_HIDDEN_TYPE */
/* unused harmony export getIteratorFn */
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
let REACT_ELEMENT_TYPE = 0xeac7;
let REACT_PORTAL_TYPE = 0xeaca;
let REACT_FRAGMENT_TYPE = 0xeacb;
let REACT_STRICT_MODE_TYPE = 0xeacc;
let REACT_PROFILER_TYPE = 0xead2;
let REACT_PROVIDER_TYPE = 0xeacd;
let REACT_CONTEXT_TYPE = 0xeace;
let REACT_FORWARD_REF_TYPE = 0xead0;
let REACT_SUSPENSE_TYPE = 0xead1;
let REACT_SUSPENSE_LIST_TYPE = 0xead8;
let REACT_MEMO_TYPE = 0xead3;
let REACT_LAZY_TYPE = 0xead4;
let REACT_FUNDAMENTAL_TYPE = 0xead5;
let REACT_SCOPE_TYPE = 0xead7;
let REACT_OPAQUE_ID_TYPE = 0xeae0;
let REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
let REACT_OFFSCREEN_TYPE = 0xeae2;
let REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  const symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

const MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
const FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  const maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/***/ }),

/***/ 38:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MESSAGE_TYPE_GET_SAVED_PREFERENCES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return MESSAGE_TYPE_SAVED_PREFERENCES; });
const MESSAGE_TYPE_GET_SAVED_PREFERENCES = 'React::DevTools::getSavedPreferences';
const MESSAGE_TYPE_SAVED_PREFERENCES = 'React::DevTools::savedPreferences';

/***/ }),

/***/ 46:
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ 47:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // A linked list to keep track of recently-used-ness

const Yallist = __webpack_require__(65);

const MAX = Symbol('max');
const LENGTH = Symbol('length');
const LENGTH_CALCULATOR = Symbol('lengthCalculator');
const ALLOW_STALE = Symbol('allowStale');
const MAX_AGE = Symbol('maxAge');
const DISPOSE = Symbol('dispose');
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
const LRU_LIST = Symbol('lruList');
const CACHE = Symbol('cache');
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

const naiveLength = () => 1; // lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.


class LRUCache {
  constructor(options) {
    if (typeof options === 'number') options = {
      max: options
    };
    if (!options) options = {};
    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number'); // Kind of weird to have a default max of Infinity, but oh well.

    const max = this[MAX] = options.max || Infinity;
    const lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  } // resize the cache when the max changes.


  set max(mL) {
    if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
    this[MAX] = mL || Infinity;
    trim(this);
  }

  get max() {
    return this[MAX];
  }

  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }

  get allowStale() {
    return this[ALLOW_STALE];
  }

  set maxAge(mA) {
    if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
    this[MAX_AGE] = mA;
    trim(this);
  }

  get maxAge() {
    return this[MAX_AGE];
  } // resize the cache when the lengthCalculator changes.


  set lengthCalculator(lC) {
    if (typeof lC !== 'function') lC = naiveLength;

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }

    trim(this);
  }

  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }

  get length() {
    return this[LENGTH];
  }

  get itemCount() {
    return this[LRU_LIST].length;
  }

  rforEach(fn, thisp) {
    thisp = thisp || this;

    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }

  forEach(fn, thisp) {
    thisp = thisp || this;

    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }

  keys() {
    return this[LRU_LIST].toArray().map(k => k.key);
  }

  values() {
    return this[LRU_LIST].toArray().map(k => k.value);
  }

  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));
    }

    this[CACHE] = new Map(); // hash of items by key

    this[LRU_LIST] = new Yallist(); // list of items in order of use recency

    this[LENGTH] = 0; // length of items in the list
  }

  dump() {
    return this[LRU_LIST].map(hit => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter(h => h);
  }

  dumpLru() {
    return this[LRU_LIST];
  }

  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
    const now = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }

      const node = this[CACHE].get(key);
      const item = node.value; // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking

      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
      }

      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }

    const hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.

    if (hit.length > this[MAX]) {
      if (this[DISPOSE]) this[DISPOSE](key, value);
      return false;
    }

    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }

  has(key) {
    if (!this[CACHE].has(key)) return false;
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }

  get(key) {
    return get(this, key, true);
  }

  peek(key) {
    return get(this, key, false);
  }

  pop() {
    const node = this[LRU_LIST].tail;
    if (!node) return null;
    del(this, node);
    return node.value;
  }

  del(key) {
    del(this, this[CACHE].get(key));
  }

  load(arr) {
    // reset the cache
    this.reset();
    const now = Date.now(); // A previous serialized cache has the most recent items first

    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0) // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v);else {
        const maxAge = expiresAt - now; // dont add already expired items

        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }

  prune() {
    this[CACHE].forEach((value, key) => get(this, key, false));
  }

}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key);

  if (node) {
    const hit = node.value;

    if (isStale(self, hit)) {
      del(self, node);
      if (!self[ALLOW_STALE]) return undefined;
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
        self[LRU_LIST].unshiftNode(node);
      }
    }

    return hit.value;
  }
};

const isStale = (self, hit) => {
  if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
  const diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev;
      del(self, walker);
      walker = prev;
    }
  }
};

const del = (self, node) => {
  if (node) {
    const hit = node.value;
    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
    self[LENGTH] -= hit.length;
    self[CACHE].delete(hit.key);
    self[LRU_LIST].removeNode(node);
  }
};

class Entry {
  constructor(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }

}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value;

  if (isStale(self, hit)) {
    del(self, node);
    if (!self[ALLOW_STALE]) hit = undefined;
  }

  if (hit) fn.call(thisp, hit.value, hit.key, self);
};

module.exports = LRUCache;

/***/ }),

/***/ 48:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

const BATCH_DURATION = 100;

class Bridge extends _events__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] {
  constructor(wall) {
    super();

    _defineProperty(this, "_isShutdown", false);

    _defineProperty(this, "_messageQueue", []);

    _defineProperty(this, "_timeoutID", null);

    _defineProperty(this, "_wallUnlisten", null);

    _defineProperty(this, "_flush", () => {
      // This method is used after the bridge is marked as destroyed in shutdown sequence,
      // so we do not bail out if the bridge marked as destroyed.
      // It is a private method that the bridge ensures is only called at the right times.
      if (this._timeoutID !== null) {
        clearTimeout(this._timeoutID);
        this._timeoutID = null;
      }

      if (this._messageQueue.length) {
        for (let i = 0; i < this._messageQueue.length; i += 2) {
          this._wall.send(this._messageQueue[i], ...this._messageQueue[i + 1]);
        }

        this._messageQueue.length = 0; // Check again for queued messages in BATCH_DURATION ms. This will keep
        // flushing in a loop as long as messages continue to be added. Once no
        // more are, the timer expires.

        this._timeoutID = setTimeout(this._flush, BATCH_DURATION);
      }
    });

    _defineProperty(this, "overrideValueAtPath", ({
      id,
      path,
      rendererID,
      type,
      value
    }) => {
      switch (type) {
        case 'context':
          this.send('overrideContext', {
            id,
            path,
            rendererID,
            wasForwarded: true,
            value
          });
          break;

        case 'hooks':
          this.send('overrideHookState', {
            id,
            path,
            rendererID,
            wasForwarded: true,
            value
          });
          break;

        case 'props':
          this.send('overrideProps', {
            id,
            path,
            rendererID,
            wasForwarded: true,
            value
          });
          break;

        case 'state':
          this.send('overrideState', {
            id,
            path,
            rendererID,
            wasForwarded: true,
            value
          });
          break;
      }
    });

    this._wall = wall;
    this._wallUnlisten = wall.listen(message => {
      this.emit(message.event, message.payload);
    }) || null; // Temporarily support older standalone front-ends sending commands to newer embedded backends.
    // We do this because React Native embeds the React DevTools backend,
    // but cannot control which version of the frontend users use.

    this.addListener('overrideValueAtPath', this.overrideValueAtPath);
  } // Listening directly to the wall isn't advised.
  // It can be used to listen for legacy (v3) messages (since they use a different format).


  get wall() {
    return this._wall;
  }

  send(event, ...payload) {
    if (this._isShutdown) {
      console.warn(`Cannot send message "${event}" through a Bridge that has been shutdown.`);
      return;
    } // When we receive a message:
    // - we add it to our queue of messages to be sent
    // - if there hasn't been a message recently, we set a timer for 0 ms in
    //   the future, allowing all messages created in the same tick to be sent
    //   together
    // - if there *has* been a message flushed in the last BATCH_DURATION ms
    //   (or we're waiting for our setTimeout-0 to fire), then _timeoutID will
    //   be set, and we'll simply add to the queue and wait for that


    this._messageQueue.push(event, payload);

    if (!this._timeoutID) {
      this._timeoutID = setTimeout(this._flush, 0);
    }
  }

  shutdown() {
    if (this._isShutdown) {
      console.warn('Bridge was already shutdown.');
      return;
    } // Queue the shutdown outgoing message for subscribers.


    this.send('shutdown'); // Mark this bridge as destroyed, i.e. disable its public API.

    this._isShutdown = true; // Disable the API inherited from EventEmitter that can add more listeners and send more messages.
    // $FlowFixMe This property is not writable.

    this.addListener = function () {}; // $FlowFixMe This property is not writable.


    this.emit = function () {}; // NOTE: There's also EventEmitter API like `on` and `prependListener` that we didn't add to our Flow type of EventEmitter.
    // Unsubscribe this bridge incoming message listeners to be sure, and so they don't have to do that.


    this.removeAllListeners(); // Stop accepting and emitting incoming messages from the wall.

    const wallUnlisten = this._wallUnlisten;

    if (wallUnlisten) {
      wallUnlisten();
    } // Synchronously flush all queued outgoing messages.
    // At this step the subscribers' code may run in this call stack.


    do {
      this._flush();
    } while (this._messageQueue.length); // Make sure once again that there is no dangling timer.


    if (this._timeoutID !== null) {
      clearTimeout(this._timeoutID);
      this._timeoutID = null;
    }
  }

}

/* harmony default export */ __webpack_exports__["a"] = (Bridge);

/***/ }),

/***/ 49:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = SemVer;
var debug;
/* istanbul ignore next */

if (typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function debug() {
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift('SEMVER');
    console.log.apply(console, args);
  };
} else {
  debug = function debug() {};
} // Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.


exports.SEMVER_SPEC_VERSION = '2.0.0';
var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */
9007199254740991; // Max safe segment length for coercion.

var MAX_SAFE_COMPONENT_LENGTH = 16; // The actual regexps go on exports.re

var re = exports.re = [];
var src = exports.src = [];
var t = exports.tokens = {};
var R = 0;

function tok(n) {
  t[n] = R++;
} // The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.


tok('NUMERICIDENTIFIER');
src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
tok('NUMERICIDENTIFIERLOOSE');
src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'; // ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

tok('NONNUMERICIDENTIFIER');
src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'; // ## Main Version
// Three dot-separated numeric identifiers.

tok('MAINVERSION');
src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';
tok('MAINVERSIONLOOSE');
src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'; // ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

tok('PRERELEASEIDENTIFIER');
src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
tok('PRERELEASEIDENTIFIERLOOSE');
src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')'; // ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

tok('PRERELEASE');
src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
tok('PRERELEASELOOSE');
src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'; // ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

tok('BUILDIDENTIFIER');
src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'; // ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

tok('BUILD');
src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))'; // ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

tok('FULL');
tok('FULLPLAIN');
src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
src[t.FULL] = '^' + src[t.FULLPLAIN] + '$'; // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.

tok('LOOSEPLAIN');
src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
tok('LOOSE');
src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
tok('GTLT');
src[t.GTLT] = '((?:<|>)?=?)'; // Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.

tok('XRANGEIDENTIFIERLOOSE');
src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
tok('XRANGEIDENTIFIER');
src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
tok('XRANGEPLAIN');
src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';
tok('XRANGEPLAINLOOSE');
src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';
tok('XRANGE');
src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
tok('XRANGELOOSE');
src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$'; // Coercion.
// Extract anything that could conceivably be a part of a valid semver

tok('COERCE');
src[t.COERCE] = '(^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
tok('COERCERTL');
re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g'); // Tilde ranges.
// Meaning is "reasonably at or greater than"

tok('LONETILDE');
src[t.LONETILDE] = '(?:~>?)';
tok('TILDETRIM');
src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
var tildeTrimReplace = '$1~';
tok('TILDE');
src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
tok('TILDELOOSE');
src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'; // Caret ranges.
// Meaning is "at least and backwards compatible with"

tok('LONECARET');
src[t.LONECARET] = '(?:\\^)';
tok('CARETTRIM');
src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
var caretTrimReplace = '$1^';
tok('CARET');
src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
tok('CARETLOOSE');
src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'; // A simple gt/lt/eq thing, or just "" to indicate "any version"

tok('COMPARATORLOOSE');
src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
tok('COMPARATOR');
src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$'; // An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`

tok('COMPARATORTRIM');
src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'; // this one has to use the /g flag

re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3'; // Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.

tok('HYPHENRANGE');
src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\s*$';
tok('HYPHENRANGELOOSE');
src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s*$'; // Star ranges basically just allow anything at all.

tok('STAR');
src[t.STAR] = '(<|>)?=?\\s*\\*'; // Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.

for (var i = 0; i < R; i++) {
  debug(i, src[i]);

  if (!re[i]) {
    re[i] = new RegExp(src[i]);
  }
}

exports.parse = parse;

function parse(version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version !== 'string') {
    return null;
  }

  if (version.length > MAX_LENGTH) {
    return null;
  }

  var r = options.loose ? re[t.LOOSE] : re[t.FULL];

  if (!r.test(version)) {
    return null;
  }

  try {
    return new SemVer(version, options);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;

function valid(version, options) {
  var v = parse(version, options);
  return v ? v.version : null;
}

exports.clean = clean;

function clean(version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version;
    } else {
      version = version.version;
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options);
  }

  debug('SemVer', version, options);
  this.options = options;
  this.loose = !!options.loose;
  var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

  if (!m) {
    throw new TypeError('Invalid Version: ' + version);
  }

  this.raw = version; // these are actually numbers

  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version');
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version');
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version');
  } // numberify any prerelease numeric ids


  if (!m[4]) {
    this.prerelease = [];
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;

        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num;
        }
      }

      return id;
    });
  }

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch;

  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.');
  }

  return this.version;
};

SemVer.prototype.toString = function () {
  return this.version;
};

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other);

  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  } // NOT having a prerelease is > having one


  if (this.prerelease.length && !other.prerelease.length) {
    return -1;
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1;
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0;
  }

  var i = 0;

  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);

    if (a === undefined && b === undefined) {
      return 0;
    } else if (b === undefined) {
      return 1;
    } else if (a === undefined) {
      return -1;
    } else if (a === b) {
      continue;
    } else {
      return compareIdentifiers(a, b);
    }
  } while (++i);
};

SemVer.prototype.compareBuild = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  var i = 0;

  do {
    var a = this.build[i];
    var b = other.build[i];
    debug('prerelease compare', i, a, b);

    if (a === undefined && b === undefined) {
      return 0;
    } else if (b === undefined) {
      return 1;
    } else if (a === undefined) {
      return -1;
    } else if (a === b) {
      continue;
    } else {
      return compareIdentifiers(a, b);
    }
  } while (++i);
}; // preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.


SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;

    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;

    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.

    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier);
      }

      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
        this.major++;
      }

      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;

    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++;
      }

      this.patch = 0;
      this.prerelease = [];
      break;

    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++;
      }

      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.

    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0];
      } else {
        var i = this.prerelease.length;

        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }

        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0);
        }
      }

      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0];
          }
        } else {
          this.prerelease = [identifier, 0];
        }
      }

      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }

  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;

function inc(version, release, loose, identifier) {
  if (typeof loose === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;

function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    var prefix = '';

    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre';
      var defaultResult = 'prerelease';
    }

    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }

    return defaultResult; // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers;
var numeric = /^[0-9]+$/;

function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
}

exports.rcompareIdentifiers = rcompareIdentifiers;

function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;

function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;

function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;

function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;

function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;

function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.compareBuild = compareBuild;

function compareBuild(a, b, loose) {
  var versionA = new SemVer(a, loose);
  var versionB = new SemVer(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
}

exports.rcompare = rcompare;

function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;

function sort(list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(a, b, loose);
  });
}

exports.rsort = rsort;

function rsort(list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(b, a, loose);
  });
}

exports.gt = gt;

function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;

function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;

function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;

function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;

function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;

function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;

function cmp(a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      return a === b;

    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      return a !== b;

    case '':
    case '=':
    case '==':
      return eq(a, b, loose);

    case '!=':
      return neq(a, b, loose);

    case '>':
      return gt(a, b, loose);

    case '>=':
      return gte(a, b, loose);

    case '<':
      return lt(a, b, loose);

    case '<=':
      return lte(a, b, loose);

    default:
      throw new TypeError('Invalid operator: ' + op);
  }
}

exports.Comparator = Comparator;

function Comparator(comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp;
    } else {
      comp = comp.value;
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options);
  }

  debug('comparator', comp, options);
  this.options = options;
  this.loose = !!options.loose;
  this.parse(comp);

  if (this.semver === ANY) {
    this.value = '';
  } else {
    this.value = this.operator + this.semver.version;
  }

  debug('comp', this);
}

var ANY = {};

Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
  var m = comp.match(r);

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp);
  }

  this.operator = m[1] !== undefined ? m[1] : '';

  if (this.operator === '=') {
    this.operator = '';
  } // if it literally is just '>' or '' then allow anything.


  if (!m[2]) {
    this.semver = ANY;
  } else {
    this.semver = new SemVer(m[2], this.options.loose);
  }
};

Comparator.prototype.toString = function () {
  return this.value;
};

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose);

  if (this.semver === ANY || version === ANY) {
    return true;
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options);
    } catch (er) {
      return false;
    }
  }

  return cmp(version, this.operator, this.semver, this.options);
};

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  var rangeTmp;

  if (this.operator === '') {
    if (this.value === '') {
      return true;
    }

    rangeTmp = new Range(comp.value, options);
    return satisfies(this.value, rangeTmp, options);
  } else if (comp.operator === '') {
    if (comp.value === '') {
      return true;
    }

    rangeTmp = new Range(this.value, options);
    return satisfies(comp.semver, rangeTmp, options);
  }

  var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
  var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
  return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};

exports.Range = Range;

function Range(range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
      return range;
    } else {
      return new Range(range.raw, options);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options);
  }

  if (!(this instanceof Range)) {
    return new Range(range, options);
  }

  this.options = options;
  this.loose = !!options.loose;
  this.includePrerelease = !!options.includePrerelease; // First, split based on boolean or ||

  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim());
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function () {
  return this.range;
};

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose;
  range = range.trim(); // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`

  var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range); // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`

  range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[t.COMPARATORTRIM]); // `~ 1.2.3` => `~1.2.3`

  range = range.replace(re[t.TILDETRIM], tildeTrimReplace); // `^ 1.2.3` => `^1.2.3`

  range = range.replace(re[t.CARETTRIM], caretTrimReplace); // normalize spaces

  range = range.split(/\s+/).join(' '); // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options);
  }, this).join(' ').split(/\s+/);

  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe);
    });
  }

  set = set.map(function (comp) {
    return new Comparator(comp, this.options);
  }, this);
  return set;
};

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function (thisComparators) {
    return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
      return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options);
        });
      });
    });
  });
}; // take a set of comparators and determine whether there
// exists a version which can satisfy it


function isSatisfiable(comparators, options) {
  var result = true;
  var remainingComparators = comparators.slice();
  var testComparator = remainingComparators.pop();

  while (result && remainingComparators.length) {
    result = remainingComparators.every(function (otherComparator) {
      return testComparator.intersects(otherComparator, options);
    });
    testComparator = remainingComparators.pop();
  }

  return result;
} // Mostly just for testing and legacy API reasons


exports.toComparators = toComparators;

function toComparators(range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
} // comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.


function parseComparator(comp, options) {
  debug('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug('caret', comp);
  comp = replaceTildes(comp, options);
  debug('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug('xrange', comp);
  comp = replaceStars(comp, options);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
} // ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0


function replaceTildes(comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options);
  }).join(' ');
}

function replaceTilde(comp, options) {
  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    } else if (pr) {
      debug('replaceTilde pr', pr);
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
    }

    debug('tilde return', ret);
    return ret;
  });
} // ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0


function replaceCarets(comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options);
  }).join(' ');
}

function replaceCaret(comp, options) {
  debug('caret', comp, options);
  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
      }
    } else if (pr) {
      debug('replaceCaret pr', pr);

      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
      }
    } else {
      debug('no pr');

      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
      }
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, options) {
  debug('replaceXRanges', comp, options);
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options);
  }).join(' ');
}

function replaceXRange(comp, options) {
  comp = comp.trim();
  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX) {
      gtlt = '';
    } // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value


    pr = options.includePrerelease ? '-0' : '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0;
      }

      p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';

        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';

        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }

      ret = gtlt + M + '.' + m + '.' + p + pr;
    } else if (xm) {
      ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
    }

    debug('xRange return', ret);
    return ret;
  });
} // Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.


function replaceStars(comp, options) {
  debug('replaceStars', comp, options); // Looseness is ignored here.  star is always as loose as it gets!

  return comp.trim().replace(re[t.STAR], '');
} // This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0


function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = '';
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0';
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0';
  } else {
    from = '>=' + from;
  }

  if (isX(tM)) {
    to = '';
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0';
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  } else {
    to = '<=' + to;
  }

  return (from + ' ' + to).trim();
} // if ANY of the sets match ALL of its comparators, then pass


Range.prototype.test = function (version) {
  if (!version) {
    return false;
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options);
    } catch (er) {
      return false;
    }
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true;
    }
  }

  return false;
};

function testSet(set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false;
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver);

      if (set[i].semver === ANY) {
        continue;
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;

        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    } // Version has a -pre, but it's not one of the ones we like.


    return false;
  }

  return true;
}

exports.satisfies = satisfies;

function satisfies(version, range, options) {
  try {
    range = new Range(range, options);
  } catch (er) {
    return false;
  }

  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;

function maxSatisfying(versions, range, options) {
  var max = null;
  var maxSV = null;

  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, options);
      }
    }
  });
  return max;
}

exports.minSatisfying = minSatisfying;

function minSatisfying(versions, range, options) {
  var min = null;
  var minSV = null;

  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, options);
      }
    }
  });
  return min;
}

exports.minVersion = minVersion;

function minVersion(range, loose) {
  range = new Range(range, loose);
  var minver = new SemVer('0.0.0');

  if (range.test(minver)) {
    return minver;
  }

  minver = new SemVer('0.0.0-0');

  if (range.test(minver)) {
    return minver;
  }

  minver = null;

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];
    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version);

      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }

          compver.raw = compver.format();

        /* fallthrough */

        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver;
          }

          break;

        case '<':
        case '<=':
          /* Ignore maximum versions */
          break;

        /* istanbul ignore next */

        default:
          throw new Error('Unexpected operation: ' + comparator.operator);
      }
    });
  }

  if (minver && range.test(minver)) {
    return minver;
  }

  return null;
}

exports.validRange = validRange;

function validRange(range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*';
  } catch (er) {
    return null;
  }
} // Determine if version is less than all the versions possible in the range


exports.ltr = ltr;

function ltr(version, range, options) {
  return outside(version, range, '<', options);
} // Determine if version is greater than all the versions possible in the range.


exports.gtr = gtr;

function gtr(version, range, options) {
  return outside(version, range, '>', options);
}

exports.outside = outside;

function outside(version, range, hilo, options) {
  version = new SemVer(version, options);
  range = new Range(range, options);
  var gtfn, ltefn, ltfn, comp, ecomp;

  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;

    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;

    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  } // If it satisifes the range it is not outside


  if (satisfies(version, range, options)) {
    return false;
  } // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.


  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];
    var high = null;
    var low = null;
    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0');
      }

      high = high || comparator;
      low = low || comparator;

      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    }); // If the edge version comparator has a operator then our version
    // isn't outside it

    if (high.operator === comp || high.operator === ecomp) {
      return false;
    } // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range


    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }

  return true;
}

exports.prerelease = prerelease;

function prerelease(version, options) {
  var parsed = parse(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
}

exports.intersects = intersects;

function intersects(r1, r2, options) {
  r1 = new Range(r1, options);
  r2 = new Range(r2, options);
  return r1.intersects(r2);
}

exports.coerce = coerce;

function coerce(version, options) {
  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version === 'number') {
    version = String(version);
  }

  if (typeof version !== 'string') {
    return null;
  }

  options = options || {};
  var match = null;

  if (!options.rtl) {
    match = version.match(re[t.COERCE]);
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    var next;

    while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }

      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    } // leave it in a clean state


    re[t.COERCERTL].lastIndex = -1;
  }

  if (match === null) {
    return null;
  }

  return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(46)))

/***/ }),

/***/ 50:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

  /* istanbul ignore next */

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(91)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function ErrorStackParser(StackFrame) {
  'use strict';

  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
  var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;
  return {
    /**
     * Given an Error object, extract the most information from it.
     *
     * @param {Error} error object
     * @return {Array} of StackFrames
     */
    parse: function ErrorStackParser$$parse(error) {
      if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
        return this.parseOpera(error);
      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
        return this.parseV8OrIE(error);
      } else if (error.stack) {
        return this.parseFFOrSafari(error);
      } else {
        throw new Error('Cannot parse given Error object');
      }
    },
    // Separate line and column numbers from a string of the form: (URI:Line:Column)
    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
      // Fail-fast but return locations like "(native)"
      if (urlLike.indexOf(':') === -1) {
        return [urlLike];
      }

      var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
      var parts = regExp.exec(urlLike.replace(/[()]/g, ''));
      return [parts[1], parts[2] || undefined, parts[3] || undefined];
    },
    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
      var filtered = error.stack.split('\n').filter(function (line) {
        return !!line.match(CHROME_IE_STACK_REGEXP);
      }, this);
      return filtered.map(function (line) {
        if (line.indexOf('(eval ') > -1) {
          // Throw away eval information until we implement stacktrace.js/stackframe#8
          line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^()]*)|(\),.*$)/g, '');
        }

        var sanitizedLine = line.replace(/^\s+/, '').replace(/\(eval code/g, '('); // capture and preseve the parenthesized location "(/foo/my bar.js:12:87)" in
        // case it has spaces in it, as the string is split on \s+ later on

        var location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/); // remove the parenthesized location from the line, if it was matched

        sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;
        var tokens = sanitizedLine.split(/\s+/).slice(1); // if a location was matched, pass it to extractLocation() otherwise pop the last token

        var locationParts = this.extractLocation(location ? location[1] : tokens.pop());
        var functionName = tokens.join(' ') || undefined;
        var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];
        return new StackFrame({
          functionName: functionName,
          fileName: fileName,
          lineNumber: locationParts[1],
          columnNumber: locationParts[2],
          source: line
        });
      }, this);
    },
    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
      var filtered = error.stack.split('\n').filter(function (line) {
        return !line.match(SAFARI_NATIVE_CODE_REGEXP);
      }, this);
      return filtered.map(function (line) {
        // Throw away eval information until we implement stacktrace.js/stackframe#8
        if (line.indexOf(' > eval') > -1) {
          line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ':$1');
        }

        if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
          // Safari eval frames only have function names and nothing else
          return new StackFrame({
            functionName: line
          });
        } else {
          var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
          var matches = line.match(functionNameRegex);
          var functionName = matches && matches[1] ? matches[1] : undefined;
          var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));
          return new StackFrame({
            functionName: functionName,
            fileName: locationParts[0],
            lineNumber: locationParts[1],
            columnNumber: locationParts[2],
            source: line
          });
        }
      }, this);
    },
    parseOpera: function ErrorStackParser$$parseOpera(e) {
      if (!e.stacktrace || e.message.indexOf('\n') > -1 && e.message.split('\n').length > e.stacktrace.split('\n').length) {
        return this.parseOpera9(e);
      } else if (!e.stack) {
        return this.parseOpera10(e);
      } else {
        return this.parseOpera11(e);
      }
    },
    parseOpera9: function ErrorStackParser$$parseOpera9(e) {
      var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
      var lines = e.message.split('\n');
      var result = [];

      for (var i = 2, len = lines.length; i < len; i += 2) {
        var match = lineRE.exec(lines[i]);

        if (match) {
          result.push(new StackFrame({
            fileName: match[2],
            lineNumber: match[1],
            source: lines[i]
          }));
        }
      }

      return result;
    },
    parseOpera10: function ErrorStackParser$$parseOpera10(e) {
      var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
      var lines = e.stacktrace.split('\n');
      var result = [];

      for (var i = 0, len = lines.length; i < len; i += 2) {
        var match = lineRE.exec(lines[i]);

        if (match) {
          result.push(new StackFrame({
            functionName: match[3] || undefined,
            fileName: match[2],
            lineNumber: match[1],
            source: lines[i]
          }));
        }
      }

      return result;
    },
    // Opera 10.65+ Error.stack very similar to FF/Safari
    parseOpera11: function ErrorStackParser$$parseOpera11(error) {
      var filtered = error.stack.split('\n').filter(function (line) {
        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
      }, this);
      return filtered.map(function (line) {
        var tokens = line.split('@');
        var locationParts = this.extractLocation(tokens.pop());
        var functionCall = tokens.shift() || '';
        var functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, '$2').replace(/\([^)]*\)/g, '') || undefined;
        var argsRaw;

        if (functionCall.match(/\(([^)]*)\)/)) {
          argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, '$1');
        }

        var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');
        return new StackFrame({
          functionName: functionName,
          args: args,
          fileName: locationParts[0],
          lineNumber: locationParts[1],
          columnNumber: locationParts[2],
          source: line
        });
      }, this);
    }
  };
});

/***/ }),

/***/ 64:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (":root {\n  /**\n   * IMPORTANT: When new theme variables are added belowâ€“ also add them to SettingsContext updateThemeVariables()\n   */\n\n  /* Light theme */\n  --light-color-attribute-name: #ef6632;\n  --light-color-attribute-name-not-editable: #23272f;\n  --light-color-attribute-name-inverted: rgba(255, 255, 255, 0.7);\n  --light-color-attribute-value: #1a1aa6;\n  --light-color-attribute-value-inverted: #ffffff;\n  --light-color-attribute-editable-value: #1a1aa6;\n  --light-color-background: #ffffff;\n  --light-color-background-hover: rgba(0, 136, 250, 0.1);\n  --light-color-background-inactive: #e5e5e5;\n  --light-color-background-invalid: #fff0f0;\n  --light-color-background-selected: #0088fa;\n  --light-color-button-background: #ffffff;\n  --light-color-button-background-focus: #ededed;\n  --light-color-button: #5f6673;\n  --light-color-button-disabled: #cfd1d5;\n  --light-color-button-active: #0088fa;\n  --light-color-button-focus: #23272f;\n  --light-color-button-hover: #23272f;\n  --light-color-border: #eeeeee;\n  --light-color-commit-did-not-render-fill: #cfd1d5;\n  --light-color-commit-did-not-render-fill-text: #000000;\n  --light-color-commit-did-not-render-pattern: #cfd1d5;\n  --light-color-commit-did-not-render-pattern-text: #333333;\n  --light-color-commit-gradient-0: #37afa9;\n  --light-color-commit-gradient-1: #63b19e;\n  --light-color-commit-gradient-2: #80b393;\n  --light-color-commit-gradient-3: #97b488;\n  --light-color-commit-gradient-4: #abb67d;\n  --light-color-commit-gradient-5: #beb771;\n  --light-color-commit-gradient-6: #cfb965;\n  --light-color-commit-gradient-7: #dfba57;\n  --light-color-commit-gradient-8: #efbb49;\n  --light-color-commit-gradient-9: #febc38;\n  --light-color-commit-gradient-text: #000000;\n  --light-color-component-name: #6a51b2;\n  --light-color-component-name-inverted: #ffffff;\n  --light-color-component-badge-background: rgba(0, 0, 0, 0.1);\n  --light-color-component-badge-background-inverted: rgba(255, 255, 255, 0.25);\n  --light-color-component-badge-count: #777d88;\n  --light-color-component-badge-count-inverted: rgba(255, 255, 255, 0.7);\n  --light-color-context-background: rgba(0,0,0,.9);\n  --light-color-context-background-hover: rgba(255, 255, 255, 0.1);\n  --light-color-context-background-selected: #178fb9;\n  --light-color-context-border: #3d424a;\n  --light-color-context-text: #ffffff;\n  --light-color-context-text-selected: #ffffff;\n  --light-color-dim: #777d88;\n  --light-color-dimmer: #cfd1d5;\n  --light-color-dimmest: #eff0f1;\n  --light-color-error-background: hsl(0, 100%, 97%);\n  --light-color-error-border: hsl(0, 100%, 92%);\n  --light-color-error-text: #ff0000;\n  --light-color-expand-collapse-toggle: #777d88;\n  --light-color-link: #0000ff;\n  --light-color-modal-background: rgba(255, 255, 255, 0.75);\n  --light-color-record-active: #fc3a4b;\n  --light-color-record-hover: #3578e5;\n  --light-color-record-inactive: #0088fa;\n  --light-color-scroll-thumb: #c2c2c2;\n  --light-color-scroll-track: #fafafa;\n  --light-color-search-match: yellow;\n  --light-color-search-match-current: #f7923b;\n  --light-color-selected-tree-highlight-active: rgba(0, 136, 250, 0.1);\n  --light-color-selected-tree-highlight-inactive: rgba(0, 0, 0, 0.05);\n  --light-color-shadow: rgba(0, 0, 0, 0.25);\n  --light-color-tab-selected-border: #0088fa;\n  --light-color-text: #000000;\n  --light-color-text-invalid: #ff0000;\n  --light-color-text-selected: #ffffff;\n  --light-color-toggle-background-invalid: #fc3a4b;\n  --light-color-toggle-background-on: #0088fa;\n  --light-color-toggle-background-off: #cfd1d5;\n  --light-color-toggle-text: #ffffff;\n  --light-color-tooltip-background: rgba(0, 0, 0, 0.9);\n  --light-color-tooltip-text: #ffffff;\n\n  /* Dark theme */\n  --dark-color-attribute-name: #9d87d2;\n  --dark-color-attribute-name-not-editable: #ededed;\n  --dark-color-attribute-name-inverted: #282828;\n  --dark-color-attribute-value: #cedae0;\n  --dark-color-attribute-value-inverted: #ffffff;\n  --dark-color-attribute-editable-value: yellow;\n  --dark-color-background: #282c34;\n  --dark-color-background-hover: rgba(255, 255, 255, 0.1);\n  --dark-color-background-inactive: #3d424a;\n  --dark-color-background-invalid: #5c0000;\n  --dark-color-background-selected: #178fb9;\n  --dark-color-button-background: #282c34;\n  --dark-color-button-background-focus: #3d424a;\n  --dark-color-button: #afb3b9;\n  --dark-color-button-active: #61dafb;\n  --dark-color-button-disabled: #4f5766;\n  --dark-color-button-focus: #a2e9fc;\n  --dark-color-button-hover: #ededed;\n  --dark-color-border: #3d424a;\n  --dark-color-commit-did-not-render-fill: #777d88;\n  --dark-color-commit-did-not-render-fill-text: #000000;\n  --dark-color-commit-did-not-render-pattern: #666c77;\n  --dark-color-commit-did-not-render-pattern-text: #ffffff;\n  --dark-color-commit-gradient-0: #37afa9;\n  --dark-color-commit-gradient-1: #63b19e;\n  --dark-color-commit-gradient-2: #80b393;\n  --dark-color-commit-gradient-3: #97b488;\n  --dark-color-commit-gradient-4: #abb67d;\n  --dark-color-commit-gradient-5: #beb771;\n  --dark-color-commit-gradient-6: #cfb965;\n  --dark-color-commit-gradient-7: #dfba57;\n  --dark-color-commit-gradient-8: #efbb49;\n  --dark-color-commit-gradient-9: #febc38;\n  --dark-color-commit-gradient-text: #000000;\n  --dark-color-component-name: #61dafb;\n  --dark-color-component-name-inverted: #282828;\n  --dark-color-component-badge-background: rgba(255, 255, 255, 0.25);\n  --dark-color-component-badge-background-inverted: rgba(0, 0, 0, 0.25);\n  --dark-color-component-badge-count: #8f949d;\n  --dark-color-component-badge-count-inverted: rgba(255, 255, 255, 0.7);\n  --dark-color-context-background: rgba(255,255,255,.9);\n  --dark-color-context-background-hover: rgba(0, 136, 250, 0.1);\n  --dark-color-context-background-selected: #0088fa;\n  --dark-color-context-border: #eeeeee;\n  --dark-color-context-text: #000000;\n  --dark-color-context-text-selected: #ffffff;\n  --dark-color-dim: #8f949d;\n  --dark-color-dimmer: #777d88;\n  --dark-color-dimmest: #4f5766;\n  --dark-color-error-background: #200;\n  --dark-color-error-border: #900;\n  --dark-color-error-text: #f55;\n  --dark-color-expand-collapse-toggle: #8f949d;\n  --dark-color-link: #61dafb;\n  --dark-color-modal-background: rgba(0, 0, 0, 0.75);\n  --dark-color-record-active: #fc3a4b;\n  --dark-color-record-hover: #a2e9fc;\n  --dark-color-record-inactive: #61dafb;\n  --dark-color-scroll-thumb: #afb3b9;\n  --dark-color-scroll-track: #313640;\n  --dark-color-search-match: yellow;\n  --dark-color-search-match-current: #f7923b;\n  --dark-color-selected-tree-highlight-active: rgba(23, 143, 185, 0.15);\n  --dark-color-selected-tree-highlight-inactive: rgba(255, 255, 255, 0.05);\n  --dark-color-shadow: rgba(0, 0, 0, 0.5);\n  --dark-color-tab-selected-border: #178fb9;\n  --dark-color-text: #ffffff;\n  --dark-color-text-invalid: #ff8080;\n  --dark-color-text-selected: #ffffff;\n  --dark-color-toggle-background-invalid: #fc3a4b;\n  --dark-color-toggle-background-on: #178fb9;\n  --dark-color-toggle-background-off: #777d88;\n  --dark-color-toggle-text: #ffffff;\n  --dark-color-tooltip-background: rgba(255, 255, 255, 0.9);\n  --dark-color-tooltip-text: #000000;\n\n  /* Font smoothing */\n  --light-font-smoothing: auto;\n  --dark-font-smoothing: antialiased;\n  --font-smoothing: auto;\n\n  /* Compact density */\n  --compact-font-size-monospace-small: 9px;\n  --compact-font-size-monospace-normal: 11px;\n  --compact-font-size-monospace-large: 15px;\n  --compact-font-size-sans-small: 10px;\n  --compact-font-size-sans-normal: 12px;\n  --compact-font-size-sans-large: 14px;\n  --compact-line-height-data: 18px;\n  --compact-root-font-size: 16px;\n\n  /* Comfortable density */\n  --comfortable-font-size-monospace-small: 10px;\n  --comfortable-font-size-monospace-normal: 13px;\n  --comfortable-font-size-monospace-large: 17px;\n  --comfortable-font-size-sans-small: 12px;\n  --comfortable-font-size-sans-normal: 14px;\n  --comfortable-font-size-sans-large: 16px;\n  --comfortable-line-height-data: 22px;\n  --comfortable-root-font-size: 20px;\n\n  /* GitHub.com system fonts */\n  --font-family-monospace: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo,\n    Courier, monospace;\n  --font-family-sans: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica,\n    Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol;\n\n  /* Constant values shared between JS and CSS */\n  --interaction-commit-size: 10px;\n  --interaction-label-width: 200px;\n}\n");

/***/ }),

/***/ 65:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;

function Yallist(list) {
  var self = this;

  if (!(self instanceof Yallist)) {
    self = new Yallist();
  }

  self.tail = null;
  self.head = null;
  self.length = 0;

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }

  return self;
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list');
  }

  var next = node.next;
  var prev = node.prev;

  if (next) {
    next.prev = prev;
  }

  if (prev) {
    prev.next = next;
  }

  if (node === this.head) {
    this.head = next;
  }

  if (node === this.tail) {
    this.tail = prev;
  }

  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var head = this.head;
  node.list = this;
  node.next = head;

  if (head) {
    head.prev = node;
  }

  this.head = node;

  if (!this.tail) {
    this.tail = node;
  }

  this.length++;
};

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var tail = this.tail;
  node.list = this;
  node.prev = tail;

  if (tail) {
    tail.next = node;
  }

  this.tail = node;

  if (!this.head) {
    this.head = node;
  }

  this.length++;
};

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined;
  }

  var res = this.tail.value;
  this.tail = this.tail.prev;

  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined;
  }

  var res = this.head.value;
  this.head = this.head.next;

  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }

  return res;
};

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }

  return res;
};

Yallist.prototype.reduce = function (fn, initial) {
  var acc;
  var walker = this.head;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }

  return acc;
};

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc;
  var walker = this.tail;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }

  return acc;
};

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }

  return arr;
};

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }

  return arr;
};

Yallist.prototype.slice = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }

  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }

  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.splice = function (start, deleteCount
/*, ...nodes */
) {
  if (start > this.length) {
    start = this.length - 1;
  }

  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }

  var ret = [];

  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }

  if (walker === null) {
    walker = this.tail;
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }

  for (var i = 2; i < arguments.length; i++) {
    walker = insert(this, walker, arguments[i]);
  }

  return ret;
};

Yallist.prototype.reverse = function () {
  var head = this.head;
  var tail = this.tail;

  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }

  this.head = tail;
  this.tail = head;
  return this;
};

function insert(self, node, value) {
  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);

  if (inserted.next === null) {
    self.tail = inserted;
  }

  if (inserted.prev === null) {
    self.head = inserted;
  }

  self.length++;
  return inserted;
}

function push(self, item) {
  self.tail = new Node(item, self.tail, null, self);

  if (!self.head) {
    self.head = self.tail;
  }

  self.length++;
}

function unshift(self, item) {
  self.head = new Node(item, null, self.head, self);

  if (!self.tail) {
    self.tail = self.head;
  }

  self.length++;
}

function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }

  this.list = list;
  this.value = value;

  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }

  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(66)(Yallist);
} catch (er) {}

/***/ }),

/***/ 66:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var walker;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          walker = this.head;

        case 1:
          if (!walker) {
            _context.next = 7;
            break;
          }

          _context.next = 4;
          return walker.value;

        case 4:
          walker = walker.next;
          _context.next = 1;
          break;

        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee, this);
  });
};

/***/ }),

/***/ 67:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(68); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34)))

/***/ }),

/***/ 68:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function registerImmediate(handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function onGlobalMessage(event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function registerImmediate(handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function registerImmediate(handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function registerImmediate(handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function registerImmediate(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6â€“8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34), __webpack_require__(46)))

/***/ }),

/***/ 7:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return localStorageGetItem; });
/* unused harmony export localStorageRemoveItem */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return localStorageSetItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return sessionStorageGetItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return sessionStorageRemoveItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return sessionStorageSetItem; });
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function localStorageGetItem(key) {
  try {
    return localStorage.getItem(key);
  } catch (error) {
    return null;
  }
}
function localStorageRemoveItem(key) {
  try {
    localStorage.removeItem(key);
  } catch (error) {}
}
function localStorageSetItem(key, value) {
  try {
    return localStorage.setItem(key, value);
  } catch (error) {}
}
function sessionStorageGetItem(key) {
  try {
    return sessionStorage.getItem(key);
  } catch (error) {
    return null;
  }
}
function sessionStorageRemoveItem(key) {
  try {
    sessionStorage.removeItem(key);
  } catch (error) {}
}
function sessionStorageSetItem(key, value) {
  try {
    return sessionStorage.setItem(key, value);
  } catch (error) {}
}

/***/ }),

/***/ 8:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return meta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return dehydrate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return fillInPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return hydrate; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

const meta = {
  inspectable: Symbol('inspectable'),
  inspected: Symbol('inspected'),
  name: Symbol('name'),
  preview_long: Symbol('preview_long'),
  preview_short: Symbol('preview_short'),
  readonly: Symbol('readonly'),
  size: Symbol('size'),
  type: Symbol('type'),
  unserializable: Symbol('unserializable')
};
// This threshold determines the depth at which the bridge "dehydrates" nested data.
// Dehydration means that we don't serialize the data for e.g. postMessage or stringify,
// unless the frontend explicitly requests it (e.g. a user clicks to expand a props object).
//
// Reducing this threshold will improve the speed of initial component inspection,
// but may decrease the responsiveness of expanding objects/arrays to inspect further.
const LEVEL_THRESHOLD = 2;
/**
 * Generate the dehydrated metadata for complex object instances
 */

function createDehydrated(type, inspectable, data, cleaned, path) {
  cleaned.push(path);
  const dehydrated = {
    inspectable,
    type,
    preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
    preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
    name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name
  };

  if (type === 'array' || type === 'typed_array') {
    dehydrated.size = data.length;
  } else if (type === 'object') {
    dehydrated.size = Object.keys(data).length;
  }

  if (type === 'iterator' || type === 'typed_array') {
    dehydrated.readonly = true;
  }

  return dehydrated;
}
/**
 * Strip out complex data (instances, functions, and data nested > LEVEL_THRESHOLD levels deep).
 * The paths of the stripped out objects are appended to the `cleaned` list.
 * On the other side of the barrier, the cleaned list is used to "re-hydrate" the cleaned representation into
 * an object with symbols as attributes, so that a sanitized object can be distinguished from a normal object.
 *
 * Input: {"some": {"attr": fn()}, "other": AnInstance}
 * Output: {
 *   "some": {
 *     "attr": {"name": the fn.name, type: "function"}
 *   },
 *   "other": {
 *     "name": "AnInstance",
 *     "type": "object",
 *   },
 * }
 * and cleaned = [["some", "attr"], ["other"]]
 */


function dehydrate(data, cleaned, unserializable, path, isPathAllowed, level = 0) {
  const type = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getDataType */ "f"])(data);
  let isPathAllowedCheck;

  switch (type) {
    case 'html_element':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: data.tagName,
        type
      };

    case 'function':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: typeof data.name === 'function' || !data.name ? 'function' : data.name,
        type
      };

    case 'string':
      return data.length <= 500 ? data : data.slice(0, 500) + '...';

    case 'bigint':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: data.toString(),
        type
      };

    case 'symbol':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: data.toString(),
        type
      };
    // React Elements aren't very inspector-friendly,
    // and often contain private fields or circular references.

    case 'react_element':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getDisplayNameForReactElement */ "i"])(data) || 'Unknown',
        type
      };
    // ArrayBuffers error if you try to inspect them.

    case 'array_buffer':
    case 'data_view':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: type === 'data_view' ? 'DataView' : 'ArrayBuffer',
        size: data.byteLength,
        type
      };

    case 'array':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      }

      return data.map((item, i) => dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1));

    case 'html_all_collection':
    case 'typed_array':
    case 'iterator':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      } else {
        const unserializableValue = {
          unserializable: true,
          type: type,
          readonly: true,
          size: type === 'typed_array' ? data.length : undefined,
          preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
          preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
          name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name
        };

        if (typeof data[Symbol.iterator]) {
          // TRICKY
          // Don't use [...spread] syntax for this purpose.
          // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
          // Other types (e.g. typed arrays, Sets) will not spread correctly.
          Array.from(data).forEach((item, i) => unserializableValue[i] = dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1));
        }

        unserializable.push(path);
        return unserializableValue;
      }

    case 'opaque_iterator':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: data[Symbol.toStringTag],
        type
      };

    case 'date':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: data.toString(),
        type
      };

    case 'regexp':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: data.toString(),
        type
      };

    case 'object':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      } else {
        const object = {};
        Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getAllEnumerableKeys */ "c"])(data).forEach(key => {
          const name = key.toString();
          object[name] = dehydrate(data[key], cleaned, unserializable, path.concat([name]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
        });
        return object;
      }

    case 'infinity':
    case 'nan':
    case 'undefined':
      // Some values are lossy when sent through a WebSocket.
      // We dehydrate+rehydrate them to preserve their type.
      cleaned.push(path);
      return {
        type
      };

    default:
      return data;
  }
}
function fillInPath(object, data, path, value) {
  const target = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getInObject */ "j"])(object, path);

  if (target != null) {
    if (!target[meta.unserializable]) {
      delete target[meta.inspectable];
      delete target[meta.inspected];
      delete target[meta.name];
      delete target[meta.preview_long];
      delete target[meta.preview_short];
      delete target[meta.readonly];
      delete target[meta.size];
      delete target[meta.type];
    }
  }

  if (value !== null && data.unserializable.length > 0) {
    const unserializablePath = data.unserializable[0];
    let isMatch = unserializablePath.length === path.length;

    for (let i = 0; i < path.length; i++) {
      if (path[i] !== unserializablePath[i]) {
        isMatch = false;
        break;
      }
    }

    if (isMatch) {
      upgradeUnserializable(value, value);
    }
  }

  Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* setInObject */ "q"])(object, path, value);
}
function hydrate(object, cleaned, unserializable) {
  cleaned.forEach(path => {
    const length = path.length;
    const last = path[length - 1];
    const parent = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getInObject */ "j"])(object, path.slice(0, length - 1));

    if (!parent || !parent.hasOwnProperty(last)) {
      return;
    }

    const value = parent[last];

    if (value.type === 'infinity') {
      parent[last] = Infinity;
    } else if (value.type === 'nan') {
      parent[last] = NaN;
    } else if (value.type === 'undefined') {
      parent[last] = undefined;
    } else {
      // Replace the string keys with Symbols so they're non-enumerable.
      const replaced = {};
      replaced[meta.inspectable] = !!value.inspectable;
      replaced[meta.inspected] = false;
      replaced[meta.name] = value.name;
      replaced[meta.preview_long] = value.preview_long;
      replaced[meta.preview_short] = value.preview_short;
      replaced[meta.size] = value.size;
      replaced[meta.readonly] = !!value.readonly;
      replaced[meta.type] = value.type;
      parent[last] = replaced;
    }
  });
  unserializable.forEach(path => {
    const length = path.length;
    const last = path[length - 1];
    const parent = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getInObject */ "j"])(object, path.slice(0, length - 1));

    if (!parent || !parent.hasOwnProperty(last)) {
      return;
    }

    const node = parent[last];

    const replacement = _objectSpread({}, node);

    upgradeUnserializable(replacement, node);
    parent[last] = replacement;
  });
  return object;
}

function upgradeUnserializable(destination, source) {
  Object.defineProperties(destination, {
    [meta.inspected]: {
      configurable: true,
      enumerable: false,
      value: !!source.inspected
    },
    [meta.name]: {
      configurable: true,
      enumerable: false,
      value: source.name
    },
    [meta.preview_long]: {
      configurable: true,
      enumerable: false,
      value: source.preview_long
    },
    [meta.preview_short]: {
      configurable: true,
      enumerable: false,
      value: source.preview_short
    },
    [meta.size]: {
      configurable: true,
      enumerable: false,
      value: source.size
    },
    [meta.readonly]: {
      configurable: true,
      enumerable: false,
      value: !!source.readonly
    },
    [meta.type]: {
      configurable: true,
      enumerable: false,
      value: source.type
    },
    [meta.unserializable]: {
      configurable: true,
      enumerable: false,
      value: !!source.unserializable
    }
  });
  delete destination.inspected;
  delete destination.name;
  delete destination.preview_long;
  delete destination.preview_short;
  delete destination.size;
  delete destination.readonly;
  delete destination.type;
  delete destination.unserializable;
}

/***/ }),

/***/ 9:
/***/ (function(module, exports) {

module.exports = __webpack_require__("../../node_modules/react-is/index.js");

/***/ }),

/***/ 91:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

  /* istanbul ignore next */

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function () {
  'use strict';

  function _isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }

  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
  }

  function _getter(p) {
    return function () {
      return this[p];
    };
  }

  var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
  var numericProps = ['columnNumber', 'lineNumber'];
  var stringProps = ['fileName', 'functionName', 'source'];
  var arrayProps = ['args'];
  var props = booleanProps.concat(numericProps, stringProps, arrayProps);

  function StackFrame(obj) {
    if (!obj) return;

    for (var i = 0; i < props.length; i++) {
      if (obj[props[i]] !== undefined) {
        this['set' + _capitalize(props[i])](obj[props[i]]);
      }
    }
  }

  StackFrame.prototype = {
    getArgs: function getArgs() {
      return this.args;
    },
    setArgs: function setArgs(v) {
      if (Object.prototype.toString.call(v) !== '[object Array]') {
        throw new TypeError('Args must be an Array');
      }

      this.args = v;
    },
    getEvalOrigin: function getEvalOrigin() {
      return this.evalOrigin;
    },
    setEvalOrigin: function setEvalOrigin(v) {
      if (v instanceof StackFrame) {
        this.evalOrigin = v;
      } else if (v instanceof Object) {
        this.evalOrigin = new StackFrame(v);
      } else {
        throw new TypeError('Eval Origin must be an Object or StackFrame');
      }
    },
    toString: function toString() {
      var fileName = this.getFileName() || '';
      var lineNumber = this.getLineNumber() || '';
      var columnNumber = this.getColumnNumber() || '';
      var functionName = this.getFunctionName() || '';

      if (this.getIsEval()) {
        if (fileName) {
          return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
        }

        return '[eval]:' + lineNumber + ':' + columnNumber;
      }

      if (functionName) {
        return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
      }

      return fileName + ':' + lineNumber + ':' + columnNumber;
    }
  };

  StackFrame.fromString = function StackFrame$$fromString(str) {
    var argsStartIndex = str.indexOf('(');
    var argsEndIndex = str.lastIndexOf(')');
    var functionName = str.substring(0, argsStartIndex);
    var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
    var locationString = str.substring(argsEndIndex + 1);

    if (locationString.indexOf('@') === 0) {
      var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
      var fileName = parts[1];
      var lineNumber = parts[2];
      var columnNumber = parts[3];
    }

    return new StackFrame({
      functionName: functionName,
      args: args || undefined,
      fileName: fileName,
      lineNumber: lineNumber || undefined,
      columnNumber: columnNumber || undefined
    });
  };

  for (var i = 0; i < booleanProps.length; i++) {
    StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);

    StackFrame.prototype['set' + _capitalize(booleanProps[i])] = function (p) {
      return function (v) {
        this[p] = Boolean(v);
      };
    }(booleanProps[i]);
  }

  for (var j = 0; j < numericProps.length; j++) {
    StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);

    StackFrame.prototype['set' + _capitalize(numericProps[j])] = function (p) {
      return function (v) {
        if (!_isNumber(v)) {
          throw new TypeError(p + ' must be a Number');
        }

        this[p] = Number(v);
      };
    }(numericProps[j]);
  }

  for (var k = 0; k < stringProps.length; k++) {
    StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);

    StackFrame.prototype['set' + _capitalize(stringProps[k])] = function (p) {
      return function (v) {
        this[p] = String(v);
      };
    }(stringProps[k]);
  }

  return StackFrame;
});

/***/ })

/******/ });
//# sourceMappingURL=backend.js.map

/***/ }),

/***/ "../../node_modules/react-devtools-inline/dist/frontend.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 160);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("../../node_modules/react/index.js");

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return ElementTypeClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return ElementTypeContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return ElementTypeFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return ElementTypeForwardRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return ElementTypeHostComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return ElementTypeMemo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return ElementTypeOtherOrUnknown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return ElementTypeProfiler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return ElementTypeRoot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return ElementTypeSuspense; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return ElementTypeSuspenseList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ComponentFilterElementType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ComponentFilterDisplayName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return ComponentFilterLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ComponentFilterHOC; });
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// WARNING
// The values below are referenced by ComponentFilters (which are saved via localStorage).
// Do not change them or it will break previously saved user customizations.
// If new element types are added, use new numbers rather than re-ordering existing ones.
//
// Changing these types is also a backwards breaking change for the standalone shell,
// since the frontend and backend must share the same values-
// and the backend is embedded in certain environments (like React Native).
const ElementTypeClass = 1;
const ElementTypeContext = 2;
const ElementTypeFunction = 5;
const ElementTypeForwardRef = 6;
const ElementTypeHostComponent = 7;
const ElementTypeMemo = 8;
const ElementTypeOtherOrUnknown = 9;
const ElementTypeProfiler = 10;
const ElementTypeRoot = 11;
const ElementTypeSuspense = 12;
const ElementTypeSuspenseList = 13; // Different types of elements displayed in the Elements tree.
// These types may be used to visually distinguish types,
// or to enable/disable certain functionality.

// WARNING
// The values below are referenced by ComponentFilters (which are saved via localStorage).
// Do not change them or it will break previously saved user customizations.
// If new filter types are added, use new numbers rather than re-ordering existing ones.
const ComponentFilterElementType = 1;
const ComponentFilterDisplayName = 2;
const ComponentFilterLocation = 3;
const ComponentFilterHOC = 4;

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export alphaSortKeys */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getAllEnumerableKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return getDisplayName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return getUID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return utfDecodeString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return utfEncodeString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return printOperationsArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getDefaultComponentFilters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return getSavedComponentFilters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return saveComponentFilters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getAppendComponentStack; });
/* unused harmony export setAppendComponentStack */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getBreakOnConsoleErrors; });
/* unused harmony export setBreakOnConsoleErrors */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return separateDisplayNameAndHOCs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return shallowDiffers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return getInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return deletePathInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return renamePathInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return setInObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return getDataType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return getDisplayNameForReactElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return formatDataForPreview; });
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_is__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/* harmony import */ var react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1);
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7);
/* harmony import */ var _hydration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */










const cachedDisplayNames = new WeakMap(); // On large trees, encoding takes significant time.
// Try to reuse the already encoded strings.

const encodedStringCache = new lru_cache__WEBPACK_IMPORTED_MODULE_0___default.a({
  max: 1000
});
function alphaSortKeys(a, b) {
  if (a.toString() > b.toString()) {
    return 1;
  } else if (b.toString() > a.toString()) {
    return -1;
  } else {
    return 0;
  }
}
function getAllEnumerableKeys(obj) {
  const keys = [];
  let current = obj;

  while (current != null) {
    const currentKeys = [...Object.keys(current), ...Object.getOwnPropertySymbols(current)];
    const descriptors = Object.getOwnPropertyDescriptors(current);
    currentKeys.forEach(key => {
      // $FlowFixMe: key can be a Symbol https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor
      if (descriptors[key].enumerable) {
        keys.push(key);
      }
    });
    current = Object.getPrototypeOf(current);
  }

  return keys;
}
function getDisplayName(type, fallbackName = 'Anonymous') {
  const nameFromCache = cachedDisplayNames.get(type);

  if (nameFromCache != null) {
    return nameFromCache;
  }

  let displayName = fallbackName; // The displayName property is not guaranteed to be a string.
  // It's only safe to use for our purposes if it's a string.
  // github.com/facebook/react-devtools/issues/803

  if (typeof type.displayName === 'string') {
    displayName = type.displayName;
  } else if (typeof type.name === 'string' && type.name !== '') {
    displayName = type.name;
  }

  cachedDisplayNames.set(type, displayName);
  return displayName;
}
let uidCounter = 0;
function getUID() {
  return ++uidCounter;
}
function utfDecodeString(array) {
  return String.fromCodePoint(...array);
}
function utfEncodeString(string) {
  const cached = encodedStringCache.get(string);

  if (cached !== undefined) {
    return cached;
  }

  const encoded = new Array(string.length);

  for (let i = 0; i < string.length; i++) {
    encoded[i] = string.codePointAt(i);
  }

  encodedStringCache.set(string, encoded);
  return encoded;
}
function printOperationsArray(operations) {
  // The first two values are always rendererID and rootID
  const rendererID = operations[0];
  const rootID = operations[1];
  const logs = [`operations for renderer:${rendererID} and root:${rootID}`];
  let i = 2; // Reassemble the string table.

  const stringTable = [null // ID = 0 corresponds to the null string.
  ];
  const stringTableSize = operations[i++];
  const stringTableEnd = i + stringTableSize;

  while (i < stringTableEnd) {
    const nextLength = operations[i++];
    const nextString = utfDecodeString(operations.slice(i, i + nextLength));
    stringTable.push(nextString);
    i += nextLength;
  }

  while (i < operations.length) {
    const operation = operations[i];

    switch (operation) {
      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_ADD */ "l"]:
        {
          const id = operations[i + 1];
          const type = operations[i + 2];
          i += 3;

          if (type === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeRoot */ "m"]) {
            logs.push(`Add new root node ${id}`);
            i++; // supportsProfiling

            i++; // hasOwnerMetadata
          } else {
            const parentID = operations[i];
            i++;
            i++; // ownerID

            const displayNameStringID = operations[i];
            const displayName = stringTable[displayNameStringID];
            i++;
            i++; // key

            logs.push(`Add node ${id} (${displayName || 'null'}) as child of ${parentID}`);
          }

          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_REMOVE */ "m"]:
        {
          const removeLength = operations[i + 1];
          i += 2;

          for (let removeIndex = 0; removeIndex < removeLength; removeIndex++) {
            const id = operations[i];
            i += 1;
            logs.push(`Remove node ${id}`);
          }

          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_REORDER_CHILDREN */ "n"]:
        {
          const id = operations[i + 1];
          const numChildren = operations[i + 2];
          i += 3;
          const children = operations.slice(i, i + numChildren);
          i += numChildren;
          logs.push(`Re-order node ${id} children ${children.join(',')}`);
          break;
        }

      case _constants__WEBPACK_IMPORTED_MODULE_3__[/* TREE_OPERATION_UPDATE_TREE_BASE_DURATION */ "o"]:
        // Base duration updates are only sent while profiling is in progress.
        // We can ignore them at this point.
        // The profiler UI uses them lazily in order to generate the tree.
        i += 3;
        break;

      default:
        throw Error(`Unsupported Bridge operation ${operation}`);
    }
  }

  console.log(logs.join('\n  '));
}
function getDefaultComponentFilters() {
  return [{
    type: react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ComponentFilterElementType */ "b"],
    value: react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeHostComponent */ "i"],
    isEnabled: true
  }];
}
function getSavedComponentFilters() {
  try {
    const raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_FILTER_PREFERENCES_KEY */ "d"]);

    if (raw != null) {
      return JSON.parse(raw);
    }
  } catch (error) {}

  return getDefaultComponentFilters();
}
function saveComponentFilters(componentFilters) {
  Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageSetItem */ "b"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_FILTER_PREFERENCES_KEY */ "d"], JSON.stringify(componentFilters));
}
function getAppendComponentStack() {
  try {
    const raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY */ "f"]);

    if (raw != null) {
      return JSON.parse(raw);
    }
  } catch (error) {}

  return true;
}
function setAppendComponentStack(value) {
  Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageSetItem */ "b"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY */ "f"], JSON.stringify(value));
}
function getBreakOnConsoleErrors() {
  try {
    const raw = Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageGetItem */ "a"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS */ "e"]);

    if (raw != null) {
      return JSON.parse(raw);
    }
  } catch (error) {}

  return false;
}
function setBreakOnConsoleErrors(value) {
  Object(_storage__WEBPACK_IMPORTED_MODULE_5__[/* localStorageSetItem */ "b"])(_constants__WEBPACK_IMPORTED_MODULE_3__[/* LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS */ "e"], JSON.stringify(value));
}
function separateDisplayNameAndHOCs(displayName, type) {
  if (displayName === null) {
    return [null, null];
  }

  let hocDisplayNames = null;

  switch (type) {
    case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeClass */ "e"]:
    case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeForwardRef */ "g"]:
    case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeFunction */ "h"]:
    case react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeMemo */ "j"]:
      if (displayName.indexOf('(') >= 0) {
        const matches = displayName.match(/[^()]+/g);

        if (matches != null) {
          displayName = matches.pop();
          hocDisplayNames = matches;
        }
      }

      break;

    default:
      break;
  }

  if (type === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeMemo */ "j"]) {
    if (hocDisplayNames === null) {
      hocDisplayNames = ['Memo'];
    } else {
      hocDisplayNames.unshift('Memo');
    }
  } else if (type === react_devtools_shared_src_types__WEBPACK_IMPORTED_MODULE_4__[/* ElementTypeForwardRef */ "g"]) {
    if (hocDisplayNames === null) {
      hocDisplayNames = ['ForwardRef'];
    } else {
      hocDisplayNames.unshift('ForwardRef');
    }
  }

  return [displayName, hocDisplayNames];
} // Pulled from react-compat
// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349

function shallowDiffers(prev, next) {
  for (const attribute in prev) {
    if (!(attribute in next)) {
      return true;
    }
  }

  for (const attribute in next) {
    if (prev[attribute] !== next[attribute]) {
      return true;
    }
  }

  return false;
}
function getInObject(object, path) {
  return path.reduce((reduced, attr) => {
    if (reduced) {
      if (hasOwnProperty.call(reduced, attr)) {
        return reduced[attr];
      }

      if (typeof reduced[Symbol.iterator] === 'function') {
        // Convert iterable to array and return array[index]
        //
        // TRICKY
        // Don't use [...spread] syntax for this purpose.
        // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
        // Other types (e.g. typed arrays, Sets) will not spread correctly.
        return Array.from(reduced)[attr];
      }
    }

    return null;
  }, object);
}
function deletePathInObject(object, path) {
  const length = path.length;
  const last = path[length - 1];

  if (object != null) {
    const parent = getInObject(object, path.slice(0, length - 1));

    if (parent) {
      if (Array.isArray(parent)) {
        parent.splice(last, 1);
      } else {
        delete parent[last];
      }
    }
  }
}
function renamePathInObject(object, oldPath, newPath) {
  const length = oldPath.length;

  if (object != null) {
    const parent = getInObject(object, oldPath.slice(0, length - 1));

    if (parent) {
      const lastOld = oldPath[length - 1];
      const lastNew = newPath[length - 1];
      parent[lastNew] = parent[lastOld];

      if (Array.isArray(parent)) {
        parent.splice(lastOld, 1);
      } else {
        delete parent[lastOld];
      }
    }
  }
}
function setInObject(object, path, value) {
  const length = path.length;
  const last = path[length - 1];

  if (object != null) {
    const parent = getInObject(object, path.slice(0, length - 1));

    if (parent) {
      parent[last] = value;
    }
  }
}

/**
 * Get a enhanced/artificial type string based on the object instance
 */
function getDataType(data) {
  if (data === null) {
    return 'null';
  } else if (data === undefined) {
    return 'undefined';
  }

  if (Object(react_is__WEBPACK_IMPORTED_MODULE_1__["isElement"])(data)) {
    return 'react_element';
  }

  if (typeof HTMLElement !== 'undefined' && data instanceof HTMLElement) {
    return 'html_element';
  }

  const type = typeof data;

  switch (type) {
    case 'bigint':
      return 'bigint';

    case 'boolean':
      return 'boolean';

    case 'function':
      return 'function';

    case 'number':
      if (Number.isNaN(data)) {
        return 'nan';
      } else if (!Number.isFinite(data)) {
        return 'infinity';
      } else {
        return 'number';
      }

    case 'object':
      if (Array.isArray(data)) {
        return 'array';
      } else if (ArrayBuffer.isView(data)) {
        return hasOwnProperty.call(data.constructor, 'BYTES_PER_ELEMENT') ? 'typed_array' : 'data_view';
      } else if (data.constructor && data.constructor.name === 'ArrayBuffer') {
        // HACK This ArrayBuffer check is gross; is there a better way?
        // We could try to create a new DataView with the value.
        // If it doesn't error, we know it's an ArrayBuffer,
        // but this seems kind of awkward and expensive.
        return 'array_buffer';
      } else if (typeof data[Symbol.iterator] === 'function') {
        return data[Symbol.iterator]() === data ? 'opaque_iterator' : 'iterator';
      } else if (data.constructor && data.constructor.name === 'RegExp') {
        return 'regexp';
      } else {
        const toStringValue = Object.prototype.toString.call(data);

        if (toStringValue === '[object Date]') {
          return 'date';
        } else if (toStringValue === '[object HTMLAllCollection]') {
          return 'html_all_collection';
        }
      }

      return 'object';

    case 'string':
      return 'string';

    case 'symbol':
      return 'symbol';

    case 'undefined':
      if (Object.prototype.toString.call(data) === '[object HTMLAllCollection]') {
        return 'html_all_collection';
      }

      return 'undefined';

    default:
      return 'unknown';
  }
}
function getDisplayNameForReactElement(element) {
  const elementType = Object(react_is__WEBPACK_IMPORTED_MODULE_1__["typeOf"])(element);

  switch (elementType) {
    case react_is__WEBPACK_IMPORTED_MODULE_1__["ContextConsumer"]:
      return 'ContextConsumer';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["ContextProvider"]:
      return 'ContextProvider';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["ForwardRef"]:
      return 'ForwardRef';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Fragment"]:
      return 'Fragment';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Lazy"]:
      return 'Lazy';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Memo"]:
      return 'Memo';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Portal"]:
      return 'Portal';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Profiler"]:
      return 'Profiler';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["StrictMode"]:
      return 'StrictMode';

    case react_is__WEBPACK_IMPORTED_MODULE_1__["Suspense"]:
      return 'Suspense';

    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_2__[/* REACT_SUSPENSE_LIST_TYPE */ "b"]:
      return 'SuspenseList';

    default:
      const type = element.type;

      if (typeof type === 'string') {
        return type;
      } else if (typeof type === 'function') {
        return getDisplayName(type, 'Anonymous');
      } else if (type != null) {
        return 'NotImplementedInDevtools';
      } else {
        return 'Element';
      }

  }
}
const MAX_PREVIEW_STRING_LENGTH = 50;

function truncateForDisplay(string, length = MAX_PREVIEW_STRING_LENGTH) {
  if (string.length > length) {
    return string.substr(0, length) + 'â€¦';
  } else {
    return string;
  }
} // Attempts to mimic Chrome's inline preview for values.
// For example, the following value...
//   {
//      foo: 123,
//      bar: "abc",
//      baz: [true, false],
//      qux: { ab: 1, cd: 2 }
//   };
//
// Would show a preview of...
//   {foo: 123, bar: "abc", baz: Array(2), qux: {â€¦}}
//
// And the following value...
//   [
//     123,
//     "abc",
//     [true, false],
//     { foo: 123, bar: "abc" }
//   ];
//
// Would show a preview of...
//   [123, "abc", Array(2), {â€¦}]


function formatDataForPreview(data, showFormattedValue) {
  if (data != null && hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "d"].type)) {
    return showFormattedValue ? data[_hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "d"].preview_long] : data[_hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "d"].preview_short];
  }

  const type = getDataType(data);

  switch (type) {
    case 'html_element':
      return `<${truncateForDisplay(data.tagName.toLowerCase())} />`;

    case 'function':
      return truncateForDisplay(`Æ’ ${typeof data.name === 'function' ? '' : data.name}() {}`);

    case 'string':
      return `"${data}"`;

    case 'bigint':
      return truncateForDisplay(data.toString() + 'n');

    case 'regexp':
      return truncateForDisplay(data.toString());

    case 'symbol':
      return truncateForDisplay(data.toString());

    case 'react_element':
      return `<${truncateForDisplay(getDisplayNameForReactElement(data) || 'Unknown')} />`;

    case 'array_buffer':
      return `ArrayBuffer(${data.byteLength})`;

    case 'data_view':
      return `DataView(${data.buffer.byteLength})`;

    case 'array':
      if (showFormattedValue) {
        let formatted = '';

        for (let i = 0; i < data.length; i++) {
          if (i > 0) {
            formatted += ', ';
          }

          formatted += formatDataForPreview(data[i], false);

          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return `[${truncateForDisplay(formatted)}]`;
      } else {
        const length = hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "d"].size) ? data[_hydration__WEBPACK_IMPORTED_MODULE_6__[/* meta */ "d"].size] : data.length;
        return `Array(${length})`;
      }

    case 'typed_array':
      const shortName = `${data.constructor.name}(${data.length})`;

      if (showFormattedValue) {
        let formatted = '';

        for (let i = 0; i < data.length; i++) {
          if (i > 0) {
            formatted += ', ';
          }

          formatted += data[i];

          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return `${shortName} [${truncateForDisplay(formatted)}]`;
      } else {
        return shortName;
      }

    case 'iterator':
      const name = data.constructor.name;

      if (showFormattedValue) {
        // TRICKY
        // Don't use [...spread] syntax for this purpose.
        // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
        // Other types (e.g. typed arrays, Sets) will not spread correctly.
        const array = Array.from(data);
        let formatted = '';

        for (let i = 0; i < array.length; i++) {
          const entryOrEntries = array[i];

          if (i > 0) {
            formatted += ', ';
          } // TRICKY
          // Browsers display Maps and Sets differently.
          // To mimic their behavior, detect if we've been given an entries tuple.
          //   Map(2) {"abc" => 123, "def" => 123}
          //   Set(2) {"abc", 123}


          if (Array.isArray(entryOrEntries)) {
            const key = formatDataForPreview(entryOrEntries[0], true);
            const value = formatDataForPreview(entryOrEntries[1], false);
            formatted += `${key} => ${value}`;
          } else {
            formatted += formatDataForPreview(entryOrEntries, false);
          }

          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return `${name}(${data.size}) {${truncateForDisplay(formatted)}}`;
      } else {
        return `${name}(${data.size})`;
      }

    case 'opaque_iterator':
      {
        return data[Symbol.toStringTag];
      }

    case 'date':
      return data.toString();

    case 'object':
      if (showFormattedValue) {
        const keys = getAllEnumerableKeys(data).sort(alphaSortKeys);
        let formatted = '';

        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];

          if (i > 0) {
            formatted += ', ';
          }

          formatted += `${key.toString()}: ${formatDataForPreview(data[key], false)}`;

          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return `{${truncateForDisplay(formatted)}}`;
      } else {
        return '{â€¦}';
      }

    case 'boolean':
    case 'number':
    case 'infinity':
    case 'nan':
    case 'null':
    case 'undefined':
      return data;

    default:
      try {
        return truncateForDisplay('' + data);
      } catch (error) {
        return 'unserializable';
      }

  }
}

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return __DEBUG__; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return TREE_OPERATION_ADD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return TREE_OPERATION_REMOVE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return TREE_OPERATION_REORDER_CHILDREN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return TREE_OPERATION_UPDATE_TREE_BASE_DURATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return LOCAL_STORAGE_FILTER_PREFERENCES_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return SESSION_STORAGE_LAST_SELECTION_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return SESSION_STORAGE_RELOAD_AND_PROFILE_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return PROFILER_EXPORT_VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CHANGE_LOG_URL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return UNSUPPORTED_VERSION_URL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return COMFORTABLE_LINE_HEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return COMPACT_LINE_HEIGHT; });
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// Flip this flag to true to enable verbose console debug logging.
const __DEBUG__ = false;
const TREE_OPERATION_ADD = 1;
const TREE_OPERATION_REMOVE = 2;
const TREE_OPERATION_REORDER_CHILDREN = 3;
const TREE_OPERATION_UPDATE_TREE_BASE_DURATION = 4;
const LOCAL_STORAGE_FILTER_PREFERENCES_KEY = 'React::DevTools::componentFilters';
const SESSION_STORAGE_LAST_SELECTION_KEY = 'React::DevTools::lastSelection';
const SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = 'React::DevTools::recordChangeDescriptions';
const SESSION_STORAGE_RELOAD_AND_PROFILE_KEY = 'React::DevTools::reloadAndProfile';
const LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS = 'React::DevTools::breakOnConsoleErrors';
const LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY = 'React::DevTools::appendComponentStack';
const LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY = 'React::DevTools::traceUpdatesEnabled';
const PROFILER_EXPORT_VERSION = 4;
const CHANGE_LOG_URL = 'https://github.com/facebook/react/blob/master/packages/react-devtools/CHANGELOG.md';
const UNSUPPORTED_VERSION_URL = 'https://reactjs.org/blog/2019/08/15/new-react-devtools.html#how-do-i-get-the-old-version-back'; // HACK
//
// Extracting during build time avoids a temporarily invalid state for the inline target.
// Sometimes the inline target is rendered before root styles are applied,
// which would result in e.g. NaN itemSize being passed to react-window list.
//

let COMFORTABLE_LINE_HEIGHT;
let COMPACT_LINE_HEIGHT;

try {
  // $FlowFixMe
  const rawStyleString = __webpack_require__(64).default;

  const extractVar = varName => {
    const regExp = new RegExp(`${varName}: ([0-9]+)`);
    const match = rawStyleString.match(regExp);
    return parseInt(match[1], 10);
  };

  COMFORTABLE_LINE_HEIGHT = extractVar('comfortable-line-height-data');
  COMPACT_LINE_HEIGHT = extractVar('compact-line-height-data');
} catch (error) {
  // We can't use the Webpack loader syntax in the context of Jest,
  // so tests need some reasonably meaningful fallback value.
  COMFORTABLE_LINE_HEIGHT = 15;
  COMPACT_LINE_HEIGHT = 10;
}



/***/ }),
/* 4 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media " + item[2] + "{" + content + "}";
      } else {
        return content;
      }
    }).join("");
  }; // import a list of modules into the list


  list.i = function (modules, mediaQuery) {
    if (typeof modules === "string") modules = [[null, modules, ""]];
    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      var id = this[i][0];
      if (typeof id === "number") alreadyImportedModules[id] = true;
    }

    for (i = 0; i < modules.length; i++) {
      var item = modules[i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      //  when a module is imported multiple times with different media queries.
      //  I hope this will never occur (Hey this way we have smaller bundles)

      if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || '';
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
  return '/*# ' + data + ' */';
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(96);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(131);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return localStorageGetItem; });
/* unused harmony export localStorageRemoveItem */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return localStorageSetItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return sessionStorageGetItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return sessionStorageRemoveItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return sessionStorageSetItem; });
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function localStorageGetItem(key) {
  try {
    return localStorage.getItem(key);
  } catch (error) {
    return null;
  }
}
function localStorageRemoveItem(key) {
  try {
    localStorage.removeItem(key);
  } catch (error) {}
}
function localStorageSetItem(key, value) {
  try {
    return localStorage.setItem(key, value);
  } catch (error) {}
}
function sessionStorageGetItem(key) {
  try {
    return sessionStorage.getItem(key);
  } catch (error) {
    return null;
  }
}
function sessionStorageRemoveItem(key) {
  try {
    sessionStorage.removeItem(key);
  } catch (error) {}
}
function sessionStorageSetItem(key, value) {
  try {
    return sessionStorage.setItem(key, value);
  } catch (error) {}
}

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return meta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return dehydrate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return fillInPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return hydrate; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

const meta = {
  inspectable: Symbol('inspectable'),
  inspected: Symbol('inspected'),
  name: Symbol('name'),
  preview_long: Symbol('preview_long'),
  preview_short: Symbol('preview_short'),
  readonly: Symbol('readonly'),
  size: Symbol('size'),
  type: Symbol('type'),
  unserializable: Symbol('unserializable')
};
// This threshold determines the depth at which the bridge "dehydrates" nested data.
// Dehydration means that we don't serialize the data for e.g. postMessage or stringify,
// unless the frontend explicitly requests it (e.g. a user clicks to expand a props object).
//
// Reducing this threshold will improve the speed of initial component inspection,
// but may decrease the responsiveness of expanding objects/arrays to inspect further.
const LEVEL_THRESHOLD = 2;
/**
 * Generate the dehydrated metadata for complex object instances
 */

function createDehydrated(type, inspectable, data, cleaned, path) {
  cleaned.push(path);
  const dehydrated = {
    inspectable,
    type,
    preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
    preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
    name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name
  };

  if (type === 'array' || type === 'typed_array') {
    dehydrated.size = data.length;
  } else if (type === 'object') {
    dehydrated.size = Object.keys(data).length;
  }

  if (type === 'iterator' || type === 'typed_array') {
    dehydrated.readonly = true;
  }

  return dehydrated;
}
/**
 * Strip out complex data (instances, functions, and data nested > LEVEL_THRESHOLD levels deep).
 * The paths of the stripped out objects are appended to the `cleaned` list.
 * On the other side of the barrier, the cleaned list is used to "re-hydrate" the cleaned representation into
 * an object with symbols as attributes, so that a sanitized object can be distinguished from a normal object.
 *
 * Input: {"some": {"attr": fn()}, "other": AnInstance}
 * Output: {
 *   "some": {
 *     "attr": {"name": the fn.name, type: "function"}
 *   },
 *   "other": {
 *     "name": "AnInstance",
 *     "type": "object",
 *   },
 * }
 * and cleaned = [["some", "attr"], ["other"]]
 */


function dehydrate(data, cleaned, unserializable, path, isPathAllowed, level = 0) {
  const type = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getDataType */ "f"])(data);
  let isPathAllowedCheck;

  switch (type) {
    case 'html_element':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: data.tagName,
        type
      };

    case 'function':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: typeof data.name === 'function' || !data.name ? 'function' : data.name,
        type
      };

    case 'string':
      return data.length <= 500 ? data : data.slice(0, 500) + '...';

    case 'bigint':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: data.toString(),
        type
      };

    case 'symbol':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: data.toString(),
        type
      };
    // React Elements aren't very inspector-friendly,
    // and often contain private fields or circular references.

    case 'react_element':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getDisplayNameForReactElement */ "i"])(data) || 'Unknown',
        type
      };
    // ArrayBuffers error if you try to inspect them.

    case 'array_buffer':
    case 'data_view':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: type === 'data_view' ? 'DataView' : 'ArrayBuffer',
        size: data.byteLength,
        type
      };

    case 'array':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      }

      return data.map((item, i) => dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1));

    case 'html_all_collection':
    case 'typed_array':
    case 'iterator':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      } else {
        const unserializableValue = {
          unserializable: true,
          type: type,
          readonly: true,
          size: type === 'typed_array' ? data.length : undefined,
          preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
          preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
          name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name
        };

        if (typeof data[Symbol.iterator]) {
          // TRICKY
          // Don't use [...spread] syntax for this purpose.
          // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
          // Other types (e.g. typed arrays, Sets) will not spread correctly.
          Array.from(data).forEach((item, i) => unserializableValue[i] = dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1));
        }

        unserializable.push(path);
        return unserializableValue;
      }

    case 'opaque_iterator':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: data[Symbol.toStringTag],
        type
      };

    case 'date':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: data.toString(),
        type
      };

    case 'regexp':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, false),
        preview_long: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* formatDataForPreview */ "b"])(data, true),
        name: data.toString(),
        type
      };

    case 'object':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      } else {
        const object = {};
        Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getAllEnumerableKeys */ "c"])(data).forEach(key => {
          const name = key.toString();
          object[name] = dehydrate(data[key], cleaned, unserializable, path.concat([name]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
        });
        return object;
      }

    case 'infinity':
    case 'nan':
    case 'undefined':
      // Some values are lossy when sent through a WebSocket.
      // We dehydrate+rehydrate them to preserve their type.
      cleaned.push(path);
      return {
        type
      };

    default:
      return data;
  }
}
function fillInPath(object, data, path, value) {
  const target = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getInObject */ "j"])(object, path);

  if (target != null) {
    if (!target[meta.unserializable]) {
      delete target[meta.inspectable];
      delete target[meta.inspected];
      delete target[meta.name];
      delete target[meta.preview_long];
      delete target[meta.preview_short];
      delete target[meta.readonly];
      delete target[meta.size];
      delete target[meta.type];
    }
  }

  if (value !== null && data.unserializable.length > 0) {
    const unserializablePath = data.unserializable[0];
    let isMatch = unserializablePath.length === path.length;

    for (let i = 0; i < path.length; i++) {
      if (path[i] !== unserializablePath[i]) {
        isMatch = false;
        break;
      }
    }

    if (isMatch) {
      upgradeUnserializable(value, value);
    }
  }

  Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* setInObject */ "q"])(object, path, value);
}
function hydrate(object, cleaned, unserializable) {
  cleaned.forEach(path => {
    const length = path.length;
    const last = path[length - 1];
    const parent = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getInObject */ "j"])(object, path.slice(0, length - 1));

    if (!parent || !parent.hasOwnProperty(last)) {
      return;
    }

    const value = parent[last];

    if (value.type === 'infinity') {
      parent[last] = Infinity;
    } else if (value.type === 'nan') {
      parent[last] = NaN;
    } else if (value.type === 'undefined') {
      parent[last] = undefined;
    } else {
      // Replace the string keys with Symbols so they're non-enumerable.
      const replaced = {};
      replaced[meta.inspectable] = !!value.inspectable;
      replaced[meta.inspected] = false;
      replaced[meta.name] = value.name;
      replaced[meta.preview_long] = value.preview_long;
      replaced[meta.preview_short] = value.preview_short;
      replaced[meta.size] = value.size;
      replaced[meta.readonly] = !!value.readonly;
      replaced[meta.type] = value.type;
      parent[last] = replaced;
    }
  });
  unserializable.forEach(path => {
    const length = path.length;
    const last = path[length - 1];
    const parent = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* getInObject */ "j"])(object, path.slice(0, length - 1));

    if (!parent || !parent.hasOwnProperty(last)) {
      return;
    }

    const node = parent[last];

    const replacement = _objectSpread({}, node);

    upgradeUnserializable(replacement, node);
    parent[last] = replacement;
  });
  return object;
}

function upgradeUnserializable(destination, source) {
  Object.defineProperties(destination, {
    [meta.inspected]: {
      configurable: true,
      enumerable: false,
      value: !!source.inspected
    },
    [meta.name]: {
      configurable: true,
      enumerable: false,
      value: source.name
    },
    [meta.preview_long]: {
      configurable: true,
      enumerable: false,
      value: source.preview_long
    },
    [meta.preview_short]: {
      configurable: true,
      enumerable: false,
      value: source.preview_short
    },
    [meta.size]: {
      configurable: true,
      enumerable: false,
      value: source.size
    },
    [meta.readonly]: {
      configurable: true,
      enumerable: false,
      value: !!source.readonly
    },
    [meta.type]: {
      configurable: true,
      enumerable: false,
      value: source.type
    },
    [meta.unserializable]: {
      configurable: true,
      enumerable: false,
      value: !!source.unserializable
    }
  });
  delete destination.inspected;
  delete destination.name;
  delete destination.preview_long;
  delete destination.preview_short;
  delete destination.size;
  delete destination.readonly;
  delete destination.type;
  delete destination.unserializable;
}

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("../../node_modules/react-is/index.js");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("../../node_modules/react-dom/index.js");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(153);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(123);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(124);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(125);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(150);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(128);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate) {//  Import support https://stackoverflow.com/questions/13673346/supporting-both-commonjs-and-amd
(function (name, definition) {
  if (true) {
    module.exports = definition();
  } else {}
})("clipboard", function () {
  if (typeof document === 'undefined' || !document.addEventListener) {
    return null;
  }

  var clipboard = {};

  clipboard.copy = function () {
    var _intercept = false;
    var _data = null; // Map from data type (e.g. "text/html") to value.

    var _bogusSelection = false;

    function cleanup() {
      _intercept = false;
      _data = null;

      if (_bogusSelection) {
        window.getSelection().removeAllRanges();
      }

      _bogusSelection = false;
    }

    document.addEventListener("copy", function (e) {
      if (_intercept) {
        for (var key in _data) {
          e.clipboardData.setData(key, _data[key]);
        }

        e.preventDefault();
      }
    }); // Workaround for Safari: https://bugs.webkit.org/show_bug.cgi?id=156529

    function bogusSelect() {
      var sel = document.getSelection(); // If "nothing" is selected...

      if (!document.queryCommandEnabled("copy") && sel.isCollapsed) {
        // ... temporarily select the entire body.
        //
        // We select the entire body because:
        // - it's guaranteed to exist,
        // - it works (unlike, say, document.head, or phantom element that is
        //   not inserted into the DOM),
        // - it doesn't seem to flicker (due to the synchronous copy event), and
        // - it avoids modifying the DOM (can trigger mutation observers).
        //
        // Because we can't do proper feature detection (we already checked
        // document.queryCommandEnabled("copy") , which actually gives a false
        // negative for Blink when nothing is selected) and UA sniffing is not
        // reliable (a lot of UA strings contain "Safari"), this will also
        // happen for some browsers other than Safari. :-()
        var range = document.createRange();
        range.selectNodeContents(document.body);
        sel.removeAllRanges();
        sel.addRange(range);
        _bogusSelection = true;
      }
    }

    ;
    return function (data) {
      return new Promise(function (resolve, reject) {
        _intercept = true;

        if (typeof data === "string") {
          _data = {
            "text/plain": data
          };
        } else if (data instanceof Node) {
          _data = {
            "text/html": new XMLSerializer().serializeToString(data)
          };
        } else if (data instanceof Object) {
          _data = data;
        } else {
          reject("Invalid data type. Must be string, DOM node, or an object mapping MIME types to strings.");
        }

        function triggerCopy(tryBogusSelect) {
          try {
            if (document.execCommand("copy")) {
              // document.execCommand is synchronous: http://www.w3.org/TR/2015/WD-clipboard-apis-20150421/#integration-with-rich-text-editing-apis
              // So we can call resolve() back here.
              cleanup();
              resolve();
            } else {
              if (!tryBogusSelect) {
                bogusSelect();
                triggerCopy(true);
              } else {
                cleanup();
                throw new Error("Unable to copy. Perhaps it's not available in your browser?");
              }
            }
          } catch (e) {
            cleanup();
            reject(e);
          }
        }

        triggerCopy(false);
      });
    };
  }();

  clipboard.paste = function () {
    var _intercept = false;

    var _resolve;

    var _dataType;

    document.addEventListener("paste", function (e) {
      if (_intercept) {
        _intercept = false;
        e.preventDefault();
        var resolve = _resolve;
        _resolve = null;
        resolve(e.clipboardData.getData(_dataType));
      }
    });
    return function (dataType) {
      return new Promise(function (resolve, reject) {
        _intercept = true;
        _resolve = resolve;
        _dataType = dataType || "text/plain";

        try {
          if (!document.execCommand("paste")) {
            _intercept = false;
            reject(new Error("Unable to paste. Pasting only works in Internet Explorer at the moment."));
          }
        } catch (e) {
          _intercept = false;
          reject(new Error(e));
        }
      });
    };
  }(); // Handle IE behaviour.


  if (typeof ClipboardEvent === "undefined" && typeof window.clipboardData !== "undefined" && typeof window.clipboardData.setData !== "undefined") {
    /*! promise-polyfill 2.0.1 */
    (function (a) {
      function b(a, b) {
        return function () {
          a.apply(b, arguments);
        };
      }

      function c(a) {
        if ("object" != typeof this) throw new TypeError("Promises must be constructed via new");
        if ("function" != typeof a) throw new TypeError("not a function");
        this._state = null, this._value = null, this._deferreds = [], i(a, b(e, this), b(f, this));
      }

      function d(a) {
        var b = this;
        return null === this._state ? void this._deferreds.push(a) : void j(function () {
          var c = b._state ? a.onFulfilled : a.onRejected;
          if (null === c) return void (b._state ? a.resolve : a.reject)(b._value);
          var d;

          try {
            d = c(b._value);
          } catch (e) {
            return void a.reject(e);
          }

          a.resolve(d);
        });
      }

      function e(a) {
        try {
          if (a === this) throw new TypeError("A promise cannot be resolved with itself.");

          if (a && ("object" == typeof a || "function" == typeof a)) {
            var c = a.then;
            if ("function" == typeof c) return void i(b(c, a), b(e, this), b(f, this));
          }

          this._state = !0, this._value = a, g.call(this);
        } catch (d) {
          f.call(this, d);
        }
      }

      function f(a) {
        this._state = !1, this._value = a, g.call(this);
      }

      function g() {
        for (var a = 0, b = this._deferreds.length; b > a; a++) d.call(this, this._deferreds[a]);

        this._deferreds = null;
      }

      function h(a, b, c, d) {
        this.onFulfilled = "function" == typeof a ? a : null, this.onRejected = "function" == typeof b ? b : null, this.resolve = c, this.reject = d;
      }

      function i(a, b, c) {
        var d = !1;

        try {
          a(function (a) {
            d || (d = !0, b(a));
          }, function (a) {
            d || (d = !0, c(a));
          });
        } catch (e) {
          if (d) return;
          d = !0, c(e);
        }
      }

      var j = c.immediateFn || "function" == typeof setImmediate && setImmediate || function (a) {
        setTimeout(a, 1);
      },
          k = Array.isArray || function (a) {
        return "[object Array]" === Object.prototype.toString.call(a);
      };

      c.prototype["catch"] = function (a) {
        return this.then(null, a);
      }, c.prototype.then = function (a, b) {
        var e = this;
        return new c(function (c, f) {
          d.call(e, new h(a, b, c, f));
        });
      }, c.all = function () {
        var a = Array.prototype.slice.call(1 === arguments.length && k(arguments[0]) ? arguments[0] : arguments);
        return new c(function (b, c) {
          function d(f, g) {
            try {
              if (g && ("object" == typeof g || "function" == typeof g)) {
                var h = g.then;
                if ("function" == typeof h) return void h.call(g, function (a) {
                  d(f, a);
                }, c);
              }

              a[f] = g, 0 === --e && b(a);
            } catch (i) {
              c(i);
            }
          }

          if (0 === a.length) return b([]);

          for (var e = a.length, f = 0; f < a.length; f++) d(f, a[f]);
        });
      }, c.resolve = function (a) {
        return a && "object" == typeof a && a.constructor === c ? a : new c(function (b) {
          b(a);
        });
      }, c.reject = function (a) {
        return new c(function (b, c) {
          c(a);
        });
      }, c.race = function (a) {
        return new c(function (b, c) {
          for (var d = 0, e = a.length; e > d; d++) a[d].then(b, c);
        });
      },   true && module.exports ? module.exports = c : a.Promise || (a.Promise = c);
    })(this);

    clipboard.copy = function (data) {
      return new Promise(function (resolve, reject) {
        // IE supports string and URL types: https://msdn.microsoft.com/en-us/library/ms536744(v=vs.85).aspx
        // We only support the string type for now.
        if (typeof data !== "string" && !("text/plain" in data)) {
          throw new Error("You must provide a text/plain type.");
        }

        var strData = typeof data === "string" ? data : data["text/plain"];
        var copySucceeded = window.clipboardData.setData("Text", strData);

        if (copySucceeded) {
          resolve();
        } else {
          reject(new Error("Copying was rejected."));
        }
      });
    };

    clipboard.paste = function () {
      return new Promise(function (resolve, reject) {
        var strData = window.clipboardData.getData("Text");

        if (strData) {
          resolve(strData);
        } else {
          // The user rejected the paste request.
          reject(new Error("Pasting was rejected."));
        }
      });
    };
  }

  return clipboard;
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(67).setImmediate))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(107);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(130);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(136);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(129);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(101);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(126);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(127);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EventEmitter; });
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class EventEmitter {
  constructor() {
    _defineProperty(this, "listenersMap", new Map());
  }

  addListener(event, listener) {
    const listeners = this.listenersMap.get(event);

    if (listeners === undefined) {
      this.listenersMap.set(event, [listener]);
    } else {
      const index = listeners.indexOf(listener);

      if (index < 0) {
        listeners.push(listener);
      }
    }
  }

  emit(event, ...args) {
    const listeners = this.listenersMap.get(event);

    if (listeners !== undefined) {
      if (listeners.length === 1) {
        // No need to clone or try/catch
        const listener = listeners[0];
        listener.apply(null, args);
      } else {
        let didThrow = false;
        let caughtError = null;
        const clonedListeners = Array.from(listeners);

        for (let i = 0; i < clonedListeners.length; i++) {
          const listener = clonedListeners[i];

          try {
            listener.apply(null, args);
          } catch (error) {
            if (caughtError === null) {
              didThrow = true;
              caughtError = error;
            }
          }
        }

        if (didThrow) {
          throw caughtError;
        }
      }
    }
  }

  removeAllListeners() {
    this.listenersMap.clear();
  }

  removeListener(event, listener) {
    const listeners = this.listenersMap.get(event);

    if (listeners !== undefined) {
      const index = listeners.indexOf(listener);

      if (index >= 0) {
        listeners.splice(index, 1);
      }
    }
  }

}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
if (false) { var throwOnDirectAccess, ReactIs; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(102)();
}

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Detect Element Resize.
 * https://github.com/sdecima/javascript-detect-element-resize
 * Sebastian Decima
 *
 * Forked from version 0.5.3; includes the following modifications:
 * 1)Â Guard against unsafe 'window' and 'document' references (to support SSR).
 * 2)Â Defer initialization code via a top-level function wrapper (to support SSR).
 * 3) Avoid unnecessary reflows by not measuring size for scroll events bubbling from children.
 * 4) Add nonce for style element.
 **/

function createDetectElementResize(nonce) {
  // Check `document` and `window` in case of server-side rendering
  var _window;

  if (typeof window !== 'undefined') {
    _window = window;
  } else if (typeof self !== 'undefined') {
    _window = self;
  } else {
    _window = global;
  }

  var attachEvent = typeof document !== 'undefined' && document.attachEvent;

  if (!attachEvent) {
    var requestFrame = function () {
      var raf = _window.requestAnimationFrame || _window.mozRequestAnimationFrame || _window.webkitRequestAnimationFrame || function (fn) {
        return _window.setTimeout(fn, 20);
      };

      return function (fn) {
        return raf(fn);
      };
    }();

    var cancelFrame = function () {
      var cancel = _window.cancelAnimationFrame || _window.mozCancelAnimationFrame || _window.webkitCancelAnimationFrame || _window.clearTimeout;
      return function (id) {
        return cancel(id);
      };
    }();

    var resetTriggers = function resetTriggers(element) {
      var triggers = element.__resizeTriggers__,
          expand = triggers.firstElementChild,
          contract = triggers.lastElementChild,
          expandChild = expand.firstElementChild;
      contract.scrollLeft = contract.scrollWidth;
      contract.scrollTop = contract.scrollHeight;
      expandChild.style.width = expand.offsetWidth + 1 + 'px';
      expandChild.style.height = expand.offsetHeight + 1 + 'px';
      expand.scrollLeft = expand.scrollWidth;
      expand.scrollTop = expand.scrollHeight;
    };

    var checkTriggers = function checkTriggers(element) {
      return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;
    };

    var scrollListener = function scrollListener(e) {
      // Don't measure (which forces) reflow for scrolls that happen inside of children!
      if (e.target.className.indexOf('contract-trigger') < 0 && e.target.className.indexOf('expand-trigger') < 0) {
        return;
      }

      var element = this;
      resetTriggers(this);

      if (this.__resizeRAF__) {
        cancelFrame(this.__resizeRAF__);
      }

      this.__resizeRAF__ = requestFrame(function () {
        if (checkTriggers(element)) {
          element.__resizeLast__.width = element.offsetWidth;
          element.__resizeLast__.height = element.offsetHeight;

          element.__resizeListeners__.forEach(function (fn) {
            fn.call(element, e);
          });
        }
      });
    };
    /* Detect CSS Animations support to detect element display/re-attach */


    var animation = false,
        keyframeprefix = '',
        animationstartevent = 'animationstart',
        domPrefixes = 'Webkit Moz O ms'.split(' '),
        startEvents = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' '),
        pfx = '';
    {
      var elm = document.createElement('fakeelement');

      if (elm.style.animationName !== undefined) {
        animation = true;
      }

      if (animation === false) {
        for (var i = 0; i < domPrefixes.length; i++) {
          if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {
            pfx = domPrefixes[i];
            keyframeprefix = '-' + pfx.toLowerCase() + '-';
            animationstartevent = startEvents[i];
            animation = true;
            break;
          }
        }
      }
    }
    var animationName = 'resizeanim';
    var animationKeyframes = '@' + keyframeprefix + 'keyframes ' + animationName + ' { from { opacity: 0; } to { opacity: 0; } } ';
    var animationStyle = keyframeprefix + 'animation: 1ms ' + animationName + '; ';
  }

  var createStyles = function createStyles(doc) {
    if (!doc.getElementById('detectElementResize')) {
      //opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360
      var css = (animationKeyframes ? animationKeyframes : '') + '.resize-triggers { ' + (animationStyle ? animationStyle : '') + 'visibility: hidden; opacity: 0; } ' + '.resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',
          head = doc.head || doc.getElementsByTagName('head')[0],
          style = doc.createElement('style');
      style.id = 'detectElementResize';
      style.type = 'text/css';

      if (nonce != null) {
        style.setAttribute('nonce', nonce);
      }

      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(doc.createTextNode(css));
      }

      head.appendChild(style);
    }
  };

  var addResizeListener = function addResizeListener(element, fn) {
    if (attachEvent) {
      element.attachEvent('onresize', fn);
    } else {
      if (!element.__resizeTriggers__) {
        var doc = element.ownerDocument;

        var elementStyle = _window.getComputedStyle(element);

        if (elementStyle && elementStyle.position == 'static') {
          element.style.position = 'relative';
        }

        createStyles(doc);
        element.__resizeLast__ = {};
        element.__resizeListeners__ = [];
        (element.__resizeTriggers__ = doc.createElement('div')).className = 'resize-triggers';
        element.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div>' + '<div class="contract-trigger"></div>';
        element.appendChild(element.__resizeTriggers__);
        resetTriggers(element);
        element.addEventListener('scroll', scrollListener, true);
        /* Listen for a css animation to detect element display/re-attach */

        if (animationstartevent) {
          element.__resizeTriggers__.__animationListener__ = function animationListener(e) {
            if (e.animationName == animationName) {
              resetTriggers(element);
            }
          };

          element.__resizeTriggers__.addEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__);
        }
      }

      element.__resizeListeners__.push(fn);
    }
  };

  var removeResizeListener = function removeResizeListener(element, fn) {
    if (attachEvent) {
      element.detachEvent('onresize', fn);
    } else {
      element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);

      if (!element.__resizeListeners__.length) {
        element.removeEventListener('scroll', scrollListener, true);

        if (element.__resizeTriggers__.__animationListener__) {
          element.__resizeTriggers__.removeEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__);

          element.__resizeTriggers__.__animationListener__ = null;
        }

        try {
          element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
        } catch (e) {// Preact compat; see developit/preact-compat/issues/228
        }
      }
    }
  };

  return {
    addResizeListener: addResizeListener,
    removeResizeListener: removeResizeListener
  };
}

var classCallCheck = function classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var AutoSizer = function (_React$PureComponent) {
  inherits(AutoSizer, _React$PureComponent);

  function AutoSizer() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, AutoSizer);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = AutoSizer.__proto__ || Object.getPrototypeOf(AutoSizer)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      height: _this.props.defaultHeight || 0,
      width: _this.props.defaultWidth || 0
    }, _this._onResize = function () {
      var _this$props = _this.props,
          disableHeight = _this$props.disableHeight,
          disableWidth = _this$props.disableWidth,
          onResize = _this$props.onResize;

      if (_this._parentNode) {
        // Guard against AutoSizer component being removed from the DOM immediately after being added.
        // This can result in invalid style values which can result in NaN values if we don't handle them.
        // See issue #150 for more context.
        var _height = _this._parentNode.offsetHeight || 0;

        var _width = _this._parentNode.offsetWidth || 0;

        var _style = window.getComputedStyle(_this._parentNode) || {};

        var paddingLeft = parseInt(_style.paddingLeft, 10) || 0;
        var paddingRight = parseInt(_style.paddingRight, 10) || 0;
        var paddingTop = parseInt(_style.paddingTop, 10) || 0;
        var paddingBottom = parseInt(_style.paddingBottom, 10) || 0;
        var newHeight = _height - paddingTop - paddingBottom;
        var newWidth = _width - paddingLeft - paddingRight;

        if (!disableHeight && _this.state.height !== newHeight || !disableWidth && _this.state.width !== newWidth) {
          _this.setState({
            height: _height - paddingTop - paddingBottom,
            width: _width - paddingLeft - paddingRight
          });

          onResize({
            height: _height,
            width: _width
          });
        }
      }
    }, _this._setRef = function (autoSizer) {
      _this._autoSizer = autoSizer;
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(AutoSizer, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var nonce = this.props.nonce;

      if (this._autoSizer && this._autoSizer.parentNode && this._autoSizer.parentNode.ownerDocument && this._autoSizer.parentNode.ownerDocument.defaultView && this._autoSizer.parentNode instanceof this._autoSizer.parentNode.ownerDocument.defaultView.HTMLElement) {
        // Delay access of parentNode until mount.
        // This handles edge-cases where the component has already been unmounted before its ref has been set,
        // As well as libraries like react-lite which have a slightly different lifecycle.
        this._parentNode = this._autoSizer.parentNode; // Defer requiring resize handler in order to support server-side rendering.
        // See issue #41

        this._detectElementResize = createDetectElementResize(nonce);

        this._detectElementResize.addResizeListener(this._parentNode, this._onResize);

        this._onResize();
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this._detectElementResize && this._parentNode) {
        this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          children = _props.children,
          className = _props.className,
          disableHeight = _props.disableHeight,
          disableWidth = _props.disableWidth,
          style = _props.style;
      var _state = this.state,
          height = _state.height,
          width = _state.width; // Outer div should not force width/height since that may prevent containers from shrinking.
      // Inner component should overflow and use calculated width/height.
      // See issue #68 for more information.

      var outerStyle = {
        overflow: 'visible'
      };
      var childParams = {}; // Avoid rendering children before the initial measurements have been collected.
      // At best this would just be wasting cycles.

      var bailoutOnChildren = false;

      if (!disableHeight) {
        if (height === 0) {
          bailoutOnChildren = true;
        }

        outerStyle.height = 0;
        childParams.height = height;
      }

      if (!disableWidth) {
        if (width === 0) {
          bailoutOnChildren = true;
        }

        outerStyle.width = 0;
        childParams.width = width;
      }

      return /*#__PURE__*/Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])('div', {
        className: className,
        ref: this._setRef,
        style: _extends({}, outerStyle, style)
      }, !bailoutOnChildren && children(childParams));
    }
  }]);
  return AutoSizer;
}(react__WEBPACK_IMPORTED_MODULE_0__["PureComponent"]);

AutoSizer.defaultProps = {
  onResize: function onResize() {},
  disableHeight: false,
  disableWidth: false,
  style: {}
};
/* harmony default export */ __webpack_exports__["a"] = (AutoSizer);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34)))

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var simpleIsEqual = function simpleIsEqual(a, b) {
  return a === b;
};

/* harmony default export */ __webpack_exports__["a"] = (function (resultFn) {
  var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : simpleIsEqual;
  var lastThis = void 0;
  var lastArgs = [];
  var lastResult = void 0;
  var calledOnce = false;

  var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) {
    return isEqual(newArg, lastArgs[index]);
  };

  var result = function result() {
    for (var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++) {
      newArgs[_key] = arguments[_key];
    }

    if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {
      return lastResult;
    }

    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    lastResult = resultFn.apply(this, newArgs);
    return lastResult;
  };

  return result;
});

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(112);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 30 */,
/* 31 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(109);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(111);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(151);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 34 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(152);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';
/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */

var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */

var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
/** Used for built-in method references. */

var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */

var now = function now() {
  return root.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */


function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  wait = toNumber(wait) || 0;

  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;
    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */


function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */


function isObjectLike(value) {
  return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */


function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */


function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = throttle;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34)))

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export REACT_ELEMENT_TYPE */
/* unused harmony export REACT_PORTAL_TYPE */
/* unused harmony export REACT_FRAGMENT_TYPE */
/* unused harmony export REACT_STRICT_MODE_TYPE */
/* unused harmony export REACT_PROFILER_TYPE */
/* unused harmony export REACT_PROVIDER_TYPE */
/* unused harmony export REACT_CONTEXT_TYPE */
/* unused harmony export REACT_FORWARD_REF_TYPE */
/* unused harmony export REACT_SUSPENSE_TYPE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return REACT_SUSPENSE_LIST_TYPE; });
/* unused harmony export REACT_MEMO_TYPE */
/* unused harmony export REACT_LAZY_TYPE */
/* unused harmony export REACT_FUNDAMENTAL_TYPE */
/* unused harmony export REACT_SCOPE_TYPE */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return REACT_OPAQUE_ID_TYPE; });
/* unused harmony export REACT_DEBUG_TRACING_MODE_TYPE */
/* unused harmony export REACT_OFFSCREEN_TYPE */
/* unused harmony export REACT_LEGACY_HIDDEN_TYPE */
/* unused harmony export getIteratorFn */
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
let REACT_ELEMENT_TYPE = 0xeac7;
let REACT_PORTAL_TYPE = 0xeaca;
let REACT_FRAGMENT_TYPE = 0xeacb;
let REACT_STRICT_MODE_TYPE = 0xeacc;
let REACT_PROFILER_TYPE = 0xead2;
let REACT_PROVIDER_TYPE = 0xeacd;
let REACT_CONTEXT_TYPE = 0xeace;
let REACT_FORWARD_REF_TYPE = 0xead0;
let REACT_SUSPENSE_TYPE = 0xead1;
let REACT_SUSPENSE_LIST_TYPE = 0xead8;
let REACT_MEMO_TYPE = 0xead3;
let REACT_LAZY_TYPE = 0xead4;
let REACT_FUNDAMENTAL_TYPE = 0xead5;
let REACT_SCOPE_TYPE = 0xead7;
let REACT_OPAQUE_ID_TYPE = 0xeae0;
let REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
let REACT_OFFSCREEN_TYPE = 0xeae2;
let REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  const symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

const MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
const FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  const maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MESSAGE_TYPE_GET_SAVED_PREFERENCES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return MESSAGE_TYPE_SAVED_PREFERENCES; });
const MESSAGE_TYPE_GET_SAVED_PREFERENCES = 'React::DevTools::getSavedPreferences';
const MESSAGE_TYPE_SAVED_PREFERENCES = 'React::DevTools::savedPreferences';

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(133);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(157);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(105);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(113);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(132);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(141);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(149);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 46 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // A linked list to keep track of recently-used-ness

const Yallist = __webpack_require__(65);

const MAX = Symbol('max');
const LENGTH = Symbol('length');
const LENGTH_CALCULATOR = Symbol('lengthCalculator');
const ALLOW_STALE = Symbol('allowStale');
const MAX_AGE = Symbol('maxAge');
const DISPOSE = Symbol('dispose');
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
const LRU_LIST = Symbol('lruList');
const CACHE = Symbol('cache');
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

const naiveLength = () => 1; // lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.


class LRUCache {
  constructor(options) {
    if (typeof options === 'number') options = {
      max: options
    };
    if (!options) options = {};
    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number'); // Kind of weird to have a default max of Infinity, but oh well.

    const max = this[MAX] = options.max || Infinity;
    const lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  } // resize the cache when the max changes.


  set max(mL) {
    if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
    this[MAX] = mL || Infinity;
    trim(this);
  }

  get max() {
    return this[MAX];
  }

  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }

  get allowStale() {
    return this[ALLOW_STALE];
  }

  set maxAge(mA) {
    if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
    this[MAX_AGE] = mA;
    trim(this);
  }

  get maxAge() {
    return this[MAX_AGE];
  } // resize the cache when the lengthCalculator changes.


  set lengthCalculator(lC) {
    if (typeof lC !== 'function') lC = naiveLength;

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }

    trim(this);
  }

  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }

  get length() {
    return this[LENGTH];
  }

  get itemCount() {
    return this[LRU_LIST].length;
  }

  rforEach(fn, thisp) {
    thisp = thisp || this;

    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }

  forEach(fn, thisp) {
    thisp = thisp || this;

    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }

  keys() {
    return this[LRU_LIST].toArray().map(k => k.key);
  }

  values() {
    return this[LRU_LIST].toArray().map(k => k.value);
  }

  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));
    }

    this[CACHE] = new Map(); // hash of items by key

    this[LRU_LIST] = new Yallist(); // list of items in order of use recency

    this[LENGTH] = 0; // length of items in the list
  }

  dump() {
    return this[LRU_LIST].map(hit => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter(h => h);
  }

  dumpLru() {
    return this[LRU_LIST];
  }

  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
    const now = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }

      const node = this[CACHE].get(key);
      const item = node.value; // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking

      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
      }

      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }

    const hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.

    if (hit.length > this[MAX]) {
      if (this[DISPOSE]) this[DISPOSE](key, value);
      return false;
    }

    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }

  has(key) {
    if (!this[CACHE].has(key)) return false;
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }

  get(key) {
    return get(this, key, true);
  }

  peek(key) {
    return get(this, key, false);
  }

  pop() {
    const node = this[LRU_LIST].tail;
    if (!node) return null;
    del(this, node);
    return node.value;
  }

  del(key) {
    del(this, this[CACHE].get(key));
  }

  load(arr) {
    // reset the cache
    this.reset();
    const now = Date.now(); // A previous serialized cache has the most recent items first

    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0) // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v);else {
        const maxAge = expiresAt - now; // dont add already expired items

        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }

  prune() {
    this[CACHE].forEach((value, key) => get(this, key, false));
  }

}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key);

  if (node) {
    const hit = node.value;

    if (isStale(self, hit)) {
      del(self, node);
      if (!self[ALLOW_STALE]) return undefined;
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
        self[LRU_LIST].unshiftNode(node);
      }
    }

    return hit.value;
  }
};

const isStale = (self, hit) => {
  if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
  const diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev;
      del(self, walker);
      walker = prev;
    }
  }
};

const del = (self, node) => {
  if (node) {
    const hit = node.value;
    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
    self[LENGTH] -= hit.length;
    self[CACHE].delete(hit.key);
    self[LRU_LIST].removeNode(node);
  }
};

class Entry {
  constructor(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }

}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value;

  if (isStale(self, hit)) {
    del(self, node);
    if (!self[ALLOW_STALE]) hit = undefined;
  }

  if (hit) fn.call(thisp, hit.value, hit.key, self);
};

module.exports = LRUCache;

/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

const BATCH_DURATION = 100;

class Bridge extends _events__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] {
  constructor(wall) {
    super();

    _defineProperty(this, "_isShutdown", false);

    _defineProperty(this, "_messageQueue", []);

    _defineProperty(this, "_timeoutID", null);

    _defineProperty(this, "_wallUnlisten", null);

    _defineProperty(this, "_flush", () => {
      // This method is used after the bridge is marked as destroyed in shutdown sequence,
      // so we do not bail out if the bridge marked as destroyed.
      // It is a private method that the bridge ensures is only called at the right times.
      if (this._timeoutID !== null) {
        clearTimeout(this._timeoutID);
        this._timeoutID = null;
      }

      if (this._messageQueue.length) {
        for (let i = 0; i < this._messageQueue.length; i += 2) {
          this._wall.send(this._messageQueue[i], ...this._messageQueue[i + 1]);
        }

        this._messageQueue.length = 0; // Check again for queued messages in BATCH_DURATION ms. This will keep
        // flushing in a loop as long as messages continue to be added. Once no
        // more are, the timer expires.

        this._timeoutID = setTimeout(this._flush, BATCH_DURATION);
      }
    });

    _defineProperty(this, "overrideValueAtPath", ({
      id,
      path,
      rendererID,
      type,
      value
    }) => {
      switch (type) {
        case 'context':
          this.send('overrideContext', {
            id,
            path,
            rendererID,
            wasForwarded: true,
            value
          });
          break;

        case 'hooks':
          this.send('overrideHookState', {
            id,
            path,
            rendererID,
            wasForwarded: true,
            value
          });
          break;

        case 'props':
          this.send('overrideProps', {
            id,
            path,
            rendererID,
            wasForwarded: true,
            value
          });
          break;

        case 'state':
          this.send('overrideState', {
            id,
            path,
            rendererID,
            wasForwarded: true,
            value
          });
          break;
      }
    });

    this._wall = wall;
    this._wallUnlisten = wall.listen(message => {
      this.emit(message.event, message.payload);
    }) || null; // Temporarily support older standalone front-ends sending commands to newer embedded backends.
    // We do this because React Native embeds the React DevTools backend,
    // but cannot control which version of the frontend users use.

    this.addListener('overrideValueAtPath', this.overrideValueAtPath);
  } // Listening directly to the wall isn't advised.
  // It can be used to listen for legacy (v3) messages (since they use a different format).


  get wall() {
    return this._wall;
  }

  send(event, ...payload) {
    if (this._isShutdown) {
      console.warn(`Cannot send message "${event}" through a Bridge that has been shutdown.`);
      return;
    } // When we receive a message:
    // - we add it to our queue of messages to be sent
    // - if there hasn't been a message recently, we set a timer for 0 ms in
    //   the future, allowing all messages created in the same tick to be sent
    //   together
    // - if there *has* been a message flushed in the last BATCH_DURATION ms
    //   (or we're waiting for our setTimeout-0 to fire), then _timeoutID will
    //   be set, and we'll simply add to the queue and wait for that


    this._messageQueue.push(event, payload);

    if (!this._timeoutID) {
      this._timeoutID = setTimeout(this._flush, 0);
    }
  }

  shutdown() {
    if (this._isShutdown) {
      console.warn('Bridge was already shutdown.');
      return;
    } // Queue the shutdown outgoing message for subscribers.


    this.send('shutdown'); // Mark this bridge as destroyed, i.e. disable its public API.

    this._isShutdown = true; // Disable the API inherited from EventEmitter that can add more listeners and send more messages.
    // $FlowFixMe This property is not writable.

    this.addListener = function () {}; // $FlowFixMe This property is not writable.


    this.emit = function () {}; // NOTE: There's also EventEmitter API like `on` and `prependListener` that we didn't add to our Flow type of EventEmitter.
    // Unsubscribe this bridge incoming message listeners to be sure, and so they don't have to do that.


    this.removeAllListeners(); // Stop accepting and emitting incoming messages from the wall.

    const wallUnlisten = this._wallUnlisten;

    if (wallUnlisten) {
      wallUnlisten();
    } // Synchronously flush all queued outgoing messages.
    // At this step the subscribers' code may run in this call stack.


    do {
      this._flush();
    } while (this._messageQueue.length); // Make sure once again that there is no dangling timer.


    if (this._timeoutID !== null) {
      clearTimeout(this._timeoutID);
      this._timeoutID = null;
    }
  }

}

/* harmony default export */ __webpack_exports__["a"] = (Bridge);

/***/ }),
/* 49 */,
/* 50 */,
/* 51 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(104);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(135);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(137);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(146);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = __webpack_require__("../../node_modules/scheduler/index.js");

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(119);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(120);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(121);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(134);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(138);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(142);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(145);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(155);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (":root {\n  /**\n   * IMPORTANT: When new theme variables are added belowâ€“ also add them to SettingsContext updateThemeVariables()\n   */\n\n  /* Light theme */\n  --light-color-attribute-name: #ef6632;\n  --light-color-attribute-name-not-editable: #23272f;\n  --light-color-attribute-name-inverted: rgba(255, 255, 255, 0.7);\n  --light-color-attribute-value: #1a1aa6;\n  --light-color-attribute-value-inverted: #ffffff;\n  --light-color-attribute-editable-value: #1a1aa6;\n  --light-color-background: #ffffff;\n  --light-color-background-hover: rgba(0, 136, 250, 0.1);\n  --light-color-background-inactive: #e5e5e5;\n  --light-color-background-invalid: #fff0f0;\n  --light-color-background-selected: #0088fa;\n  --light-color-button-background: #ffffff;\n  --light-color-button-background-focus: #ededed;\n  --light-color-button: #5f6673;\n  --light-color-button-disabled: #cfd1d5;\n  --light-color-button-active: #0088fa;\n  --light-color-button-focus: #23272f;\n  --light-color-button-hover: #23272f;\n  --light-color-border: #eeeeee;\n  --light-color-commit-did-not-render-fill: #cfd1d5;\n  --light-color-commit-did-not-render-fill-text: #000000;\n  --light-color-commit-did-not-render-pattern: #cfd1d5;\n  --light-color-commit-did-not-render-pattern-text: #333333;\n  --light-color-commit-gradient-0: #37afa9;\n  --light-color-commit-gradient-1: #63b19e;\n  --light-color-commit-gradient-2: #80b393;\n  --light-color-commit-gradient-3: #97b488;\n  --light-color-commit-gradient-4: #abb67d;\n  --light-color-commit-gradient-5: #beb771;\n  --light-color-commit-gradient-6: #cfb965;\n  --light-color-commit-gradient-7: #dfba57;\n  --light-color-commit-gradient-8: #efbb49;\n  --light-color-commit-gradient-9: #febc38;\n  --light-color-commit-gradient-text: #000000;\n  --light-color-component-name: #6a51b2;\n  --light-color-component-name-inverted: #ffffff;\n  --light-color-component-badge-background: rgba(0, 0, 0, 0.1);\n  --light-color-component-badge-background-inverted: rgba(255, 255, 255, 0.25);\n  --light-color-component-badge-count: #777d88;\n  --light-color-component-badge-count-inverted: rgba(255, 255, 255, 0.7);\n  --light-color-context-background: rgba(0,0,0,.9);\n  --light-color-context-background-hover: rgba(255, 255, 255, 0.1);\n  --light-color-context-background-selected: #178fb9;\n  --light-color-context-border: #3d424a;\n  --light-color-context-text: #ffffff;\n  --light-color-context-text-selected: #ffffff;\n  --light-color-dim: #777d88;\n  --light-color-dimmer: #cfd1d5;\n  --light-color-dimmest: #eff0f1;\n  --light-color-error-background: hsl(0, 100%, 97%);\n  --light-color-error-border: hsl(0, 100%, 92%);\n  --light-color-error-text: #ff0000;\n  --light-color-expand-collapse-toggle: #777d88;\n  --light-color-link: #0000ff;\n  --light-color-modal-background: rgba(255, 255, 255, 0.75);\n  --light-color-record-active: #fc3a4b;\n  --light-color-record-hover: #3578e5;\n  --light-color-record-inactive: #0088fa;\n  --light-color-scroll-thumb: #c2c2c2;\n  --light-color-scroll-track: #fafafa;\n  --light-color-search-match: yellow;\n  --light-color-search-match-current: #f7923b;\n  --light-color-selected-tree-highlight-active: rgba(0, 136, 250, 0.1);\n  --light-color-selected-tree-highlight-inactive: rgba(0, 0, 0, 0.05);\n  --light-color-shadow: rgba(0, 0, 0, 0.25);\n  --light-color-tab-selected-border: #0088fa;\n  --light-color-text: #000000;\n  --light-color-text-invalid: #ff0000;\n  --light-color-text-selected: #ffffff;\n  --light-color-toggle-background-invalid: #fc3a4b;\n  --light-color-toggle-background-on: #0088fa;\n  --light-color-toggle-background-off: #cfd1d5;\n  --light-color-toggle-text: #ffffff;\n  --light-color-tooltip-background: rgba(0, 0, 0, 0.9);\n  --light-color-tooltip-text: #ffffff;\n\n  /* Dark theme */\n  --dark-color-attribute-name: #9d87d2;\n  --dark-color-attribute-name-not-editable: #ededed;\n  --dark-color-attribute-name-inverted: #282828;\n  --dark-color-attribute-value: #cedae0;\n  --dark-color-attribute-value-inverted: #ffffff;\n  --dark-color-attribute-editable-value: yellow;\n  --dark-color-background: #282c34;\n  --dark-color-background-hover: rgba(255, 255, 255, 0.1);\n  --dark-color-background-inactive: #3d424a;\n  --dark-color-background-invalid: #5c0000;\n  --dark-color-background-selected: #178fb9;\n  --dark-color-button-background: #282c34;\n  --dark-color-button-background-focus: #3d424a;\n  --dark-color-button: #afb3b9;\n  --dark-color-button-active: #61dafb;\n  --dark-color-button-disabled: #4f5766;\n  --dark-color-button-focus: #a2e9fc;\n  --dark-color-button-hover: #ededed;\n  --dark-color-border: #3d424a;\n  --dark-color-commit-did-not-render-fill: #777d88;\n  --dark-color-commit-did-not-render-fill-text: #000000;\n  --dark-color-commit-did-not-render-pattern: #666c77;\n  --dark-color-commit-did-not-render-pattern-text: #ffffff;\n  --dark-color-commit-gradient-0: #37afa9;\n  --dark-color-commit-gradient-1: #63b19e;\n  --dark-color-commit-gradient-2: #80b393;\n  --dark-color-commit-gradient-3: #97b488;\n  --dark-color-commit-gradient-4: #abb67d;\n  --dark-color-commit-gradient-5: #beb771;\n  --dark-color-commit-gradient-6: #cfb965;\n  --dark-color-commit-gradient-7: #dfba57;\n  --dark-color-commit-gradient-8: #efbb49;\n  --dark-color-commit-gradient-9: #febc38;\n  --dark-color-commit-gradient-text: #000000;\n  --dark-color-component-name: #61dafb;\n  --dark-color-component-name-inverted: #282828;\n  --dark-color-component-badge-background: rgba(255, 255, 255, 0.25);\n  --dark-color-component-badge-background-inverted: rgba(0, 0, 0, 0.25);\n  --dark-color-component-badge-count: #8f949d;\n  --dark-color-component-badge-count-inverted: rgba(255, 255, 255, 0.7);\n  --dark-color-context-background: rgba(255,255,255,.9);\n  --dark-color-context-background-hover: rgba(0, 136, 250, 0.1);\n  --dark-color-context-background-selected: #0088fa;\n  --dark-color-context-border: #eeeeee;\n  --dark-color-context-text: #000000;\n  --dark-color-context-text-selected: #ffffff;\n  --dark-color-dim: #8f949d;\n  --dark-color-dimmer: #777d88;\n  --dark-color-dimmest: #4f5766;\n  --dark-color-error-background: #200;\n  --dark-color-error-border: #900;\n  --dark-color-error-text: #f55;\n  --dark-color-expand-collapse-toggle: #8f949d;\n  --dark-color-link: #61dafb;\n  --dark-color-modal-background: rgba(0, 0, 0, 0.75);\n  --dark-color-record-active: #fc3a4b;\n  --dark-color-record-hover: #a2e9fc;\n  --dark-color-record-inactive: #61dafb;\n  --dark-color-scroll-thumb: #afb3b9;\n  --dark-color-scroll-track: #313640;\n  --dark-color-search-match: yellow;\n  --dark-color-search-match-current: #f7923b;\n  --dark-color-selected-tree-highlight-active: rgba(23, 143, 185, 0.15);\n  --dark-color-selected-tree-highlight-inactive: rgba(255, 255, 255, 0.05);\n  --dark-color-shadow: rgba(0, 0, 0, 0.5);\n  --dark-color-tab-selected-border: #178fb9;\n  --dark-color-text: #ffffff;\n  --dark-color-text-invalid: #ff8080;\n  --dark-color-text-selected: #ffffff;\n  --dark-color-toggle-background-invalid: #fc3a4b;\n  --dark-color-toggle-background-on: #178fb9;\n  --dark-color-toggle-background-off: #777d88;\n  --dark-color-toggle-text: #ffffff;\n  --dark-color-tooltip-background: rgba(255, 255, 255, 0.9);\n  --dark-color-tooltip-text: #000000;\n\n  /* Font smoothing */\n  --light-font-smoothing: auto;\n  --dark-font-smoothing: antialiased;\n  --font-smoothing: auto;\n\n  /* Compact density */\n  --compact-font-size-monospace-small: 9px;\n  --compact-font-size-monospace-normal: 11px;\n  --compact-font-size-monospace-large: 15px;\n  --compact-font-size-sans-small: 10px;\n  --compact-font-size-sans-normal: 12px;\n  --compact-font-size-sans-large: 14px;\n  --compact-line-height-data: 18px;\n  --compact-root-font-size: 16px;\n\n  /* Comfortable density */\n  --comfortable-font-size-monospace-small: 10px;\n  --comfortable-font-size-monospace-normal: 13px;\n  --comfortable-font-size-monospace-large: 17px;\n  --comfortable-font-size-sans-small: 12px;\n  --comfortable-font-size-sans-normal: 14px;\n  --comfortable-font-size-sans-large: 16px;\n  --comfortable-line-height-data: 22px;\n  --comfortable-root-font-size: 20px;\n\n  /* GitHub.com system fonts */\n  --font-family-monospace: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo,\n    Courier, monospace;\n  --font-family-sans: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica,\n    Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol;\n\n  /* Constant values shared between JS and CSS */\n  --interaction-commit-size: 10px;\n  --interaction-label-width: 200px;\n}\n");

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;

function Yallist(list) {
  var self = this;

  if (!(self instanceof Yallist)) {
    self = new Yallist();
  }

  self.tail = null;
  self.head = null;
  self.length = 0;

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }

  return self;
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list');
  }

  var next = node.next;
  var prev = node.prev;

  if (next) {
    next.prev = prev;
  }

  if (prev) {
    prev.next = next;
  }

  if (node === this.head) {
    this.head = next;
  }

  if (node === this.tail) {
    this.tail = prev;
  }

  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var head = this.head;
  node.list = this;
  node.next = head;

  if (head) {
    head.prev = node;
  }

  this.head = node;

  if (!this.tail) {
    this.tail = node;
  }

  this.length++;
};

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var tail = this.tail;
  node.list = this;
  node.prev = tail;

  if (tail) {
    tail.next = node;
  }

  this.tail = node;

  if (!this.head) {
    this.head = node;
  }

  this.length++;
};

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined;
  }

  var res = this.tail.value;
  this.tail = this.tail.prev;

  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined;
  }

  var res = this.head.value;
  this.head = this.head.next;

  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }

  return res;
};

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }

  return res;
};

Yallist.prototype.reduce = function (fn, initial) {
  var acc;
  var walker = this.head;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }

  return acc;
};

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc;
  var walker = this.tail;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }

  return acc;
};

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }

  return arr;
};

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }

  return arr;
};

Yallist.prototype.slice = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }

  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }

  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.splice = function (start, deleteCount
/*, ...nodes */
) {
  if (start > this.length) {
    start = this.length - 1;
  }

  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }

  var ret = [];

  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }

  if (walker === null) {
    walker = this.tail;
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }

  for (var i = 2; i < arguments.length; i++) {
    walker = insert(this, walker, arguments[i]);
  }

  return ret;
};

Yallist.prototype.reverse = function () {
  var head = this.head;
  var tail = this.tail;

  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }

  this.head = tail;
  this.tail = head;
  return this;
};

function insert(self, node, value) {
  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);

  if (inserted.next === null) {
    self.tail = inserted;
  }

  if (inserted.prev === null) {
    self.head = inserted;
  }

  self.length++;
  return inserted;
}

function push(self, item) {
  self.tail = new Node(item, self.tail, null, self);

  if (!self.head) {
    self.head = self.tail;
  }

  self.length++;
}

function unshift(self, item) {
  self.head = new Node(item, null, self.head, self);

  if (!self.tail) {
    self.tail = self.head;
  }

  self.length++;
}

function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }

  this.list = list;
  this.value = value;

  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }

  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(66)(Yallist);
} catch (er) {}

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var walker;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          walker = this.head;

        case 1:
          if (!walker) {
            _context.next = 7;
            break;
          }

          _context.next = 4;
          return walker.value;

        case 4:
          walker = walker.next;
          _context.next = 1;
          break;

        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee, this);
  });
};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(68); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34)))

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function registerImmediate(handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function onGlobalMessage(event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function registerImmediate(handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function registerImmediate(handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function registerImmediate(handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function registerImmediate(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6â€“8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34), __webpack_require__(46)))

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(99);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(106);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(110);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(116);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(139);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(143);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(147);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};

  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }

  return descriptors;
};

var formatRegExp = /%[sdj%]/g;

exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];

    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }

    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;

    switch (x) {
      case '%s':
        return String(args[i++]);

      case '%d':
        return Number(args[i++]);

      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }

      default:
        return x;
    }
  });

  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
}; // Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.


exports.deprecate = function (fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  } // Allow for deprecating things in the process of starting up.


  if (typeof process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;

exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();

  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;

      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }

  return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/


function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


function isArray(ar) {
  return Array.isArray(ar);
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = __webpack_require__(92);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */


exports.inherits = __webpack_require__(93);

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];

    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }

    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};

exports.promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }

  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  } // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.


  function callbackified() {
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();

    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }

    var self = this;

    var cb = function cb() {
      return maybeCb.apply(self, arguments);
    }; // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)


    original.apply(this, args).then(function (ret) {
      process.nextTick(cb, null, ret);
    }, function (rej) {
      process.nextTick(callbackifyOnRejected, rej, cb);
    });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}

exports.callbackify = callbackify;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(46)))

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
   true ? module.exports = factory() : undefined;
})(this, function () {
  'use strict';

  function createCommonjsModule(fn, module) {
    return module = {
      exports: {}
    }, fn(module, module.exports), module.exports;
  }

  var _global = createCommonjsModule(function (module) {
    // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
    var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
    : Function('return this')();

    if (typeof __g == 'number') {
      __g = global;
    } // eslint-disable-line no-undef

  });

  var _core = createCommonjsModule(function (module) {
    var core = module.exports = {
      version: '2.6.5'
    };

    if (typeof __e == 'number') {
      __e = core;
    } // eslint-disable-line no-undef

  });

  var _core_1 = _core.version;

  var _isObject = function _isObject(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };

  var _anObject = function _anObject(it) {
    if (!_isObject(it)) {
      throw TypeError(it + ' is not an object!');
    }

    return it;
  };

  var _fails = function _fails(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  }; // Thank's IE8 for his funny defineProperty


  var _descriptors = !_fails(function () {
    return Object.defineProperty({}, 'a', {
      get: function get() {
        return 7;
      }
    }).a != 7;
  });

  var document = _global.document; // typeof document.createElement is 'object' in old IE

  var is = _isObject(document) && _isObject(document.createElement);

  var _domCreate = function _domCreate(it) {
    return is ? document.createElement(it) : {};
  };

  var _ie8DomDefine = !_descriptors && !_fails(function () {
    return Object.defineProperty(_domCreate('div'), 'a', {
      get: function get() {
        return 7;
      }
    }).a != 7;
  }); // 7.1.1 ToPrimitive(input [, PreferredType])
  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string


  var _toPrimitive = function _toPrimitive(it, S) {
    if (!_isObject(it)) {
      return it;
    }

    var fn, val;

    if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) {
      return val;
    }

    if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) {
      return val;
    }

    if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) {
      return val;
    }

    throw TypeError("Can't convert object to primitive value");
  };

  var dP = Object.defineProperty;
  var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    _anObject(O);

    P = _toPrimitive(P, true);

    _anObject(Attributes);

    if (_ie8DomDefine) {
      try {
        return dP(O, P, Attributes);
      } catch (e) {
        /* empty */
      }
    }

    if ('get' in Attributes || 'set' in Attributes) {
      throw TypeError('Accessors not supported!');
    }

    if ('value' in Attributes) {
      O[P] = Attributes.value;
    }

    return O;
  };
  var _objectDp = {
    f: f
  };

  var _propertyDesc = function _propertyDesc(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var _hide = _descriptors ? function (object, key, value) {
    return _objectDp.f(object, key, _propertyDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var hasOwnProperty = {}.hasOwnProperty;

  var _has = function _has(it, key) {
    return hasOwnProperty.call(it, key);
  };

  var id = 0;
  var px = Math.random();

  var _uid = function _uid(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };

  var _library = false;

  var _shared = createCommonjsModule(function (module) {
    var SHARED = '__core-js_shared__';
    var store = _global[SHARED] || (_global[SHARED] = {});
    (module.exports = function (key, value) {
      return store[key] || (store[key] = value !== undefined ? value : {});
    })('versions', []).push({
      version: _core.version,
      mode: _library ? 'pure' : 'global',
      copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
    });
  });

  var _functionToString = _shared('native-function-to-string', Function.toString);

  var _redefine = createCommonjsModule(function (module) {
    var SRC = _uid('src');

    var TO_STRING = 'toString';

    var TPL = ('' + _functionToString).split(TO_STRING);

    _core.inspectSource = function (it) {
      return _functionToString.call(it);
    };

    (module.exports = function (O, key, val, safe) {
      var isFunction = typeof val == 'function';

      if (isFunction) {
        _has(val, 'name') || _hide(val, 'name', key);
      }

      if (O[key] === val) {
        return;
      }

      if (isFunction) {
        _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
      }

      if (O === _global) {
        O[key] = val;
      } else if (!safe) {
        delete O[key];

        _hide(O, key, val);
      } else if (O[key]) {
        O[key] = val;
      } else {
        _hide(O, key, val);
      } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

    })(Function.prototype, TO_STRING, function toString() {
      return typeof this == 'function' && this[SRC] || _functionToString.call(this);
    });
  });

  var _aFunction = function _aFunction(it) {
    if (typeof it != 'function') {
      throw TypeError(it + ' is not a function!');
    }

    return it;
  }; // optional / simple context binding


  var _ctx = function _ctx(fn, that, length) {
    _aFunction(fn);

    if (that === undefined) {
      return fn;
    }

    switch (length) {
      case 1:
        return function (a) {
          return fn.call(that, a);
        };

      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };

      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }

    return function ()
    /* ...args */
    {
      return fn.apply(that, arguments);
    };
  };

  var PROTOTYPE = 'prototype';

  var $export = function $export(type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
    var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
    var key, own, out, exp;

    if (IS_GLOBAL) {
      source = name;
    }

    for (key in source) {
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

      out = (own ? target : source)[key]; // bind timers to global for call from export context

      exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out; // extend global

      if (target) {
        _redefine(target, key, out, type & $export.U);
      } // export


      if (exports[key] != out) {
        _hide(exports, key, exp);
      }

      if (IS_PROTO && expProto[key] != out) {
        expProto[key] = out;
      }
    }
  };

  _global.core = _core; // type bitmap

  $export.F = 1; // forced

  $export.G = 2; // global

  $export.S = 4; // static

  $export.P = 8; // proto

  $export.B = 16; // bind

  $export.W = 32; // wrap

  $export.U = 64; // safe

  $export.R = 128; // real proto method for `library`

  var _export = $export; // 7.1.4 ToInteger

  var ceil = Math.ceil;
  var floor = Math.floor;

  var _toInteger = function _toInteger(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  }; // 7.2.1 RequireObjectCoercible(argument)


  var _defined = function _defined(it) {
    if (it == undefined) {
      throw TypeError("Can't call method on  " + it);
    }

    return it;
  }; // true  -> String#at
  // false -> String#codePointAt


  var _stringAt = function _stringAt(TO_STRING) {
    return function (that, pos) {
      var s = String(_defined(that));

      var i = _toInteger(pos);

      var l = s.length;
      var a, b;

      if (i < 0 || i >= l) {
        return TO_STRING ? '' : undefined;
      }

      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };

  var $at = _stringAt(false);

  _export(_export.P, 'String', {
    // 21.1.3.3 String.prototype.codePointAt(pos)
    codePointAt: function codePointAt(pos) {
      return $at(this, pos);
    }
  });

  var codePointAt = _core.String.codePointAt;
  var max = Math.max;
  var min = Math.min;

  var _toAbsoluteIndex = function _toAbsoluteIndex(index, length) {
    index = _toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  };

  var fromCharCode = String.fromCharCode;
  var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

  _export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
    // 21.1.2.2 String.fromCodePoint(...codePoints)
    fromCodePoint: function fromCodePoint(x) {
      var arguments$1 = arguments; // eslint-disable-line no-unused-vars

      var res = [];
      var aLen = arguments.length;
      var i = 0;
      var code;

      while (aLen > i) {
        code = +arguments$1[i++];

        if (_toAbsoluteIndex(code, 0x10ffff) !== code) {
          throw RangeError(code + ' is not a valid code point');
        }

        res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
      }

      return res.join('');
    }
  });

  var fromCodePoint = _core.String.fromCodePoint; // This is a generated file. Do not edit.

  var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
  var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
  var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
  var unicode = {
    Space_Separator: Space_Separator,
    ID_Start: ID_Start,
    ID_Continue: ID_Continue
  };
  var util = {
    isSpaceSeparator: function isSpaceSeparator(c) {
      return typeof c === 'string' && unicode.Space_Separator.test(c);
    },
    isIdStartChar: function isIdStartChar(c) {
      return typeof c === 'string' && (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c === '$' || c === '_' || unicode.ID_Start.test(c));
    },
    isIdContinueChar: function isIdContinueChar(c) {
      return typeof c === 'string' && (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9' || c === '$' || c === '_' || c === '\u200C' || c === '\u200D' || unicode.ID_Continue.test(c));
    },
    isDigit: function isDigit(c) {
      return typeof c === 'string' && /[0-9]/.test(c);
    },
    isHexDigit: function isHexDigit(c) {
      return typeof c === 'string' && /[0-9A-Fa-f]/.test(c);
    }
  };
  var source;
  var parseState;
  var stack;
  var pos;
  var line;
  var column;
  var token;
  var key;
  var root;

  var parse = function parse(text, reviver) {
    source = String(text);
    parseState = 'start';
    stack = [];
    pos = 0;
    line = 1;
    column = 0;
    token = undefined;
    key = undefined;
    root = undefined;

    do {
      token = lex(); // This code is unreachable.
      // if (!parseStates[parseState]) {
      //     throw invalidParseState()
      // }

      parseStates[parseState]();
    } while (token.type !== 'eof');

    if (typeof reviver === 'function') {
      return internalize({
        '': root
      }, '', reviver);
    }

    return root;
  };

  function internalize(holder, name, reviver) {
    var value = holder[name];

    if (value != null && typeof value === 'object') {
      for (var key in value) {
        var replacement = internalize(value, key, reviver);

        if (replacement === undefined) {
          delete value[key];
        } else {
          value[key] = replacement;
        }
      }
    }

    return reviver.call(holder, name, value);
  }

  var lexState;
  var buffer;
  var doubleQuote;
  var sign;
  var c;

  function lex() {
    lexState = 'default';
    buffer = '';
    doubleQuote = false;
    sign = 1;

    for (;;) {
      c = peek(); // This code is unreachable.
      // if (!lexStates[lexState]) {
      //     throw invalidLexState(lexState)
      // }

      var token = lexStates[lexState]();

      if (token) {
        return token;
      }
    }
  }

  function peek() {
    if (source[pos]) {
      return String.fromCodePoint(source.codePointAt(pos));
    }
  }

  function read() {
    var c = peek();

    if (c === '\n') {
      line++;
      column = 0;
    } else if (c) {
      column += c.length;
    } else {
      column++;
    }

    if (c) {
      pos += c.length;
    }

    return c;
  }

  var lexStates = {
    default: function default$1() {
      switch (c) {
        case '\t':
        case '\v':
        case '\f':
        case ' ':
        case '\u00A0':
        case '\uFEFF':
        case '\n':
        case '\r':
        case '\u2028':
        case '\u2029':
          read();
          return;

        case '/':
          read();
          lexState = 'comment';
          return;

        case undefined:
          read();
          return newToken('eof');
      }

      if (util.isSpaceSeparator(c)) {
        read();
        return;
      } // This code is unreachable.
      // if (!lexStates[parseState]) {
      //     throw invalidLexState(parseState)
      // }


      return lexStates[parseState]();
    },
    comment: function comment() {
      switch (c) {
        case '*':
          read();
          lexState = 'multiLineComment';
          return;

        case '/':
          read();
          lexState = 'singleLineComment';
          return;
      }

      throw invalidChar(read());
    },
    multiLineComment: function multiLineComment() {
      switch (c) {
        case '*':
          read();
          lexState = 'multiLineCommentAsterisk';
          return;

        case undefined:
          throw invalidChar(read());
      }

      read();
    },
    multiLineCommentAsterisk: function multiLineCommentAsterisk() {
      switch (c) {
        case '*':
          read();
          return;

        case '/':
          read();
          lexState = 'default';
          return;

        case undefined:
          throw invalidChar(read());
      }

      read();
      lexState = 'multiLineComment';
    },
    singleLineComment: function singleLineComment() {
      switch (c) {
        case '\n':
        case '\r':
        case '\u2028':
        case '\u2029':
          read();
          lexState = 'default';
          return;

        case undefined:
          read();
          return newToken('eof');
      }

      read();
    },
    value: function value() {
      switch (c) {
        case '{':
        case '[':
          return newToken('punctuator', read());

        case 'n':
          read();
          literal('ull');
          return newToken('null', null);

        case 't':
          read();
          literal('rue');
          return newToken('boolean', true);

        case 'f':
          read();
          literal('alse');
          return newToken('boolean', false);

        case '-':
        case '+':
          if (read() === '-') {
            sign = -1;
          }

          lexState = 'sign';
          return;

        case '.':
          buffer = read();
          lexState = 'decimalPointLeading';
          return;

        case '0':
          buffer = read();
          lexState = 'zero';
          return;

        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          buffer = read();
          lexState = 'decimalInteger';
          return;

        case 'I':
          read();
          literal('nfinity');
          return newToken('numeric', Infinity);

        case 'N':
          read();
          literal('aN');
          return newToken('numeric', NaN);

        case '"':
        case "'":
          doubleQuote = read() === '"';
          buffer = '';
          lexState = 'string';
          return;
      }

      throw invalidChar(read());
    },
    identifierNameStartEscape: function identifierNameStartEscape() {
      if (c !== 'u') {
        throw invalidChar(read());
      }

      read();
      var u = unicodeEscape();

      switch (u) {
        case '$':
        case '_':
          break;

        default:
          if (!util.isIdStartChar(u)) {
            throw invalidIdentifier();
          }

          break;
      }

      buffer += u;
      lexState = 'identifierName';
    },
    identifierName: function identifierName() {
      switch (c) {
        case '$':
        case '_':
        case '\u200C':
        case '\u200D':
          buffer += read();
          return;

        case '\\':
          read();
          lexState = 'identifierNameEscape';
          return;
      }

      if (util.isIdContinueChar(c)) {
        buffer += read();
        return;
      }

      return newToken('identifier', buffer);
    },
    identifierNameEscape: function identifierNameEscape() {
      if (c !== 'u') {
        throw invalidChar(read());
      }

      read();
      var u = unicodeEscape();

      switch (u) {
        case '$':
        case '_':
        case '\u200C':
        case '\u200D':
          break;

        default:
          if (!util.isIdContinueChar(u)) {
            throw invalidIdentifier();
          }

          break;
      }

      buffer += u;
      lexState = 'identifierName';
    },
    sign: function sign$1() {
      switch (c) {
        case '.':
          buffer = read();
          lexState = 'decimalPointLeading';
          return;

        case '0':
          buffer = read();
          lexState = 'zero';
          return;

        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          buffer = read();
          lexState = 'decimalInteger';
          return;

        case 'I':
          read();
          literal('nfinity');
          return newToken('numeric', sign * Infinity);

        case 'N':
          read();
          literal('aN');
          return newToken('numeric', NaN);
      }

      throw invalidChar(read());
    },
    zero: function zero() {
      switch (c) {
        case '.':
          buffer += read();
          lexState = 'decimalPoint';
          return;

        case 'e':
        case 'E':
          buffer += read();
          lexState = 'decimalExponent';
          return;

        case 'x':
        case 'X':
          buffer += read();
          lexState = 'hexadecimal';
          return;
      }

      return newToken('numeric', sign * 0);
    },
    decimalInteger: function decimalInteger() {
      switch (c) {
        case '.':
          buffer += read();
          lexState = 'decimalPoint';
          return;

        case 'e':
        case 'E':
          buffer += read();
          lexState = 'decimalExponent';
          return;
      }

      if (util.isDigit(c)) {
        buffer += read();
        return;
      }

      return newToken('numeric', sign * Number(buffer));
    },
    decimalPointLeading: function decimalPointLeading() {
      if (util.isDigit(c)) {
        buffer += read();
        lexState = 'decimalFraction';
        return;
      }

      throw invalidChar(read());
    },
    decimalPoint: function decimalPoint() {
      switch (c) {
        case 'e':
        case 'E':
          buffer += read();
          lexState = 'decimalExponent';
          return;
      }

      if (util.isDigit(c)) {
        buffer += read();
        lexState = 'decimalFraction';
        return;
      }

      return newToken('numeric', sign * Number(buffer));
    },
    decimalFraction: function decimalFraction() {
      switch (c) {
        case 'e':
        case 'E':
          buffer += read();
          lexState = 'decimalExponent';
          return;
      }

      if (util.isDigit(c)) {
        buffer += read();
        return;
      }

      return newToken('numeric', sign * Number(buffer));
    },
    decimalExponent: function decimalExponent() {
      switch (c) {
        case '+':
        case '-':
          buffer += read();
          lexState = 'decimalExponentSign';
          return;
      }

      if (util.isDigit(c)) {
        buffer += read();
        lexState = 'decimalExponentInteger';
        return;
      }

      throw invalidChar(read());
    },
    decimalExponentSign: function decimalExponentSign() {
      if (util.isDigit(c)) {
        buffer += read();
        lexState = 'decimalExponentInteger';
        return;
      }

      throw invalidChar(read());
    },
    decimalExponentInteger: function decimalExponentInteger() {
      if (util.isDigit(c)) {
        buffer += read();
        return;
      }

      return newToken('numeric', sign * Number(buffer));
    },
    hexadecimal: function hexadecimal() {
      if (util.isHexDigit(c)) {
        buffer += read();
        lexState = 'hexadecimalInteger';
        return;
      }

      throw invalidChar(read());
    },
    hexadecimalInteger: function hexadecimalInteger() {
      if (util.isHexDigit(c)) {
        buffer += read();
        return;
      }

      return newToken('numeric', sign * Number(buffer));
    },
    string: function string() {
      switch (c) {
        case '\\':
          read();
          buffer += escape();
          return;

        case '"':
          if (doubleQuote) {
            read();
            return newToken('string', buffer);
          }

          buffer += read();
          return;

        case "'":
          if (!doubleQuote) {
            read();
            return newToken('string', buffer);
          }

          buffer += read();
          return;

        case '\n':
        case '\r':
          throw invalidChar(read());

        case '\u2028':
        case '\u2029':
          separatorChar(c);
          break;

        case undefined:
          throw invalidChar(read());
      }

      buffer += read();
    },
    start: function start() {
      switch (c) {
        case '{':
        case '[':
          return newToken('punctuator', read());
        // This code is unreachable since the default lexState handles eof.
        // case undefined:
        //     return newToken('eof')
      }

      lexState = 'value';
    },
    beforePropertyName: function beforePropertyName() {
      switch (c) {
        case '$':
        case '_':
          buffer = read();
          lexState = 'identifierName';
          return;

        case '\\':
          read();
          lexState = 'identifierNameStartEscape';
          return;

        case '}':
          return newToken('punctuator', read());

        case '"':
        case "'":
          doubleQuote = read() === '"';
          lexState = 'string';
          return;
      }

      if (util.isIdStartChar(c)) {
        buffer += read();
        lexState = 'identifierName';
        return;
      }

      throw invalidChar(read());
    },
    afterPropertyName: function afterPropertyName() {
      if (c === ':') {
        return newToken('punctuator', read());
      }

      throw invalidChar(read());
    },
    beforePropertyValue: function beforePropertyValue() {
      lexState = 'value';
    },
    afterPropertyValue: function afterPropertyValue() {
      switch (c) {
        case ',':
        case '}':
          return newToken('punctuator', read());
      }

      throw invalidChar(read());
    },
    beforeArrayValue: function beforeArrayValue() {
      if (c === ']') {
        return newToken('punctuator', read());
      }

      lexState = 'value';
    },
    afterArrayValue: function afterArrayValue() {
      switch (c) {
        case ',':
        case ']':
          return newToken('punctuator', read());
      }

      throw invalidChar(read());
    },
    end: function end() {
      // This code is unreachable since it's handled by the default lexState.
      // if (c === undefined) {
      //     read()
      //     return newToken('eof')
      // }
      throw invalidChar(read());
    }
  };

  function newToken(type, value) {
    return {
      type: type,
      value: value,
      line: line,
      column: column
    };
  }

  function literal(s) {
    for (var i = 0, list = s; i < list.length; i += 1) {
      var c = list[i];
      var p = peek();

      if (p !== c) {
        throw invalidChar(read());
      }

      read();
    }
  }

  function escape() {
    var c = peek();

    switch (c) {
      case 'b':
        read();
        return '\b';

      case 'f':
        read();
        return '\f';

      case 'n':
        read();
        return '\n';

      case 'r':
        read();
        return '\r';

      case 't':
        read();
        return '\t';

      case 'v':
        read();
        return '\v';

      case '0':
        read();

        if (util.isDigit(peek())) {
          throw invalidChar(read());
        }

        return '\0';

      case 'x':
        read();
        return hexEscape();

      case 'u':
        read();
        return unicodeEscape();

      case '\n':
      case '\u2028':
      case '\u2029':
        read();
        return '';

      case '\r':
        read();

        if (peek() === '\n') {
          read();
        }

        return '';

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        throw invalidChar(read());

      case undefined:
        throw invalidChar(read());
    }

    return read();
  }

  function hexEscape() {
    var buffer = '';
    var c = peek();

    if (!util.isHexDigit(c)) {
      throw invalidChar(read());
    }

    buffer += read();
    c = peek();

    if (!util.isHexDigit(c)) {
      throw invalidChar(read());
    }

    buffer += read();
    return String.fromCodePoint(parseInt(buffer, 16));
  }

  function unicodeEscape() {
    var buffer = '';
    var count = 4;

    while (count-- > 0) {
      var c = peek();

      if (!util.isHexDigit(c)) {
        throw invalidChar(read());
      }

      buffer += read();
    }

    return String.fromCodePoint(parseInt(buffer, 16));
  }

  var parseStates = {
    start: function start() {
      if (token.type === 'eof') {
        throw invalidEOF();
      }

      push();
    },
    beforePropertyName: function beforePropertyName() {
      switch (token.type) {
        case 'identifier':
        case 'string':
          key = token.value;
          parseState = 'afterPropertyName';
          return;

        case 'punctuator':
          // This code is unreachable since it's handled by the lexState.
          // if (token.value !== '}') {
          //     throw invalidToken()
          // }
          pop();
          return;

        case 'eof':
          throw invalidEOF();
      } // This code is unreachable since it's handled by the lexState.
      // throw invalidToken()

    },
    afterPropertyName: function afterPropertyName() {
      // This code is unreachable since it's handled by the lexState.
      // if (token.type !== 'punctuator' || token.value !== ':') {
      //     throw invalidToken()
      // }
      if (token.type === 'eof') {
        throw invalidEOF();
      }

      parseState = 'beforePropertyValue';
    },
    beforePropertyValue: function beforePropertyValue() {
      if (token.type === 'eof') {
        throw invalidEOF();
      }

      push();
    },
    beforeArrayValue: function beforeArrayValue() {
      if (token.type === 'eof') {
        throw invalidEOF();
      }

      if (token.type === 'punctuator' && token.value === ']') {
        pop();
        return;
      }

      push();
    },
    afterPropertyValue: function afterPropertyValue() {
      // This code is unreachable since it's handled by the lexState.
      // if (token.type !== 'punctuator') {
      //     throw invalidToken()
      // }
      if (token.type === 'eof') {
        throw invalidEOF();
      }

      switch (token.value) {
        case ',':
          parseState = 'beforePropertyName';
          return;

        case '}':
          pop();
      } // This code is unreachable since it's handled by the lexState.
      // throw invalidToken()

    },
    afterArrayValue: function afterArrayValue() {
      // This code is unreachable since it's handled by the lexState.
      // if (token.type !== 'punctuator') {
      //     throw invalidToken()
      // }
      if (token.type === 'eof') {
        throw invalidEOF();
      }

      switch (token.value) {
        case ',':
          parseState = 'beforeArrayValue';
          return;

        case ']':
          pop();
      } // This code is unreachable since it's handled by the lexState.
      // throw invalidToken()

    },
    end: function end() {// This code is unreachable since it's handled by the lexState.
      // if (token.type !== 'eof') {
      //     throw invalidToken()
      // }
    }
  };

  function push() {
    var value;

    switch (token.type) {
      case 'punctuator':
        switch (token.value) {
          case '{':
            value = {};
            break;

          case '[':
            value = [];
            break;
        }

        break;

      case 'null':
      case 'boolean':
      case 'numeric':
      case 'string':
        value = token.value;
        break;
      // This code is unreachable.
      // default:
      //     throw invalidToken()
    }

    if (root === undefined) {
      root = value;
    } else {
      var parent = stack[stack.length - 1];

      if (Array.isArray(parent)) {
        parent.push(value);
      } else {
        parent[key] = value;
      }
    }

    if (value !== null && typeof value === 'object') {
      stack.push(value);

      if (Array.isArray(value)) {
        parseState = 'beforeArrayValue';
      } else {
        parseState = 'beforePropertyName';
      }
    } else {
      var current = stack[stack.length - 1];

      if (current == null) {
        parseState = 'end';
      } else if (Array.isArray(current)) {
        parseState = 'afterArrayValue';
      } else {
        parseState = 'afterPropertyValue';
      }
    }
  }

  function pop() {
    stack.pop();
    var current = stack[stack.length - 1];

    if (current == null) {
      parseState = 'end';
    } else if (Array.isArray(current)) {
      parseState = 'afterArrayValue';
    } else {
      parseState = 'afterPropertyValue';
    }
  } // This code is unreachable.
  // function invalidParseState () {
  //     return new Error(`JSON5: invalid parse state '${parseState}'`)
  // }
  // This code is unreachable.
  // function invalidLexState (state) {
  //     return new Error(`JSON5: invalid lex state '${state}'`)
  // }


  function invalidChar(c) {
    if (c === undefined) {
      return syntaxError("JSON5: invalid end of input at " + line + ":" + column);
    }

    return syntaxError("JSON5: invalid character '" + formatChar(c) + "' at " + line + ":" + column);
  }

  function invalidEOF() {
    return syntaxError("JSON5: invalid end of input at " + line + ":" + column);
  } // This code is unreachable.
  // function invalidToken () {
  //     if (token.type === 'eof') {
  //         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
  //     }
  //     const c = String.fromCodePoint(token.value.codePointAt(0))
  //     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)
  // }


  function invalidIdentifier() {
    column -= 5;
    return syntaxError("JSON5: invalid identifier character at " + line + ":" + column);
  }

  function separatorChar(c) {
    console.warn("JSON5: '" + formatChar(c) + "' in strings is not valid ECMAScript; consider escaping");
  }

  function formatChar(c) {
    var replacements = {
      "'": "\\'",
      '"': '\\"',
      '\\': '\\\\',
      '\b': '\\b',
      '\f': '\\f',
      '\n': '\\n',
      '\r': '\\r',
      '\t': '\\t',
      '\v': '\\v',
      '\0': '\\0',
      '\u2028': '\\u2028',
      '\u2029': '\\u2029'
    };

    if (replacements[c]) {
      return replacements[c];
    }

    if (c < ' ') {
      var hexString = c.charCodeAt(0).toString(16);
      return '\\x' + ('00' + hexString).substring(hexString.length);
    }

    return c;
  }

  function syntaxError(message) {
    var err = new SyntaxError(message);
    err.lineNumber = line;
    err.columnNumber = column;
    return err;
  }

  var stringify = function stringify(value, replacer, space) {
    var stack = [];
    var indent = '';
    var propertyList;
    var replacerFunc;
    var gap = '';
    var quote;

    if (replacer != null && typeof replacer === 'object' && !Array.isArray(replacer)) {
      space = replacer.space;
      quote = replacer.quote;
      replacer = replacer.replacer;
    }

    if (typeof replacer === 'function') {
      replacerFunc = replacer;
    } else if (Array.isArray(replacer)) {
      propertyList = [];

      for (var i = 0, list = replacer; i < list.length; i += 1) {
        var v = list[i];
        var item = void 0;

        if (typeof v === 'string') {
          item = v;
        } else if (typeof v === 'number' || v instanceof String || v instanceof Number) {
          item = String(v);
        }

        if (item !== undefined && propertyList.indexOf(item) < 0) {
          propertyList.push(item);
        }
      }
    }

    if (space instanceof Number) {
      space = Number(space);
    } else if (space instanceof String) {
      space = String(space);
    }

    if (typeof space === 'number') {
      if (space > 0) {
        space = Math.min(10, Math.floor(space));
        gap = '          '.substr(0, space);
      }
    } else if (typeof space === 'string') {
      gap = space.substr(0, 10);
    }

    return serializeProperty('', {
      '': value
    });

    function serializeProperty(key, holder) {
      var value = holder[key];

      if (value != null) {
        if (typeof value.toJSON5 === 'function') {
          value = value.toJSON5(key);
        } else if (typeof value.toJSON === 'function') {
          value = value.toJSON(key);
        }
      }

      if (replacerFunc) {
        value = replacerFunc.call(holder, key, value);
      }

      if (value instanceof Number) {
        value = Number(value);
      } else if (value instanceof String) {
        value = String(value);
      } else if (value instanceof Boolean) {
        value = value.valueOf();
      }

      switch (value) {
        case null:
          return 'null';

        case true:
          return 'true';

        case false:
          return 'false';
      }

      if (typeof value === 'string') {
        return quoteString(value, false);
      }

      if (typeof value === 'number') {
        return String(value);
      }

      if (typeof value === 'object') {
        return Array.isArray(value) ? serializeArray(value) : serializeObject(value);
      }

      return undefined;
    }

    function quoteString(value) {
      var quotes = {
        "'": 0.1,
        '"': 0.2
      };
      var replacements = {
        "'": "\\'",
        '"': '\\"',
        '\\': '\\\\',
        '\b': '\\b',
        '\f': '\\f',
        '\n': '\\n',
        '\r': '\\r',
        '\t': '\\t',
        '\v': '\\v',
        '\0': '\\0',
        '\u2028': '\\u2028',
        '\u2029': '\\u2029'
      };
      var product = '';

      for (var i = 0; i < value.length; i++) {
        var c = value[i];

        switch (c) {
          case "'":
          case '"':
            quotes[c]++;
            product += c;
            continue;

          case '\0':
            if (util.isDigit(value[i + 1])) {
              product += '\\x00';
              continue;
            }

        }

        if (replacements[c]) {
          product += replacements[c];
          continue;
        }

        if (c < ' ') {
          var hexString = c.charCodeAt(0).toString(16);
          product += '\\x' + ('00' + hexString).substring(hexString.length);
          continue;
        }

        product += c;
      }

      var quoteChar = quote || Object.keys(quotes).reduce(function (a, b) {
        return quotes[a] < quotes[b] ? a : b;
      });
      product = product.replace(new RegExp(quoteChar, 'g'), replacements[quoteChar]);
      return quoteChar + product + quoteChar;
    }

    function serializeObject(value) {
      if (stack.indexOf(value) >= 0) {
        throw TypeError('Converting circular structure to JSON5');
      }

      stack.push(value);
      var stepback = indent;
      indent = indent + gap;
      var keys = propertyList || Object.keys(value);
      var partial = [];

      for (var i = 0, list = keys; i < list.length; i += 1) {
        var key = list[i];
        var propertyString = serializeProperty(key, value);

        if (propertyString !== undefined) {
          var member = serializeKey(key) + ':';

          if (gap !== '') {
            member += ' ';
          }

          member += propertyString;
          partial.push(member);
        }
      }

      var final;

      if (partial.length === 0) {
        final = '{}';
      } else {
        var properties;

        if (gap === '') {
          properties = partial.join(',');
          final = '{' + properties + '}';
        } else {
          var separator = ',\n' + indent;
          properties = partial.join(separator);
          final = '{\n' + indent + properties + ',\n' + stepback + '}';
        }
      }

      stack.pop();
      indent = stepback;
      return final;
    }

    function serializeKey(key) {
      if (key.length === 0) {
        return quoteString(key, true);
      }

      var firstChar = String.fromCodePoint(key.codePointAt(0));

      if (!util.isIdStartChar(firstChar)) {
        return quoteString(key, true);
      }

      for (var i = firstChar.length; i < key.length; i++) {
        if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
          return quoteString(key, true);
        }
      }

      return key;
    }

    function serializeArray(value) {
      if (stack.indexOf(value) >= 0) {
        throw TypeError('Converting circular structure to JSON5');
      }

      stack.push(value);
      var stepback = indent;
      indent = indent + gap;
      var partial = [];

      for (var i = 0; i < value.length; i++) {
        var propertyString = serializeProperty(String(i), value);
        partial.push(propertyString !== undefined ? propertyString : 'null');
      }

      var final;

      if (partial.length === 0) {
        final = '[]';
      } else {
        if (gap === '') {
          var properties = partial.join(',');
          final = '[' + properties + ']';
        } else {
          var separator = ',\n' + indent;
          var properties$1 = partial.join(separator);
          final = '[\n' + indent + properties$1 + ',\n' + stepback + ']';
        }
      }

      stack.pop();
      indent = stepback;
      return final;
    }
  };

  var JSON5 = {
    parse: parse,
    stringify: stringify
  };
  var lib = JSON5;
  var es5 = lib;
  return es5;
});

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }

  return str.replace(matchOperatorsRe, '\\$&');
};

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(100);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(108);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(114);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(115);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(117);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(118);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(122);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(140);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(144);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(148);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(154);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(156);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 91 */,
/* 92 */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

/***/ }),
/* 93 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;

    var TempCtor = function TempCtor() {};

    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(95);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, "/* Used to detect in JavaScript if apps have loaded styles or not. */\n:root {\n  --reach-menu-button: 1;\n}\n\n[data-reach-menu] {\n  font-family: sans-serif;\n  display: block;\n  position: absolute;\n}\n\n[data-reach-menu-list] {\n  display: block;\n  white-space: nowrap;\n  border: solid 1px hsla(0, 0%, 0%, 0.25);\n  background: hsla(0, 100%, 100%, 0.99);\n  outline: none;\n  padding: 1rem 0;\n  font-size: 85%;\n}\n\n[data-reach-menu-item] {\n  display: block;\n}\n\n/*\n The dom structure of a MenuLink is reach-menu-item > a,\n so to target all items we can use `data-reach-menu-item`\n*/\n[data-reach-menu-item] {\n  /*\n    These are styled in one rule instead of something like a[data-reach-menu-item]\n    and li[data-reach-menu-item] so that apps don't have to fight specificity and\n    can style both li and a menu items with one rule,\n    ie: `[data-selected] { background: red; }`.\n    Otherwise they'd have to define two styles, one for a and one for li.\n  */\n\n  /* reach-menu-item */\n  cursor: pointer;\n\n  /* a */\n  display: block;\n  color: inherit;\n  font: inherit;\n  text-decoration: initial;\n\n  /* both */\n  padding: 5px 20px;\n}\n\n/* pseudo pseudo selector */\n[data-reach-menu-item][data-selected] {\n  background: hsl(211, 81%, 36%);\n  color: white;\n  outline: none;\n}\n", ""]);

// exports


/***/ }),
/* 96 */
/***/ (function(module, exports) {

/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */
module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  } // blank or null?


  if (!css || typeof css !== "string") {
    return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/"); // convert each url(...)

  /*
  This regular expression is just a way to recursively match brackets within
  a string.
  	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
     (  = Start a capturing group
       (?:  = Start a non-capturing group
           [^)(]  = Match anything that isn't a parentheses
           |  = OR
           \(  = Match a start parentheses
               (?:  = Start another non-capturing groups
                   [^)(]+  = Match anything that isn't a parentheses
                   |  = OR
                   \(  = Match a start parentheses
                       [^)(]*  = Match anything that isn't a parentheses
                   \)  = Match a end parentheses
               )  = End Group
               *\) = Match anything and then a close parens
           )  = Close non-capturing group
           *  = Match anything
        )  = Close capturing group
   \)  = Match a close parens
  	 /gi  = Get all matches, not the first.  Be case insensitive.
   */

  var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
    // strip quotes (if they exist)
    var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
      return $1;
    }).replace(/^'(.*)'$/, function (o, $1) {
      return $1;
    }); // already a full url? no change

    if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
      return fullMatch;
    } // convert the url to a full url


    var newUrl;

    if (unquotedOrigUrl.indexOf("//") === 0) {
      //TODO: should we add protocol?
      newUrl = unquotedOrigUrl;
    } else if (unquotedOrigUrl.indexOf("/") === 0) {
      // path should be relative to the base url
      newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
    } else {
      // path should be relative to current directory
      newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
    } // send back the fixed url(...)


    return "url(" + JSON.stringify(newUrl) + ")";
  }); // send back the fixed css

  return fixedCss;
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(98);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ":root {\n  --reach-tooltip: 1;\n}\n\n[data-reach-tooltip] {\n  z-index: 1;\n  pointer-events: none;\n  position: absolute;\n  padding: 0.25em 0.5em;\n  box-shadow: 2px 2px 10px hsla(0, 0%, 0%, 0.1);\n  white-space: nowrap;\n  font-size: 85%;\n  background: #f0f0f0;\n  color: #444;\n  border: solid 1px #ccc;\n}\n", ""]);

// exports


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Badge___1D92d {\n  display: inline-block;\n  background-color: var(--color-component-badge-background);\n  color: var(--color-text);\n  padding: 0.125rem 0.25rem;\n  line-height: normal;\n  border-radius: 0.125rem;\n  margin-right: 0.25rem;\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-small);\n}\n\n.ExtraLabel___ktyWc {\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-small);\n  color: var(--color-component-badge-count);\n}\n", ""]);

// exports
exports.locals = {
	"Badge": "Badge___1D92d",
	"ExtraLabel": "ExtraLabel___ktyWc"
};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".ButtonIcon___1AgYV {\n  width: 1rem;\n  height: 1rem;\n  fill: currentColor;\n}\n", ""]);

// exports
exports.locals = {
	"ButtonIcon": "ButtonIcon___1AgYV"
};

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Element___1PGUo,\n.InactiveSelectedElement___3H2V0,\n.SelectedElement___2BZuq,\n.HoveredElement___4tCuC {\n  color: var(--color-component-name);\n}\n.HoveredElement___4tCuC {\n  background-color: var(--color-background-hover);\n}\n.InactiveSelectedElement___3H2V0 {\n  background-color: var(--color-background-inactive);\n}\n\n.Wrapper___1kRcF {\n  padding: 0 0.25rem;\n  white-space: pre;\n  height: var(--line-height-data);\n  line-height: var(--line-height-data);\n  display: inline-flex;\n  align-items: center;\n  cursor: default;\n  user-select: none;\n}\n\n.ScrollAnchor___31Dc8 {\n  height: 100%;\n  width: 0;\n}\n\n.SelectedElement___2BZuq {\n  background-color: var(--color-background-selected);\n  color: var(--color-text-selected);\n\n  /* Invert colors */\n  --color-component-name: var(--color-component-name-inverted);\n  --color-text: var(--color-text-selected);\n  --color-component-badge-background: var(\n    --color-component-badge-background-inverted\n  );\n  --color-component-badge-count: var(--color-component-badge-count-inverted);\n  --color-attribute-name: var(--color-attribute-name-inverted);\n  --color-attribute-value: var(--color-attribute-value-inverted);\n  --color-expand-collapse-toggle: var(--color-component-name-inverted);\n}\n\n.KeyName___iOoVX {\n  color: var(--color-attribute-name);\n}\n\n.KeyValue___2hQzO {\n  color: var(--color-attribute-value);\n  user-select: text;\n  max-width: 100px;\n  overflow-x: hidden;\n  text-overflow: ellipsis;\n}\n\n.Highlight___OJ7Ox {\n  background-color: var(--color-search-match);\n}\n.CurrentHighlight___3RWa2 {\n  background-color: var(--color-search-match-current);\n}\n\n.ExpandCollapseToggle___3CxPD {\n  display: inline-flex;\n  width: 1rem;\n  height: 1rem;\n  flex: 0 0 1rem;\n  color: var(--color-expand-collapse-toggle);\n}\n\n.Badge___36OB- {\n  margin-left: 0.25rem;\n}\n", ""]);

// exports
exports.locals = {
	"Element": "Element___1PGUo",
	"InactiveSelectedElement": "InactiveSelectedElement___3H2V0",
	"SelectedElement": "SelectedElement___2BZuq",
	"HoveredElement": "HoveredElement___4tCuC",
	"Wrapper": "Wrapper___1kRcF",
	"ScrollAnchor": "ScrollAnchor___31Dc8",
	"KeyName": "KeyName___iOoVX",
	"KeyValue": "KeyValue___2hQzO",
	"Highlight": "Highlight___OJ7Ox",
	"CurrentHighlight": "CurrentHighlight___3RWa2",
	"ExpandCollapseToggle": "ExpandCollapseToggle___3CxPD",
	"Badge": "Badge___36OB-"
};

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var ReactPropTypesSecret = __webpack_require__(103);

function emptyFunction() {}

function emptyFunctionWithReset() {}

emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }

    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
    err.name = 'Invariant Violation';
    throw err;
  }

  ;
  shim.isRequired = shim;

  function getShim() {
    return shim;
  }

  ; // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.

  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
module.exports = ReactPropTypesSecret;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".ToggleDisabled___iQeZ3,\n.ToggleOn___3XJTo,\n.ToggleOff___142SC {\n  background: var(--color-button-background);\n  border: none;\n  border-radius: 0.25rem;\n  padding: 0;\n  flex: 0 0 auto;\n}\n\n.ToggleContent___1C-vg {\n  display: inline-flex;\n  align-items: center;\n  border-radius: 0.25rem;\n  padding: 0.25rem;\n}\n\n.ToggleOff___142SC {\n  border: none;\n  background: var(--color-button-background);\n  color: var(--color-button);\n}\n.ToggleOff___142SC:hover {\n  color: var(--color-button-hover);\n}\n\n.ToggleOn___3XJTo,\n.ToggleOn___3XJTo:active {\n  color: var(--color-button-active);\n  outline: none;\n}\n\n.ToggleOn___3XJTo:focus,\n.ToggleOff___142SC:focus,\n.ToggleContent___1C-vg:focus {\n  outline: none;\n}\n\n.ToggleOn___3XJTo:focus > .ToggleContent___1C-vg,\n.ToggleOff___142SC:focus > .ToggleContent___1C-vg {\n  background: var(--color-button-background-focus);\n}\n\n.ToggleDisabled___iQeZ3 {\n  background: var(--color-button-background);\n  color: var(--color-button-disabled);\n  cursor: default;\n}\n\n.Input___ESX-3 {\n  width: 0;\n  margin: 0;\n  opacity: 0;\n}\n", ""]);

// exports
exports.locals = {
	"ToggleDisabled": "ToggleDisabled___iQeZ3",
	"ToggleOn": "ToggleOn___3XJTo",
	"ToggleOff": "ToggleOff___142SC",
	"ToggleContent": "ToggleContent___1C-vg",
	"Input": "Input___ESX-3"
};

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Tooltip___3QR8H {\n  border: none;\n  border-radius: 0.25rem;\n  padding: 0.25rem 0.5rem;\n  font-family: var(--font-family-sans);\n  font-size: 12px;\n  background-color: var(--color-tooltip-background);\n  color: var(--color-tooltip-text);\n\n  /* Make sure this is above the DevTools, which are above the Overlay */\n  z-index: 10000002;\n}\n", ""]);

// exports
exports.locals = {
	"Tooltip": "Tooltip___3QR8H"
};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Button___1-PiG {\n  border: none;\n  background: var(--color-button-background);\n  color: var(--color-button);\n  padding: 0;\n  border-radius: 0.25rem;\n  flex: 0 0 auto;\n}\n.ButtonContent___2mZ9q {\n  display: inline-flex;\n  align-items: center;\n  border-radius: 0.25rem;\n  padding: 0.25rem;\n}\n\n.Button___1-PiG:hover {\n  color: var(--color-button-hover);\n}\n.Button___1-PiG:active {\n  color: var(--color-button-focus);\n  outline: none;\n}\n.Button___1-PiG:focus,\n.ButtonContent___2mZ9q:focus {\n  outline: none;\n}\n\n.Button___1-PiG:focus > .ButtonContent___2mZ9q {\n  background: var(--color-button-background-focus);\n}\n\n.Button___1-PiG:disabled,\n.Button___1-PiG:disabled:active {\n  background: var(--color-button-background);\n  color: var(--color-button-disabled);\n  cursor: default;\n}\n", ""]);

// exports
exports.locals = {
	"Button": "Button___1-PiG",
	"ButtonContent": "ButtonContent___2mZ9q"
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".OwnerStack___32qwj {\n  max-width: 100%;\n  overflow-x: auto;\n  flex: 1;\n  display: flex;\n  align-items: center;\n  position: relative;\n}\n\n.Component___3e3s7,\n.Component___3e3s7[data-reach-menu-item] {\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n  user-select: none;\n  white-space: nowrap;\n  display: flex;\n  align-items: center;\n}\n\n.Component___3e3s7[data-reach-menu-item][data-selected],\n.Component___3e3s7[data-reach-menu-item][data-selected]:hover {\n  color: var(--color-text-selected);\n  background: var(--color-background-selected);\n}\n.Component___3e3s7[data-reach-menu-item][data-selected]:focus {\n  outline: none;\n}\n\n.Bar___3G3dX {\n  display: flex;\n  flex: 1 1 auto;\n  overflow-x: auto;\n}\n\n.VRule___IJYKJ {\n  flex: 0 0 auto;\n  height: 20px;\n  width: 1px;\n  background-color: var(--color-border);\n  margin: 0 0.5rem;\n}\n\n.MenuButton___3te3U {\n  border-radius: 0.25rem;\n  display: inline-flex;\n  align-items: center;\n  padding: 0;\n  flex: 0 0 auto;\n  border: none;\n  background: var(--color-button-background);\n  color: var(--color-button);\n}\n.MenuButtonContent___3VvHH {\n  display: inline-flex;\n  align-items: center;\n  border-radius: 0.25rem;\n  padding: 0.25rem;\n}\n.MenuButton___3te3U:hover {\n  color: var(--color-button-hover);\n}\n.MenuButton___3te3U[aria-expanded='true'],\n.MenuButton___3te3U[aria-expanded='true']:active {\n  color: var(--color-button-active);\n  outline: none;\n}\n\n.MenuButton___3te3U:focus,\n.MenuButtonContent___3VvHH:focus {\n  outline: none;\n}\n.MenuButton___3te3U:focus > .MenuButtonContent___3VvHH {\n  background: var(--color-button-background-focus);\n}\n\n.Modal___8b8bs[data-reach-menu-list] {\n  display: inline-flex;\n  flex-direction: column;\n  background-color: var(--color-background);\n  color: var(--color-button);\n  padding: 0.25rem 0;\n  padding-right: 0;\n  border: 1px solid var(--color-border);\n  border-radius: 0.25rem;\n  max-height: 10rem;\n  overflow: auto;\n\n  /* Make sure this is above the DevTools, which are above the Overlay */\n  z-index: 10000002;\n  position: relative;\n\n  /* Reach UI tries to set its own :( */\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n}\n\n.NotInStore___3Y2P2,\n.NotInStore___3Y2P2:hover {\n  color: var(--color-dimmest);\n}\n\n.Badge___2E6aT {\n  margin-left: 0.25rem;\n}\n", ""]);

// exports
exports.locals = {
	"OwnerStack": "OwnerStack___32qwj",
	"Component": "Component___3e3s7",
	"Bar": "Bar___3G3dX",
	"VRule": "VRule___IJYKJ",
	"MenuButton": "MenuButton___3te3U",
	"MenuButtonContent": "MenuButtonContent___3VvHH",
	"Modal": "Modal___8b8bs",
	"NotInStore": "NotInStore___3Y2P2",
	"Badge": "Badge___2E6aT"
};

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Icon___v5HwN {\n  width: 1rem;\n  height: 1rem;\n  fill: currentColor;\n}\n", ""]);

// exports
exports.locals = {
	"Icon": "Icon___v5HwN"
};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".SearchInput___3_D7A {\n  flex: 1 1;\n  display: flex;\n  align-items: center;\n}\n\n.Input___3Kf09 {\n  flex: 1 1 100px;\n  width: 100px;\n  font-size: var(--font-size-sans-large);\n  outline: none;\n  border: none;\n  background-color: var(--color-background);\n  color: var(--color-text);\n  padding-left: 1.5rem;\n  margin-left: -1rem;\n}\n\n.InputIcon___1HrXN {\n  pointer-events: none;\n  z-index: 2;\n  color: var(--color-dimmer);\n}\n\n.IndexLabel___2cd8c {\n  color: var(--color-dim);\n  font-size: var(--font-size-sans-normal);\n  white-space: pre;\n}\n\n.LeftVRule___wcxjb,\n.RightVRule___cvpx8 {\n  height: 20px;\n  width: 1px;\n  background-color: var(--color-border);\n}\n.LeftVRule___wcxjb {\n  margin: 0 0.25rem 0 0.5rem;\n}\n.RightVRule___cvpx8 {\n  margin: 0 0.5rem 0 0.25rem;\n}\n", ""]);

// exports
exports.locals = {
	"SearchInput": "SearchInput___3_D7A",
	"Input": "Input___3Kf09",
	"InputIcon": "InputIcon___1HrXN",
	"IndexLabel": "IndexLabel___2cd8c",
	"LeftVRule": "LeftVRule___wcxjb",
	"RightVRule": "RightVRule___cvpx8"
};

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Active___3Y5D2,\n.Inactive___2Ddkx {\n  position: absolute;\n  left: 0;\n  width: 100%;\n  z-index: 0;\n  pointer-events: none;\n}\n\n.Active___3Y5D2 {\n  background-color: var(--color-selected-tree-highlight-active);\n}\n\n.Inactive___2Ddkx {\n  background-color: var(--color-selected-tree-highlight-inactive);\n}\n", ""]);

// exports
exports.locals = {
	"Active": "Active___3Y5D2",
	"Inactive": "Inactive___2Ddkx"
};

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Tree___3Pjje {\n  position: relative;\n  height: 100%;\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n  border-top: 1px solid var(--color-border);\n\n  /* Default size will be adjusted by Tree after scrolling */\n  --indentation-size: 12px;\n}\n\n.List___qlOJG {\n  overflow-x: hidden !important;\n}\n\n.InnerElementType___1csGF {\n  overflow-x: hidden;\n}\n\n.SearchInput___1Q2I_ {\n  flex: 0 0 42px;\n  display: flex;\n  align-items: center;\n  border-bottom: 1px solid var(--color-border);\n  padding: 0.5rem;\n}\n\n.AutoSizerWrapper___3IcMr {\n  width: 100%;\n  overflow: hidden;\n  flex: 1 0 auto;\n}\n.AutoSizerWrapper___3IcMr:focus {\n  outline: none;\n}\n\n.List___qlOJG {\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n  line-height: var(--line-height-data);\n}\n\n.VRule___3yG5q {\n  height: 20px;\n  width: 1px;\n  margin: 0 0.5rem;\n  background-color: var(--color-border);\n}\n\n.Loading___TrqnR {\n  height: 100%;\n  padding-left: 0.5rem;\n  display: flex;\n  align-items: center;\n  flex: 1;\n  justify-content: flex-start;\n  font-size: var(--font-size-sans-large);\n  color: var(--color-dim);\n}\n", ""]);

// exports
exports.locals = {
	"Tree": "Tree___3Pjje",
	"List": "List___qlOJG",
	"InnerElementType": "InnerElementType___1csGF",
	"SearchInput": "SearchInput___1Q2I_",
	"AutoSizerWrapper": "AutoSizerWrapper___3IcMr",
	"VRule": "VRule___3yG5q",
	"Loading": "Loading___TrqnR"
};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".ErrorBoundary___24NcV {\n  height: 100%;\n  width: 100%;\n  background-color: var(--color-background);\n  padding: 0.5rem;\n  overflow: auto;\n}\n\n.Header___8LGXN {\n  font-size: var(--font-size-sans-large);\n  font-weight: bold;\n  color: var(--color-error-text);\n}\n\n.Stack___3-PTh {\n  margin-top: 0.5rem;\n  white-space: pre-wrap;\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n  -webkit-font-smoothing: initial;\n  background-color: var(--color-error-background);\n  border: 1px solid var(--color-error-border);\n  color: var(--color-error-text);\n  border-radius: 0.25rem;\n  padding: 0.5rem;\n}\n\n.IconAndLinkRow___orFpO {\n  display: flex;\n  align-items: center;\n  margin-top: 0.5rem;\n  color: var(--color-text);\n}\n\n.RetryIcon___274aX {\n  margin-right: 0.25rem;\n  color: var(--color-button-active);\n}\n\n.RetryButton___2tkCs {\n  margin-right: 0.25rem;\n  color: var(--color-text);\n}\n.RetryButton___2tkCs:hover {\n  color: var(--color-button-hover);\n}\n\n.ReportIcon___1KI7p {\n  margin-right: 0.25rem;\n}\n\n.ReportLink___vHb7P {\n  color: var(--color-link);\n}", ""]);

// exports
exports.locals = {
	"ErrorBoundary": "ErrorBoundary___24NcV",
	"Header": "Header___8LGXN",
	"Stack": "Stack___3-PTh",
	"IconAndLinkRow": "IconAndLinkRow___orFpO",
	"RetryIcon": "RetryIcon___274aX",
	"RetryButton": "RetryButton___2tkCs",
	"ReportIcon": "ReportIcon___1KI7p",
	"ReportLink": "ReportLink___vHb7P"
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Background___39iOi {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: flex-start;\n  justify-content: center;\n  padding: 1rem;\n  background-color: var(--color-modal-background);\n  overflow: auto;\n}\n\n.Dialog___2XI77 {\n  position: relative;\n  z-index: 3;\n  width: 25rem;\n  min-width: 20rem;\n  max-width: 100%;\n  display: inline-block;\n  background-color: var(--color-background);\n  box-shadow: 0 2px 4px var(--color-shadow);\n  padding: 0.5rem;\n  border: 1px solid var(--color-border);\n  border-radius: 0.25rem;\n  font-size: var(--font-size-sans-normal);\n}\n\n.Title___1FtK3 {\n  font-size: var(--font-size-sans-large);\n  margin-bottom: 0.5rem;\n}\n\n.Buttons___3N6w8 {\n  text-align: right;\n  margin-top: 0.5rem;\n}\n\n.Button___3JNc2 {\n  font-size: var(--font-size-sans-large);\n}\n", ""]);

// exports
exports.locals = {
	"Background": "Background___39iOi",
	"Dialog": "Dialog___2XI77",
	"Title": "Title___1FtK3",
	"Buttons": "Buttons___3N6w8",
	"Button": "Button___3JNc2"
};

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".ContextMenu___3Zn8W {\n  position: absolute;\n  background-color: var(--color-context-background);\n  border-radius: 0.25rem;\n  overflow: hidden;\n  z-index: 10000002;\n}", ""]);

// exports
exports.locals = {
	"ContextMenu": "ContextMenu___3Zn8W"
};

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".ContextMenuItem___21C_r {\n  display: flex;\n  align-items: center;\n  color: var(--color-context-text);\n  padding: 0.5rem 0.75rem;\n  cursor: default;\n  border-top: 1px solid var(--color-context-border);\n  font-family: var(--font-family-sans);\n  font-size: var(--font-size-sans-normal);\n}\n.ContextMenuItem___21C_r:first-of-type {\n  border-top: none;\n}\n.ContextMenuItem___21C_r:hover,\n.ContextMenuItem___21C_r:focus {\n  outline: 0;\n  background-color: var(--color-context-background-hover);\n}\n.ContextMenuItem___21C_r:active {\n  background-color: var(--color-context-background-selected);\n  color: var(--color-context-text-selected);\n}", ""]);

// exports
exports.locals = {
	"ContextMenuItem": "ContextMenuItem___21C_r"
};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".HocBadges___3V-9f {\n  padding: 0.125rem 0.25rem;\n  user-select: none;\n}\n\n.Badge___yfw97 {\n  display: inline-block;\n  background-color: var(--color-component-badge-background);\n  color: var(--color-text);\n  padding: 0.125rem 0.25rem;\n  line-height: normal;\n  border-radius: 0.125rem;\n  margin-right: 0.25rem;\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-small);\n}\n", ""]);

// exports
exports.locals = {
	"HocBadges": "HocBadges___3V-9f",
	"Badge": "Badge___yfw97"
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Input___2Lqoc {\n  min-width: 0.5rem;\n  flex: 1 1 auto;\n  border: none;\n  background: transparent;\n  outline: none;\n  padding: 0;\n  border: none;\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n}\n\n.Input___2Lqoc:focus {\n  border-color: var(--color-border);\n}\n", ""]);

// exports
exports.locals = {
	"Input": "Input___2Lqoc"
};

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Input___2v7pX {\n  flex: 0 1 auto;\n  box-shadow: 0px 1px 3px transparent;\n  color: var(--color-text);\n}\n.Input___2v7pX:focus {\n  color: var(--color-text);\n  box-shadow: 0px 1px 3px var(--color-shadow);\n}", ""]);

// exports
exports.locals = {
	"Input": "Input___2v7pX"
};

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Checkbox___S8zDe {\n  flex: 0 0 auto;\n  align-self: center;\n  margin: 0 0.25rem;\n}\n\n.Input___54okB {\n  flex: 1 1;\n  background: none;\n  border: 1px solid transparent;\n  color: var(--color-attribute-editable-value);\n  border-radius: 0.125rem;\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n}\n\n.Invalid___AR4Hd {\n  flex: 1 1;\n  background: none;\n  border: 1px solid transparent;\n  color: var(--color-attribute-editable-value);\n  border-radius: 0.125rem;\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n  background-color: var(--color-background-invalid);\n  color: var(--color-text-invalid);\n\n  --color-border: var(--color-text-invalid);\n}\n\n.Input___54okB:focus,\n.Invalid___AR4Hd:focus {\n  background-color: var(--color-button-background-focus);\n  outline: none;\n}\n\n.ResetButton___k3gxk {\n  flex: 0 0 auto;\n  padding: 0 0.5rem;\n}\n", ""]);

// exports
exports.locals = {
	"Checkbox": "Checkbox___S8zDe",
	"Input": "Input___54okB",
	"Invalid": "Invalid___AR4Hd",
	"ResetButton": "ResetButton___k3gxk"
};

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".NewArrayValue___3rHoU {\n  white-space: nowrap;\n  display: flex;\n  align-items: center;\n}\n\n.EditableName___3OJ36 {\n  margin-left: 1rem;\n}\n\n.Invalid___1sVw9 {\n  background-color: var(--color-background-invalid);\n  color: var(--color-text-invalid) !important;\n}\n\n.Input___1SYGr:focus,\n.Invalid___1sVw9:focus {\n  background-color: var(--color-button-background-focus);\n}", ""]);

// exports
exports.locals = {
	"NewArrayValue": "NewArrayValue___3rHoU",
	"EditableName": "EditableName___3OJ36",
	"Invalid": "Invalid___1sVw9",
	"Input": "Input___1SYGr"
};

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".NewKeyValue___34r7B {\n  white-space: nowrap;\n  display: flex;\n  align-items: center;\n}\n\n.EditableName___2W--L {\n  margin-left: 1rem;\n}\n\n.EditableValue___16Q0K {\n  min-width: 1rem;\n}\n", ""]);

// exports
exports.locals = {
	"NewKeyValue": "NewKeyValue___34r7B",
	"EditableName": "EditableName___2W--L",
	"EditableValue": "EditableValue___16Q0K"
};

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".ExpandCollapseToggle___1eSq5 {\n  flex: 0 0 1rem;\n  width: 1rem;\n  height: 1rem;\n  padding: 0;\n  color: var(--color-expand-collapse-toggle);\n}\n", ""]);

// exports
exports.locals = {
	"ExpandCollapseToggle": "ExpandCollapseToggle___1eSq5"
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Item___2n2qv:not([hidden]) {\n  display: flex;\n}\n\n.Name___3LSJX {\n  color: var(--color-attribute-name-not-editable);\n  flex: 0 0 auto;\n  cursor: default;\n}\n.EditableName___2TyRo {\n  color: var(--color-attribute-name);\n  flex: 0 0 auto;\n  cursor: default;\n}\n\n.AfterName___1HlGw {\n  color: var(--color-text);\n  margin-right: 0.5rem;\n}\n\n.Value___7p123 {\n  color: var(--color-attribute-value);\n  white-space: pre;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  cursor: default;\n}\n\n.None___RYyex {\n  color: var(--color-dimmer);\n  font-style: italic;\n}\n\n.ExpandCollapseToggleSpacer___3KNWO {\n  flex: 0 0 1rem;\n  width: 1rem;\n}\n\n.Empty___1MaDj {\n  color: var(--color-dimmer);\n}\n\n.DeleteArrayItemButton___1R-pd {\n  padding: 0;\n  margin-right: 0.125rem;\n}", ""]);

// exports
exports.locals = {
	"Item": "Item___2n2qv",
	"Name": "Name___3LSJX",
	"EditableName": "EditableName___2TyRo",
	"AfterName": "AfterName___1HlGw",
	"Value": "Value___7p123",
	"None": "None___RYyex",
	"ExpandCollapseToggleSpacer": "ExpandCollapseToggleSpacer___3KNWO",
	"Empty": "Empty___1MaDj",
	"DeleteArrayItemButton": "DeleteArrayItemButton___1R-pd"
};

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".InspectedElementTree___2_4hD {\n  padding: 0.25rem;\n  border-top: 1px solid var(--color-border);\n}\n.InspectedElementTree___2_4hD:first-of-type {\n  border-top: none;\n}\n\n.HeaderRow___3I5kU {\n  display: flex;\n  align-items: center;\n}\n\n.Header___2LZLy {\n  flex: 1 1;\n  font-family: var(--font-family-sans);\n}\n\n.Item___3t7sh {\n  display: flex;\n}\n\n.Name___6619F {\n  color: var(--color-attribute-name);\n  flex: 0 0 auto;\n}\n.Name___6619F:after {\n  content: ': ';\n  color: var(--color-text);\n  margin-right: 0.5rem;\n}\n\n.Value___na2y1 {\n  color: var(--color-attribute-value);\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.None___1ezJC {\n  color: var(--color-dimmer);\n  font-style: italic;\n}\n\n.Empty___2hAqe {\n  color: var(--color-dimmer);\n  font-style: italic;\n  padding-left: 0.75rem;\n}\n\n.ToggleSuspenseRow___3Abo4 {\n  padding-left: 1rem;\n  white-space: nowrap;\n  display: flex;\n  align-items: center;\n}\n\n.EditableValue___2B5lx {\n  min-width: 1rem;\n}\n", ""]);

// exports
exports.locals = {
	"InspectedElementTree": "InspectedElementTree___2_4hD",
	"HeaderRow": "HeaderRow___3I5kU",
	"Header": "Header___2LZLy",
	"Item": "Item___3t7sh",
	"Name": "Name___6619F",
	"Value": "Value___na2y1",
	"None": "None___1ezJC",
	"Empty": "Empty___2hAqe",
	"ToggleSuspenseRow": "ToggleSuspenseRow___3Abo4",
	"EditableValue": "EditableValue___2B5lx"
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".HooksTreeView___3YmZw {\n  padding: 0.25rem;\n  border-top: 1px solid var(--color-border);\n}\n\n.Hook___SbvM_ {\n}\n\n.Children___1f8xt {\n  padding-left: 1rem;\n}\n\n.HeaderRow___37mMe {\n  display: flex;\n  align-items: center;\n}\n\n.Header___9n-jL {\n  flex: 1 1;\n  font-family: var(--font-family-sans);\n}\n\n.NameValueRow___1dbuI {\n  display: flex;\n}\n\n.Name___3oYR1,\n.NameAnonymous___W-cy2 {\n  flex: 0 0 auto;\n  cursor: default;\n}\n.Name___3oYR1 {\n  color: var(--color-dim);\n}\n.NameAnonymous___W-cy2 {\n  color: var(--color-dimmer);\n}\n\n.EditableName___1m4Hy {\n  color: var(--color-attribute-name);\n  flex: 0 0 auto;\n  cursor: default;\n}\n.EditableName___1m4Hy:after,\n.Name___3oYR1:after {\n  color: var(--color-text);\n  content: ': ';\n  margin-right: 0.5rem;\n}\n\n.Value___3tDyC {\n  color: var(--color-attribute-value);\n  overflow: hidden;\n  text-overflow: ellipsis;\n  cursor: default;\n  white-space: nowrap;\n}\n\n.None___dHntG {\n  color: var(--color-dimmer);\n  font-style: italic;\n}\n\n.TruncationIndicator___fImBc {\n  color: var(--color-dimmer);\n}\n\n.ExpandCollapseToggleSpacer___2RAvX {\n  flex: 0 0 1rem;\n  width: 1rem;\n}\n", ""]);

// exports
exports.locals = {
	"HooksTreeView": "HooksTreeView___3YmZw",
	"Hook": "Hook___SbvM_",
	"Children": "Children___1f8xt",
	"HeaderRow": "HeaderRow___37mMe",
	"Header": "Header___9n-jL",
	"NameValueRow": "NameValueRow___1dbuI",
	"Name": "Name___3oYR1",
	"NameAnonymous": "NameAnonymous___W-cy2",
	"EditableName": "EditableName___1m4Hy",
	"Value": "Value___3tDyC",
	"None": "None___dHntG",
	"TruncationIndicator": "TruncationIndicator___fImBc",
	"ExpandCollapseToggleSpacer": "ExpandCollapseToggleSpacer___2RAvX"
};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".LayoutViewer___215Ad {\n  padding: 0.25rem;\n  border-top: 1px solid var(--color-border);\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-small);\n}\n\n.Header___YXSRg {\n  font-family: var(--font-family-sans);\n}\n\n.DashedBox___i8dxS,\n.SolidBox___1W-UG {\n  flex: 1 1 auto;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  border-width: 1px;\n  border-color: var(--color-dim);\n  padding: 0.25rem;\n  margin: 0.25rem;\n}\n.DashedBox___i8dxS {\n  border-style: dashed;\n}\n.SolidBox___1W-UG {\n  border-style: solid;\n}\n\n.LabelRow___2SQOh {\n  width: 100%;\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.Label___IskVY {\n  position: absolute;\n  left: 0.5rem;\n  flex: 1 0 100px;\n  color: var(--color-attribute-name);\n}\n\n.BoxRow___2_1as {\n  width: 100%;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n}\n", ""]);

// exports
exports.locals = {
	"LayoutViewer": "LayoutViewer___215Ad",
	"Header": "Header___YXSRg",
	"DashedBox": "DashedBox___i8dxS",
	"SolidBox": "SolidBox___1W-UG",
	"LabelRow": "LabelRow___2SQOh",
	"Label": "Label___IskVY",
	"BoxRow": "BoxRow___2_1as"
};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".StyleEditor___1RvzE {\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n  padding: 0.25rem;\n  border-top: 1px solid var(--color-border);\n}\n\n.HeaderRow___xyA6t {\n  display: flex;\n  align-items: center;\n}\n\n.Header___2SGfE {\n  flex: 1 1;\n}\n\n.Brackets___2zA4K {\n  font-family: var(--font-family-sans);\n  font-size: var(--font-size-sans-small);\n}\n\n.Row___3v8mp {\n  white-space: nowrap;\n  padding-left: 1rem;\n  display: flex;\n  align-items: center;\n}\n\n.Invalid___3ogBH {\n  background-color: var(--color-background-invalid);\n  color: var(--color-text-invalid);\n\n  --color-border: var(--color-text-invalid);\n}\n.Attribute___2yC0c {\n  color: var(--color-attribute-name);\n}\n\n.Value___1yJUg {\n  color: var(--color-attribute-value);\n}\n\n.Input___3Zdnf {\n  flex: 0 1 auto;\n  padding: 1px;\n  box-shadow: 0px 1px 3px transparent;\n}\n.Input___3Zdnf:focus {\n  color: var(--color-text);\n  box-shadow: 0px 1px 3px var(--color-shadow);\n}\n\n.Empty___3Pi3w {\n  color: var(--color-dimmer);\n  font-style: italic;\n  user-select: none;\n  padding-left: 1rem;\n}\n", ""]);

// exports
exports.locals = {
	"StyleEditor": "StyleEditor___1RvzE",
	"HeaderRow": "HeaderRow___xyA6t",
	"Header": "Header___2SGfE",
	"Brackets": "Brackets___2zA4K",
	"Row": "Row___3v8mp",
	"Invalid": "Invalid___3ogBH",
	"Attribute": "Attribute___2yC0c",
	"Value": "Value___1yJUg",
	"Input": "Input___3Zdnf",
	"Empty": "Empty___3Pi3w"
};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Owners___13tPI {\n  padding: 0.25rem;\n  border-top: 1px solid var(--color-border);\n}\n\n.OwnersHeader___3Yv3d {\n  font-family: var(--font-family-sans);\n}\n\n.Source____5R8o {\n  padding: 0.25rem;\n  border-top: 1px solid var(--color-border);\n}\n\n.SourceHeaderRow___2mf8O {\n  display: flex;\n  align-items: center;\n}\n\n.SourceHeader___3eTnC {\n  flex: 1 1;\n  font-family: var(--font-family-sans);\n}\n\n.SourceOneLiner___1CmzZ {\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: 100%;\n  margin-left: 1rem;\n}\n\n.Owner___3pCT- {\n  color: var(--color-component-name);\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: 100%;\n}\n\n.InspectedElement___AIaEa {\n  overflow-x: hidden;\n  overflow-y: auto;\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n  line-height: var(--line-height-data);\n}\n\n.Owner___3pCT- {\n  border-radius: 0.25rem;\n  padding: 0.125rem 0.25rem;\n  background: none;\n  border: none;\n  display: block;\n}\n.Owner___3pCT-:focus {\n  outline: none;\n  background-color: var(--color-button-background-focus);\n}\n\n.NotInStore___1AhKj {\n  color: var(--color-dim);\n  cursor: default;\n}\n\n.OwnerButton___1ZvI9 {\n  cursor: pointer;\n  width: 100%;\n  padding: 0;\n}\n\n.OwnerContent___1S1aF {\n  display: flex;\n  align-items: center;\n  padding-left: 1rem;\n  width: 100%;\n  border-radius: 0.25rem;\n}\n\n.OwnerContent___1S1aF:hover {\n  background-color: var(--color-background-hover);\n}\n\n.ContextMenuIcon___2EG7W {\n  margin-right: 0.5rem;\n}\n\n.OwnersMetaField___ot46- {\n  padding-left: 1.25rem;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}", ""]);

// exports
exports.locals = {
	"Owners": "Owners___13tPI",
	"OwnersHeader": "OwnersHeader___3Yv3d",
	"Source": "Source____5R8o",
	"SourceHeaderRow": "SourceHeaderRow___2mf8O",
	"SourceHeader": "SourceHeader___3eTnC",
	"SourceOneLiner": "SourceOneLiner___1CmzZ",
	"Owner": "Owner___3pCT-",
	"InspectedElement": "InspectedElement___AIaEa",
	"NotInStore": "NotInStore___1AhKj",
	"OwnerButton": "OwnerButton___1ZvI9",
	"OwnerContent": "OwnerContent___1S1aF",
	"ContextMenuIcon": "ContextMenuIcon___2EG7W",
	"OwnersMetaField": "OwnersMetaField___ot46-"
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".InspectedElement___gy6ot {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  width: 100%;\n  border-left: 1px solid var(--color-border);\n  border-top: 1px solid var(--color-border);\n}\n\n.TitleRow___2UUrj {\n  flex: 0 0 42px;\n  display: flex;\n  align-items: center;\n  font-size: var(--font-size-monospace-large);\n  border-bottom: 1px solid var(--color-border);\n  padding: 0.5rem;\n}\n\n.Key___1eadz {\n  flex: 0 1 auto;\n  padding-left: 0.25rem;\n  padding-right: 0.125rem;\n  line-height: 1rem;\n  border-top-left-radius: 0.125rem;\n  border-bottom-left-radius: 0.125rem;\n  display: inline-block;\n  background-color: var(--color-component-badge-background);\n  color: var(--color-text);\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-small);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: 100%;\n}\n\n.KeyArrow___2TKpc {\n  height: 1rem;\n  width: 1rem;\n  margin-right: -0.25rem;\n  border: 0.5rem solid transparent;\n  border-left: 0.5rem solid var(--color-component-badge-background);\n}\n\n.SelectedComponentName___3ByrZ {\n  flex: 1 1 auto;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  line-height: normal;\n}\n\n.Component___No3ti {\n  flex: 1 1 auto;\n  color: var(--color-component-name);\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: 100%;\n}\n\n.Loading___1cYSg {\n  padding: 0.25rem;\n  color: var(--color-dimmer);\n  font-style: italic;\n}\n\n", ""]);

// exports
exports.locals = {
	"InspectedElement": "InspectedElement___gy6ot",
	"TitleRow": "TitleRow___2UUrj",
	"Key": "Key___1eadz",
	"KeyArrow": "KeyArrow___2TKpc",
	"SelectedComponentName": "SelectedComponentName___3ByrZ",
	"Component": "Component___No3ti",
	"Loading": "Loading___1cYSg"
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Tab___20JoC,\n.TabCurrent___b4c3L,\n.TabDisabled___l1-ZF {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  border-top: 3px solid transparent;\n  border-bottom: 3px solid transparent;\n  user-select: none;\n  color: var(--color-text);\n\n  /* Electron drag area */\n  -webkit-app-region: no-drag;\n}\n.Tab___20JoC:hover,\n.TabCurrent___b4c3L:hover {\n  background-color: var(--color-background-hover);\n}\n.Tab___20JoC:focus-within,\n.TabCurrent___b4c3L:focus-within {\n  background-color: var(--color-background-hover);\n}\n\n.TabCurrent___b4c3L {\n  border-bottom: 3px solid var(--color-tab-selected-border);\n}\n\n.TabDisabled___l1-ZF {\n  color: var(--color-dim);\n  cursor: default;\n}\n\n.TabSizeNavigation___2GG1g {\n  font-size: var(--font-size-sans-large);\n  padding: 0.5rem 1rem;\n}\n.TabSizeProfiler___2wFBf {\n  font-size: var(--font-size-sans-normal);\n  padding: 0.25rem 0.5rem;\n}\n.TabSizeSettings___3V4f9 {\n  font-size: var(--font-size-sans-normal);\n  padding: 0.25rem 0.5rem;\n}\n\n.Input___2unCl {\n  width: 0;\n  margin: 0;\n  opacity: 0;\n}\n\n.IconSizeNavigation___mZIpl,\n.IconSizeProfiler___1jYXs,\n.IconSizeSettings___1HNRk {\n  margin-right: 0.5rem;\n  color: var(--color-button-active);\n}\n\n.IconDisabled___17Sd2 {\n  color: var(--color-dim);\n}\n\n.IconSizeNavigation___mZIpl {\n  width: 1.5rem;\n  height: 1.5rem;\n}\n.IconSizeProfiler___1jYXs {\n  width: 1rem;\n  height: 1rem;\n}\n.IconSizeSettings___1HNRk {\n  width: 1rem;\n  height: 1rem;\n}\n\n.TabLabelNavigation___2q3j3,\n.TabLabelProfiler___2QHeh,\n.TabLabelSettings___1pDKr {\n}\n\n@media screen and (max-width: 525px) {\n  .IconSizeNavigation___mZIpl {\n    margin-right: 0;\n  }\n\n  .TabLabelNavigation___2q3j3 {\n    display: none;\n  }\n}\n\n@media screen and (max-width: 900px) {\n  .TabLabelProfiler___2QHeh {\n    display: none;\n  }\n\n  .IconSizeProfiler___1jYXs {\n    margin-right: 0;\n  }\n}\n\n@media screen and (max-width: 400px) {\n  .TabLabelSettings___1pDKr {\n    display: none;\n  }\n\n  .IconSizeSettings___1HNRk {\n    margin-right: 0;\n  }\n}\n", ""]);

// exports
exports.locals = {
	"Tab": "Tab___20JoC",
	"TabCurrent": "TabCurrent___b4c3L",
	"TabDisabled": "TabDisabled___l1-ZF",
	"TabSizeNavigation": "TabSizeNavigation___2GG1g",
	"TabSizeProfiler": "TabSizeProfiler___2wFBf",
	"TabSizeSettings": "TabSizeSettings___3V4f9",
	"Input": "Input___2unCl",
	"IconSizeNavigation": "IconSizeNavigation___mZIpl",
	"IconSizeProfiler": "IconSizeProfiler___1jYXs",
	"IconSizeSettings": "IconSizeSettings___1HNRk",
	"IconDisabled": "IconDisabled___17Sd2",
	"TabLabelNavigation": "TabLabelNavigation___2q3j3",
	"TabLabelProfiler": "TabLabelProfiler___2QHeh",
	"TabLabelSettings": "TabLabelSettings___1pDKr"
};

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Settings___29B2k {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n  justify-content: flex-start;\n  font-family: var(--font-family-sans);\n  font-size: var(--font-size-sans-normal);\n}\n\n.Setting___1NJgU {\n  margin-bottom: 0.5rem;\n}\n.Setting___1NJgU:last-of-type {\n  margin-bottom: 0;\n}\n\n.OptionGroup___2ZgHP {\n  display: inline-flex;\n  flex-direction: row;\n  align-items: center;\n  user-select: none;\n  margin: 0 1rem 0.5rem 0;\n}\n.OptionGroup___2ZgHP:last-of-type {\n  margin-right: 0;\n}\n\n.RadioLabel___1oyOB {\n  display: inline;\n  margin-right: 0.5rem;\n}\n\n.Select___1otXV {\n}\n\n.CheckboxOption___2XWVZ {\n  display: block;\n  padding: 0 0 0.5rem;\n}\n\n.HRule___1h4ad {\n  height: 1px;\n  background-color: var(--color-border);\n  width: 100%;\n  border: none;\n  margin: 0.5rem 0;\n}\n\n.Header___NGIlt {\n  font-size: var(--font-size-sans-large);\n  margin-top: 0.5rem;\n}\n\n.ButtonIcon___3ZAjp {\n  margin-right: 0.25rem;\n}\n\n.NoFiltersCell___1WYR2 {\n  padding: 0.25rem 0;\n  color: var(--color-dim);\n}\n\n.Table___2srES {\n  min-width: 20rem;\n  margin-top: 0.5rem;\n  border-spacing: 0;\n}\n\n.TableRow___3kYuW {\n  padding-bottom: 0.5rem;\n}\n\n.TableCell___1yj52 {\n  padding: 0;\n  padding-right: 0.5rem;\n}\n.TableCell___1yj52:last-of-type {\n  text-align: right;\n  padding-right: 0;\n}\n\n.Input___I9AdA {\n  border: 1px solid var(--color-border);\n  border-radius: 0.125rem;\n  padding: 0.125rem;\n}\n\n.InvalidRegExp___35lmE,\n.InvalidRegExp___35lmE:active,\n.InvalidRegExp___35lmE:focus,\n.InvalidRegExp___35lmE:hover {\n  color: var(--color-value-invalid);\n}\n\n.ToggleOffInvalid___2Rg2K,\n.ToggleOnInvalid___1Kamt,\n.ToggleOff___3cr6E,\n.ToggleOn___3KAVB {\n  border-radius: 0.75rem;\n  width: 1rem;\n  height: 0.625rem;\n  display: flex;\n  align-items: center;\n  padding: 0.125rem;\n}\n.ToggleOffInvalid___2Rg2K {\n  background-color: var(--color-toggle-background-invalid);\n  justify-content: flex-start;\n}\n.ToggleOnInvalid___1Kamt {\n  background-color: var(--color-toggle-background-invalid);\n  justify-content: flex-end;\n}\n.ToggleOff___3cr6E {\n  background-color: var(--color-toggle-background-off);\n  justify-content: flex-start;\n}\n.ToggleOn___3KAVB {\n  background-color: var(--color-toggle-background-on);\n  justify-content: flex-end;\n}\n\n.ToggleInsideOff___1pXcm,\n.ToggleInsideOn___3kEsU {\n  border-radius: 0.375rem;\n  width: 0.375rem;\n  height: 0.375rem;\n  background-color: var(--color-toggle-text);\n}\n\n.ReleaseNotes___q8NY1 {\n  width: 100%;\n  background-color: var(--color-background-hover);\n  padding: 0.25rem 0.5rem;\n  border-radius: 0.25rem;\n}\n\n.ReleaseNotesLink___2gjE8 {\n  color: var(--color-button-active);\n}\n", ""]);

// exports
exports.locals = {
	"Settings": "Settings___29B2k",
	"Setting": "Setting___1NJgU",
	"OptionGroup": "OptionGroup___2ZgHP",
	"RadioLabel": "RadioLabel___1oyOB",
	"Select": "Select___1otXV",
	"CheckboxOption": "CheckboxOption___2XWVZ",
	"HRule": "HRule___1h4ad",
	"Header": "Header___NGIlt",
	"ButtonIcon": "ButtonIcon___3ZAjp",
	"NoFiltersCell": "NoFiltersCell___1WYR2",
	"Table": "Table___2srES",
	"TableRow": "TableRow___3kYuW",
	"TableCell": "TableCell___1yj52",
	"Input": "Input___I9AdA",
	"InvalidRegExp": "InvalidRegExp___35lmE",
	"ToggleOffInvalid": "ToggleOffInvalid___2Rg2K",
	"ToggleOnInvalid": "ToggleOnInvalid___1Kamt",
	"ToggleOff": "ToggleOff___3cr6E",
	"ToggleOn": "ToggleOn___3KAVB",
	"ToggleInsideOff": "ToggleInsideOff___1pXcm",
	"ToggleInsideOn": "ToggleInsideOn___3kEsU",
	"ReleaseNotes": "ReleaseNotes___q8NY1",
	"ReleaseNotesLink": "ReleaseNotesLink___2gjE8"
};

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Background___3ncIs {\n  position: absolute;\n  z-index: 3;\n  width: 100%;\n  top: 0;\n  bottom: 0;\n  background-color: var(--color-modal-background);\n  display: flex;\n  align-items: flex-start;\n  justify-content: center;\n  font-size: var(--font-size-sans-normal);\n  padding: 1rem;\n}\n\n.Modal___rU10h {\n  display: flex;\n  flex-direction: column;\n  flex: 0 1 auto;\n  max-height: 100%;\n  background-color: var(--color-background);\n  border: 1px solid var(--color-border);\n  box-shadow: 0 2px 4px var(--color-shadow);\n  border-radius: 0.25rem;\n  overflow: auto;\n  width: 400px;\n  max-width: 100%;\n}\n\n.Spacer___3_C0y {\n  flex: 1;\n}\n\n.Tabs___3mQky {\n  display: flex;\n  flex-direction: row;\n  border-bottom: 1px solid var(--color-border);\n  padding-right: 0.25rem;\n  flex: 0 0 auto;\n}\n\n.Content___2YU9A {\n  padding: 0.5rem;\n  flex: 0 1 auto;\n  overflow: auto;\n}\n", ""]);

// exports
exports.locals = {
	"Background": "Background___3ncIs",
	"Modal": "Modal___rU10h",
	"Spacer": "Spacer___3_C0y",
	"Tabs": "Tabs___3mQky",
	"Content": "Content___2YU9A"
};

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Components___MlQHS {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: row;\n  background-color: var(--color-background);\n  color: var(--color-text);\n  font-family: var(--font-family-sans);\n}\n\n.Components___MlQHS, .Components___MlQHS * {\n  box-sizing: border-box;\n  -webkit-font-smoothing: var(--font-smoothing);\n}\n\n.TreeWrapper___2uPTC {\n  flex: 0 0 var(--horizontal-resize-percentage);\n  overflow: auto;\n}\n\n.InspectedElementWrapper___Ay-WL {\n  flex: 1 1 35%;\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n\n.ResizeBarWrapper___2jVIz {\n  flex: 0 0 0px;\n  position: relative;\n}\n\n.ResizeBar___1o6VK {\n  position: absolute;\n  left: -2px;\n  width: 5px;\n  height: 100%;\n  cursor: ew-resize;\n}\n\n@media screen and (max-width: 600px) {\n  .Components___MlQHS {\n    flex-direction: column;\n  }\n\n  .TreeWrapper___2uPTC {\n    flex: 0 0 var(--vertical-resize-percentage);\n  }\n\n  .InspectedElementWrapper___Ay-WL {\n    flex: 1 1 50%;\n  }\n\n  .ResizeBar___1o6VK {\n    top: -2px;\n    left: 0;\n    width: 100%;\n    height: 5px;\n    cursor: ns-resize;\n  }\n}\n\n.Loading___Slif- {\n  height: 100%;\n  padding-left: 0.5rem;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: var(--font-size-sans-large);\n  color: var(--color-dim);\n}\n", ""]);

// exports
exports.locals = {
	"Components": "Components___MlQHS",
	"TreeWrapper": "TreeWrapper___2uPTC",
	"InspectedElementWrapper": "InspectedElementWrapper___Ay-WL",
	"ResizeBarWrapper": "ResizeBarWrapper___2jVIz",
	"ResizeBar": "ResizeBar___1o6VK",
	"Loading": "Loading___Slif-"
};

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".NoCommitData___2oJ_z {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n\n.Header___1oGeD {\n  font-size: var(--font-size-sans-large);\n  margin-bottom: 0.5rem;\n}\n\n.FilterMessage___1Yg5n {\n  display: flex;\n  align-items: center;\n}\n", ""]);

// exports
exports.locals = {
	"NoCommitData": "NoCommitData___2oJ_z",
	"Header": "Header___1oGeD",
	"FilterMessage": "FilterMessage___1Yg5n"
};

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Group___2hArG {\n  transition: all ease-in-out 250ms;\n}\n\n.Rect___fBfs_ {\n  cursor: pointer;\n  stroke: var(--color-background);\n  transition: all ease-in-out 250ms;\n}\n\n.ForeignObject___2EdVc {\n  pointer-events: none;\n  transition: all ease-in-out 250ms;\n}\n\n.Div___1Pgrm {\n  pointer-events: none;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  font-family: var(--font-family-sans);\n  font-size: var(--font-size-sans-normal);\n  margin-left: 0.25rem;\n  margin-right: 0.25rem;\n  line-height: 1.5;\n  padding: 0 0 0;\n  font-weight: 400;\n  color: var(--color-commit-gradient-text);\n  text-align: left;\n  transition: all ease-in-out 250ms;\n}\n", ""]);

// exports
exports.locals = {
	"Group": "Group___2hArG",
	"Rect": "Rect___fBfs_",
	"ForeignObject": "ForeignObject___2EdVc",
	"Div": "Div___1Pgrm"
};

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Component___3ci_S {\n  margin-bottom: 0.5rem;\n}\n\n.Item___2hxYk {\n  margin-top: 0.25rem;\n}\n\n.Key___1tUd1 {\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-small);\n  line-height: 1;\n}\n\n.Key___1tUd1:first-of-type::before {\n  content: ' (';\n}\n\n.Key___1tUd1::after {\n  content: ', ';\n}\n\n.Key___1tUd1:last-of-type::after {\n  content: ')';\n}\n\n.Label___2zyeV {\n  font-weight: bold;\n}\n", ""]);

// exports
exports.locals = {
	"Component": "Component___3ci_S",
	"Item": "Item___2hxYk",
	"Key": "Key___1tUd1",
	"Label": "Label___2zyeV"
};

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Toolbar___3u3I_ {\n  padding: 0.25rem 0;\n  margin-bottom: 0.25rem;\n  flex: 0 0 auto;\n  display: flex;\n  align-items: center;\n  border-bottom: 1px solid var(--color-border);\n}\n\n.Content___3i3NJ {\n  user-select: none;\n  overflow-y: auto;\n}\n\n.Component___Y5kFG {\n  flex: 1;\n  font-weight: bold;\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n  white-space: nowrap;\n  overflow-x: hidden;\n  text-overflow: ellipsis;\n}\n\n.Label___3g1xf {\n  font-weight: bold;\n}\n\n.CurrentCommit___21fVV {\n  margin: 0.25rem 0;\n  display: block;\n  width: 100%;\n  text-align: left;\n  background: none;\n  border: none;\n}\n", ""]);

// exports
exports.locals = {
	"Toolbar": "Toolbar___3u3I_",
	"Content": "Content___3i3NJ",
	"Component": "Component___Y5kFG",
	"Label": "Label___3g1xf",
	"CurrentCommit": "CurrentCommit___21fVV"
};

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Tooltip___NP68S {\n  position: absolute;\n  pointer-events: none;\n  border: none;\n  border-radius: 0.25rem;\n  padding: 0.25rem 0.5rem;\n  font-family: var(--font-family-sans);\n  font-size: 12px;\n  background-color: var(--color-tooltip-background);\n  color: var(--color-tooltip-text);\n  opacity: 1;\n  /* Make sure this is above the DevTools, which are above the Overlay */\n  z-index: 10000002;\n}\n\n.Tooltip___NP68S.hidden___3rGbV {\n  opacity: 0;\n}\n\n\n.Container___3aJAm {\n  width: -moz-max-content;\n  width: -webkit-max-content;\n}\n", ""]);

// exports
exports.locals = {
	"Tooltip": "Tooltip___NP68S",
	"hidden": "hidden___3rGbV",
	"Container": "Container___3aJAm"
};

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Container___WYOTp {\n  width: 100%;\n  flex: 1;\n  padding: 0.5rem;\n}\n\n.PatternPath___2kgd1 {\n  stroke: var(--color-commit-did-not-render-pattern);\n  stroke-width: 1;\n}\n", ""]);

// exports
exports.locals = {
	"Container": "Container___WYOTp",
	"PatternPath": "PatternPath___2kgd1"
};

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Container___2D32U {\n  width: 100%;\n  flex: 1;\n  padding: 0.5rem;\n}\n", ""]);

// exports
exports.locals = {
	"Container": "Container___2D32U"
};

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Interaction___1wkkK,\n.SelectedInteraction___7La_q {\n  display: flex;\n  align-items: center;\n  padding: 0 0.25rem;\n  border-bottom: 1px solid var(--color-border);\n}\n\n.Interaction___1wkkK:hover {\n  background-color: var(--color-background-hover);\n}\n\n.SelectedInteraction___7La_q {\n  background-color: var(--color-background-hover);\n}\n\n.Name___3dY_4 {\n  white-space: nowrap;\n  overflow-x: hidden;\n  text-overflow: ellipsis;\n}\n\n.Timeline___O0RIy {\n  position: relative;\n  height: 100%;\n}\n\n.InteractionLine___r6F9K {\n  position: absolute;\n  height: 3px;\n  background-color: var(--color-commit-did-not-render-fill);\n  color: var(--color-commit-did-not-render-fill-text);\n  border-radius: 0.125rem;\n}\n\n.CommitBox___2Ly_w {\n  position: absolute;\n  width: var(--interaction-commit-size);\n  height: var(--interaction-commit-size);\n  background-color: var(--color-commit-did-not-render-fill);\n  color: var(--color-commit-did-not-render-fill-text);\n  cursor: pointer;\n}\n", ""]);

// exports
exports.locals = {
	"Interaction": "Interaction___1wkkK",
	"SelectedInteraction": "SelectedInteraction___7La_q",
	"Name": "Name___3dY_4",
	"Timeline": "Timeline___O0RIy",
	"InteractionLine": "InteractionLine___r6F9K",
	"CommitBox": "CommitBox___2Ly_w"
};

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".NoInteractions___1FQiN {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n\n.Header___26pfp {\n  font-size: var(--font-size-sans-large);\n}\n\n.Link___1QIRe {\n  color: var(--color-button);\n}\n", ""]);

// exports
exports.locals = {
	"NoInteractions": "NoInteractions___1FQiN",
	"Header": "Header___26pfp",
	"Link": "Link___1QIRe"
};

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Container___1CyNc {\n  width: 100%;\n  flex: 1;\n  padding: 0.5rem;\n}\n\n.FocusTarget___3WP7F:focus {\n  outline: none;\n}\n", ""]);

// exports
exports.locals = {
	"Container": "Container___1CyNc",
	"FocusTarget": "FocusTarget___3WP7F"
};

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Spacer___1c3sH {\n  flex: 1;\n}\n", ""]);

// exports
exports.locals = {
	"Spacer": "Spacer___1c3sH"
};

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".ActiveRecordToggle___1Cpcb {\n  color: var(--color-record-active);\n}\n.ActiveRecordToggle___1Cpcb:hover {\n  color: var(--color-record-active);\n}\n.ActiveRecordToggle___1Cpcb:focus {\n  color: var(--color-record-active);\n}\n.ActiveRecordToggle___1Cpcb:active {\n  color: var(--color-record-hover);\n}\n\n.InactiveRecordToggle___2CUtF {\n  color: var(--color-record-inactive);\n}\n.InactiveRecordToggle___2CUtF:hover {\n  color: var(--color-record-hover);\n}\n.InactiveRecordToggle___2CUtF:focus {\n  color: var(--color-record-inactive);\n}\n.InactiveRecordToggle___2CUtF:active {\n  color: var(--color-record-hover);\n}\n\n.DisabledRecordToggle___gcsbF {\n  color: var(--color-button-disabled);\n}\n.DisabledRecordToggle___gcsbF:hover {\n  color: var(--color-button-disabled);\n}\n.DisabledRecordToggle___gcsbF:focus {\n  color: var(--color-button-disabled);\n}\n.DisabledRecordToggle___gcsbF:active {\n  color: var(--color-button-disabled);\n}\n", ""]);

// exports
exports.locals = {
	"ActiveRecordToggle": "ActiveRecordToggle___1Cpcb",
	"InactiveRecordToggle": "InactiveRecordToggle___2CUtF",
	"DisabledRecordToggle": "DisabledRecordToggle___gcsbF"
};

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".VRule___2XiHw {\n  height: 20px;\n  width: 1px;\n  border-left: 1px solid var(--color-border);\n  padding-left: 0.25rem;\n  margin-left: 0.25rem;\n}\n\n/**\n * https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications\n */\n.Input___2GKA7 {\n  position: absolute !important;\n  height: 1px;\n  width: 1px;\n  overflow: hidden;\n  clip: rect(1px, 1px, 1px, 1px);\n}\n\n.ErrorMessage___3yR0b {\n  margin: 0.5rem 0;\n  color: var(--color-dim);\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n}\n", ""]);

// exports
exports.locals = {
	"VRule": "VRule___2XiHw",
	"Input": "Input___2GKA7",
	"ErrorMessage": "ErrorMessage___3yR0b"
};

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Outer___2YMUU {\n  user-select: none;\n  cursor: pointer;\n  border-bottom: 3px solid transparent;\n  padding-top: 4px;\n  padding-bottom: 1px;\n  display: flex;\n  align-items: flex-end;\n}\n\n.Inner___TFCLU {\n  width: 100%;\n  min-height: 5px;\n  background-color: var(--color-commit-did-not-render-fill);\n  color: var(--color-commit-did-not-render-fill-text);\n}\n", ""]);

// exports
exports.locals = {
	"Outer": "Outer___2YMUU",
	"Inner": "Inner___TFCLU"
};

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".List___1_Mwa {\n  /**\n   * The decision to suppress the default (horizontal) scroll bars is intentional.\n   * The snapshot selector is small enough that the scrollbar renders it essentially useless.\n   * There are two alternative navigation mechanisms (arrow keys and arrow buttons).\n   * If necessary, we could also expand the click-and-drag mechanism to scroll.\n   */\n  overflow-x: hidden !important;\n}\n", ""]);

// exports
exports.locals = {
	"List": "List___1_Mwa"
};

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Button___7tgtJ {\n  flex: 0 0 auto;\n  margin-left: 0.25rem;\n}\n\n.Commits___2KF5W {\n  height: 100%;\n  min-width: 30px;\n  margin-left: 0.25rem;\n  overflow: hidden;\n}\n.Commits___2KF5W:focus {\n  outline: none;\n  background-color: var(--color-button-background-focus);\n}\n\n.IndexLabel___36CS7 {\n  flex: 0 0 auto;\n  white-space: nowrap;\n  font-family: var(--font-family-monospace);\n  margin-left: 0.25rem;\n}\n\n.NoCommits___3GzV1 {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: var(--color-dim);\n}\n", ""]);

// exports
exports.locals = {
	"Button": "Button___7tgtJ",
	"Commits": "Commits___2KF5W",
	"IndexLabel": "IndexLabel___36CS7",
	"NoCommits": "NoCommits___3GzV1"
};

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Toolbar___CuJgF {\n  height: 2.25rem;\n  padding: 0 0.5rem;\n  flex: 0 0 auto;\n  display: flex;\n  align-items: center;\n  border-bottom: 1px solid var(--color-border);\n}\n\n.Content___2tGS0 {\n  padding: 0.5rem;\n  user-select: none;\n  overflow: auto;\n}\n\n.List___2AC9R {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n\n.ListItem___2wzT0 {\n  margin: 0 0 0.5rem;\n}\n\n.NoInteractions___2-rNG {\n  color: var(--color-dim);\n}\n\n.Interactions___2JjM3 {\n  margin: 0 0 0.5rem;\n}\n.Interaction___2_WfJ {\n  display: block;\n  width: 100%;\n  text-align: left;\n  background: none;\n  border: none;\n  padding: 0.25rem 0.5rem;\n  color: var(--color-text);\n}\n.Interaction___2_WfJ:focus,\n.Interaction___2_WfJ:hover {\n  outline: none;\n  background-color: var(--color-background-hover);\n}\n\n.Label___3KINM {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  font-weight: bold;\n}\n\n.Value___3wrFP {\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n}\n\n.NothingSelected___2Sj9L {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  color: var(--color-dim);\n}\n", ""]);

// exports
exports.locals = {
	"Toolbar": "Toolbar___CuJgF",
	"Content": "Content___2tGS0",
	"List": "List___2AC9R",
	"ListItem": "ListItem___2wzT0",
	"NoInteractions": "NoInteractions___2-rNG",
	"Interactions": "Interactions___2JjM3",
	"Interaction": "Interaction___2_WfJ",
	"Label": "Label___3KINM",
	"Value": "Value___3wrFP",
	"NothingSelected": "NothingSelected___2Sj9L"
};

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Toolbar___14c8s {\n  height: 2.25rem;\n  padding: 0 0.5rem;\n  flex: 0 0 auto;\n  display: flex;\n  align-items: center;\n}\n\n.Content___2Br59 {\n  padding: 0.5rem;\n  user-select: none;\n  border-top: 1px solid var(--color-border);\n  overflow: auto;\n}\n\n.Name___y3sqj {\n  font-size: var(--font-size-sans-large);\n  white-space: nowrap;\n  overflow-x: hidden;\n  text-overflow: ellipsis;\n}\n\n.NothingSelected___LXwMm {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  color: var(--color-dim);\n}\n\n.Commits___3dPiw {\n  font-weight: bold;\n}\n\n.List___1d-dx {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n\n.ListItem___6d_7z {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  padding: 0.25rem 0.5rem;\n}\n.ListItem___6d_7z:hover {\n  background-color: var(--color-background-hover);\n}\n\n.CommitBox___5r9ed {\n  width: 20px;\n  height: 20px;\n  margin-right: 0.5rem;\n}\n", ""]);

// exports
exports.locals = {
	"Toolbar": "Toolbar___14c8s",
	"Content": "Content___2Br59",
	"Name": "Name___y3sqj",
	"NothingSelected": "NothingSelected___LXwMm",
	"Commits": "Commits___3dPiw",
	"List": "List___1d-dx",
	"ListItem": "ListItem___6d_7z",
	"CommitBox": "CommitBox___5r9ed"
};

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Toolbar___2uBS2 {\n  height: 2.25rem;\n  padding: 0 0.5rem;\n  flex: 0 0 auto;\n  display: flex;\n  align-items: center;\n  border-bottom: 1px solid var(--color-border);\n}\n\n.Content___1WAA9 {\n  padding: 0.5rem;\n  user-select: none;\n  overflow-y: auto;\n}\n\n.WhatChanged___3T3Sx {\n  margin-bottom: 1rem;\n}\n\n.Component___1oc9o {\n  flex: 1;\n  color: var(--color-component-name);\n  font-family: var(--font-family-monospace);\n  font-size: var(--font-size-monospace-normal);\n  white-space: nowrap;\n  overflow-x: hidden;\n  text-overflow: ellipsis;\n}\n\n.Label___buTyu {\n  font-weight: bold;\n  margin-bottom: 0.5rem;\n}\n\n.CurrentCommit___2ZAl5,\n.Commit___2PAr5 {\n  display: block;\n  width: 100%;\n  text-align: left;\n  background: none;\n  border: none;\n  padding: 0.25rem 0.5rem;\n  color: var(--color-text);\n}\n\n.Commit___2PAr5:focus,\n.Commit___2PAr5:hover {\n  outline: none;\n  background-color: var(--color-background-hover);\n}\n\n.CurrentCommit___2ZAl5 {\n  background-color: var(--color-background-selected);\n  color: var(--color-text-selected);\n}\n\n.CurrentCommit___2ZAl5:focus {\n  outline: none;\n}\n", ""]);

// exports
exports.locals = {
	"Toolbar": "Toolbar___2uBS2",
	"Content": "Content___1WAA9",
	"WhatChanged": "WhatChanged___3T3Sx",
	"Component": "Component___1oc9o",
	"Label": "Label___buTyu",
	"CurrentCommit": "CurrentCommit___2ZAl5",
	"Commit": "Commit___2PAr5"
};

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Profiler___20Ry4 {\n  width: 100%;\n  height: 100%;\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  align-items: stretch;\n  font-family: var(--font-family-sans);\n  font-size: var(--font-size-sans-normal);\n  background-color: var(--color-background);\n  color: var(--color-text);\n}\n\n.Profiler___20Ry4, .Profiler___20Ry4 * {\n  box-sizing: border-box;\n  -webkit-font-smoothing: var(--font-smoothing);\n}\n\n.LeftColumn___3I7-I {\n  display: flex;\n  flex-direction: column;\n  flex: 2 1 200px;\n  border-top: 1px solid var(--color-border);\n}\n\n.RightColumn___3smXD {\n  display: flex;\n  flex-direction: column;\n  flex: 1 1 100px;\n  max-width: 300px;\n  overflow-x: hidden;\n  border-left: 1px solid var(--color-border);\n  border-top: 1px solid var(--color-border);\n}\n\n.Content___1LjDy {\n  position: relative;\n  flex: 1 1 auto;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n\n.Column___3WWtw {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  padding: 0 1rem;\n}\n\n.Paragraph___1HLty {\n  text-align: center;\n}\n\n.Row___1RpSu {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n}\n\n.Header___QyJw2 {\n  font-size: var(--font-size-sans-large);\n  margin-bottom: 0.5rem;\n}\n\n.Toolbar___30kHu {\n  height: 2.25rem;\n  padding: 0 0.25rem;\n  flex: 0 0 auto;\n  display: flex;\n  align-items: center;\n  border-bottom: 1px solid var(--color-border);\n}\n\n.VRule___2y9G3 {\n  height: 20px;\n  width: 1px;\n  border-left: 1px solid var(--color-border);\n  padding-left: 0.25rem;\n  margin-left: 0.25rem;\n}\n\n.Spacer___1sezP {\n  flex: 1;\n}\n\n.StopRecordingButton___1-ElU {\n  font-size: var(--font-size-sans-large);\n  padding: 0.5rem;\n}\n\n.ContentFallback___2Ata2 {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: var(--font-size-sans-large);\n  color: var(--color-dim);\n}\n\n.SnapshotSelectorFallback___3fsFv {\n  height: 100%;\n  padding-left: 0.5rem;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: var(--font-size-sans-large);\n  color: var(--color-dim);\n}\n\n.Link___mZ2LE {\n  color: var(--color-button);\n}\n", ""]);

// exports
exports.locals = {
	"Profiler": "Profiler___20Ry4",
	"LeftColumn": "LeftColumn___3I7-I",
	"RightColumn": "RightColumn___3smXD",
	"Content": "Content___1LjDy",
	"Column": "Column___3WWtw",
	"Paragraph": "Paragraph___1HLty",
	"Row": "Row___1RpSu",
	"Header": "Header___QyJw2",
	"Toolbar": "Toolbar___30kHu",
	"VRule": "VRule___2y9G3",
	"Spacer": "Spacer___1sezP",
	"StopRecordingButton": "StopRecordingButton___1-ElU",
	"ContentFallback": "ContentFallback___2Ata2",
	"SnapshotSelectorFallback": "SnapshotSelectorFallback___3fsFv",
	"Link": "Link___mZ2LE"
};

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".ReactLogo___O8zf5 {\n  width: 1.75rem;\n  height: 1.75rem;\n  margin: 0 0.75rem 0 0.25rem;\n  color: var(--color-button-active);\n}\n", ""]);

// exports
exports.locals = {
	"ReactLogo": "ReactLogo___O8zf5"
};

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Row___3IwJ6 {  \n  display: flex;  \n  flex-direction: row;  \n  align-items: center;  \n} \n\n.Column___w9Fle { \n  display: flex;  \n  flex-direction: column; \n  align-items: center;  \n} \n\n.Title___1PTyg {  \n  font-size: var(--font-size-sans-large); \n  margin-bottom: 0.5rem;  \n} \n\n.ReleaseNotesLink___2_Y38 { \n  color: var(--color-button-active);  \n}", ""]);

// exports
exports.locals = {
	"Row": "Row___3IwJ6",
	"Column": "Column___w9Fle",
	"Title": "Title___1PTyg",
	"ReleaseNotesLink": "ReleaseNotesLink___2_Y38"
};

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".Command___2iS3V {\n  background-color: var(--color-dimmest);\n  padding: 0.25rem 0.5rem;\n  display: block;\n  border-radius: 0.125rem;\n}\n", ""]);

// exports
exports.locals = {
	"Command": "Command___2iS3V"
};

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ".DevTools___NAxvy {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  background-color: var(--color-background);\n  color: var(--color-text);\n}\n\n.TabBar___2aDHU {\n  flex: 0 0 auto;\n  display: flex;\n  align-items: center;\n  padding: 0 0.5rem;\n  background-color: var(--color-background);\n  border-top: 1px solid var(--color-border);\n  font-family: var(--font-family-sans);\n  font-size: var(--font-size-sans-large);\n  user-select: none;\n\n  /* Electron drag area */\n  -webkit-app-region: drag;\n}\n\n.Spacer___1VPRF {\n  flex: 1;\n}\n\n.TabContent___27Qz1 {\n  flex: 1 1 100%;\n  overflow: auto;\n  -webkit-app-region: no-drag;\n}\n\n.DevToolsVersion___3_3UD {\n  font-size: var(--font-size-sans-normal);\n  margin-right: 0.5rem;\n}\n\n.DevToolsVersion___3_3UD:before {\n  font-size: var(--font-size-sans-large);\n  content: 'DevTools ';\n}\n\n@media screen and (max-width: 400px) {\n  .DevToolsVersion___3_3UD:before {\n    content: '';\n  }\n}\n\n@media screen and (max-width: 300px) {\n  .DevToolsVersion___3_3UD {\n    display: none;\n  }\n}\n\n.DevTools___NAxvy, .DevTools___NAxvy * {\n  box-sizing: border-box;\n  -webkit-font-smoothing: var(--font-smoothing);\n}\n", ""]);

// exports
exports.locals = {
	"DevTools": "DevTools___NAxvy",
	"TabBar": "TabBar___2aDHU",
	"Spacer": "Spacer___1VPRF",
	"TabContent": "TabContent___27Qz1",
	"DevToolsVersion": "DevToolsVersion___3_3UD"
};

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(159);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(5)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(false);
// imports


// module
exports.push([module.i, ":root {\n  /**\n   * IMPORTANT: When new theme variables are added belowâ€“ also add them to SettingsContext updateThemeVariables()\n   */\n\n  /* Light theme */\n  --light-color-attribute-name: #ef6632;\n  --light-color-attribute-name-not-editable: #23272f;\n  --light-color-attribute-name-inverted: rgba(255, 255, 255, 0.7);\n  --light-color-attribute-value: #1a1aa6;\n  --light-color-attribute-value-inverted: #ffffff;\n  --light-color-attribute-editable-value: #1a1aa6;\n  --light-color-background: #ffffff;\n  --light-color-background-hover: rgba(0, 136, 250, 0.1);\n  --light-color-background-inactive: #e5e5e5;\n  --light-color-background-invalid: #fff0f0;\n  --light-color-background-selected: #0088fa;\n  --light-color-button-background: #ffffff;\n  --light-color-button-background-focus: #ededed;\n  --light-color-button: #5f6673;\n  --light-color-button-disabled: #cfd1d5;\n  --light-color-button-active: #0088fa;\n  --light-color-button-focus: #23272f;\n  --light-color-button-hover: #23272f;\n  --light-color-border: #eeeeee;\n  --light-color-commit-did-not-render-fill: #cfd1d5;\n  --light-color-commit-did-not-render-fill-text: #000000;\n  --light-color-commit-did-not-render-pattern: #cfd1d5;\n  --light-color-commit-did-not-render-pattern-text: #333333;\n  --light-color-commit-gradient-0: #37afa9;\n  --light-color-commit-gradient-1: #63b19e;\n  --light-color-commit-gradient-2: #80b393;\n  --light-color-commit-gradient-3: #97b488;\n  --light-color-commit-gradient-4: #abb67d;\n  --light-color-commit-gradient-5: #beb771;\n  --light-color-commit-gradient-6: #cfb965;\n  --light-color-commit-gradient-7: #dfba57;\n  --light-color-commit-gradient-8: #efbb49;\n  --light-color-commit-gradient-9: #febc38;\n  --light-color-commit-gradient-text: #000000;\n  --light-color-component-name: #6a51b2;\n  --light-color-component-name-inverted: #ffffff;\n  --light-color-component-badge-background: rgba(0, 0, 0, 0.1);\n  --light-color-component-badge-background-inverted: rgba(255, 255, 255, 0.25);\n  --light-color-component-badge-count: #777d88;\n  --light-color-component-badge-count-inverted: rgba(255, 255, 255, 0.7);\n  --light-color-context-background: rgba(0,0,0,.9);\n  --light-color-context-background-hover: rgba(255, 255, 255, 0.1);\n  --light-color-context-background-selected: #178fb9;\n  --light-color-context-border: #3d424a;\n  --light-color-context-text: #ffffff;\n  --light-color-context-text-selected: #ffffff;\n  --light-color-dim: #777d88;\n  --light-color-dimmer: #cfd1d5;\n  --light-color-dimmest: #eff0f1;\n  --light-color-error-background: hsl(0, 100%, 97%);\n  --light-color-error-border: hsl(0, 100%, 92%);\n  --light-color-error-text: #ff0000;\n  --light-color-expand-collapse-toggle: #777d88;\n  --light-color-link: #0000ff;\n  --light-color-modal-background: rgba(255, 255, 255, 0.75);\n  --light-color-record-active: #fc3a4b;\n  --light-color-record-hover: #3578e5;\n  --light-color-record-inactive: #0088fa;\n  --light-color-scroll-thumb: #c2c2c2;\n  --light-color-scroll-track: #fafafa;\n  --light-color-search-match: yellow;\n  --light-color-search-match-current: #f7923b;\n  --light-color-selected-tree-highlight-active: rgba(0, 136, 250, 0.1);\n  --light-color-selected-tree-highlight-inactive: rgba(0, 0, 0, 0.05);\n  --light-color-shadow: rgba(0, 0, 0, 0.25);\n  --light-color-tab-selected-border: #0088fa;\n  --light-color-text: #000000;\n  --light-color-text-invalid: #ff0000;\n  --light-color-text-selected: #ffffff;\n  --light-color-toggle-background-invalid: #fc3a4b;\n  --light-color-toggle-background-on: #0088fa;\n  --light-color-toggle-background-off: #cfd1d5;\n  --light-color-toggle-text: #ffffff;\n  --light-color-tooltip-background: rgba(0, 0, 0, 0.9);\n  --light-color-tooltip-text: #ffffff;\n\n  /* Dark theme */\n  --dark-color-attribute-name: #9d87d2;\n  --dark-color-attribute-name-not-editable: #ededed;\n  --dark-color-attribute-name-inverted: #282828;\n  --dark-color-attribute-value: #cedae0;\n  --dark-color-attribute-value-inverted: #ffffff;\n  --dark-color-attribute-editable-value: yellow;\n  --dark-color-background: #282c34;\n  --dark-color-background-hover: rgba(255, 255, 255, 0.1);\n  --dark-color-background-inactive: #3d424a;\n  --dark-color-background-invalid: #5c0000;\n  --dark-color-background-selected: #178fb9;\n  --dark-color-button-background: #282c34;\n  --dark-color-button-background-focus: #3d424a;\n  --dark-color-button: #afb3b9;\n  --dark-color-button-active: #61dafb;\n  --dark-color-button-disabled: #4f5766;\n  --dark-color-button-focus: #a2e9fc;\n  --dark-color-button-hover: #ededed;\n  --dark-color-border: #3d424a;\n  --dark-color-commit-did-not-render-fill: #777d88;\n  --dark-color-commit-did-not-render-fill-text: #000000;\n  --dark-color-commit-did-not-render-pattern: #666c77;\n  --dark-color-commit-did-not-render-pattern-text: #ffffff;\n  --dark-color-commit-gradient-0: #37afa9;\n  --dark-color-commit-gradient-1: #63b19e;\n  --dark-color-commit-gradient-2: #80b393;\n  --dark-color-commit-gradient-3: #97b488;\n  --dark-color-commit-gradient-4: #abb67d;\n  --dark-color-commit-gradient-5: #beb771;\n  --dark-color-commit-gradient-6: #cfb965;\n  --dark-color-commit-gradient-7: #dfba57;\n  --dark-color-commit-gradient-8: #efbb49;\n  --dark-color-commit-gradient-9: #febc38;\n  --dark-color-commit-gradient-text: #000000;\n  --dark-color-component-name: #61dafb;\n  --dark-color-component-name-inverted: #282828;\n  --dark-color-component-badge-background: rgba(255, 255, 255, 0.25);\n  --dark-color-component-badge-background-inverted: rgba(0, 0, 0, 0.25);\n  --dark-color-component-badge-count: #8f949d;\n  --dark-color-component-badge-count-inverted: rgba(255, 255, 255, 0.7);\n  --dark-color-context-background: rgba(255,255,255,.9);\n  --dark-color-context-background-hover: rgba(0, 136, 250, 0.1);\n  --dark-color-context-background-selected: #0088fa;\n  --dark-color-context-border: #eeeeee;\n  --dark-color-context-text: #000000;\n  --dark-color-context-text-selected: #ffffff;\n  --dark-color-dim: #8f949d;\n  --dark-color-dimmer: #777d88;\n  --dark-color-dimmest: #4f5766;\n  --dark-color-error-background: #200;\n  --dark-color-error-border: #900;\n  --dark-color-error-text: #f55;\n  --dark-color-expand-collapse-toggle: #8f949d;\n  --dark-color-link: #61dafb;\n  --dark-color-modal-background: rgba(0, 0, 0, 0.75);\n  --dark-color-record-active: #fc3a4b;\n  --dark-color-record-hover: #a2e9fc;\n  --dark-color-record-inactive: #61dafb;\n  --dark-color-scroll-thumb: #afb3b9;\n  --dark-color-scroll-track: #313640;\n  --dark-color-search-match: yellow;\n  --dark-color-search-match-current: #f7923b;\n  --dark-color-selected-tree-highlight-active: rgba(23, 143, 185, 0.15);\n  --dark-color-selected-tree-highlight-inactive: rgba(255, 255, 255, 0.05);\n  --dark-color-shadow: rgba(0, 0, 0, 0.5);\n  --dark-color-tab-selected-border: #178fb9;\n  --dark-color-text: #ffffff;\n  --dark-color-text-invalid: #ff8080;\n  --dark-color-text-selected: #ffffff;\n  --dark-color-toggle-background-invalid: #fc3a4b;\n  --dark-color-toggle-background-on: #178fb9;\n  --dark-color-toggle-background-off: #777d88;\n  --dark-color-toggle-text: #ffffff;\n  --dark-color-tooltip-background: rgba(255, 255, 255, 0.9);\n  --dark-color-tooltip-text: #000000;\n\n  /* Font smoothing */\n  --light-font-smoothing: auto;\n  --dark-font-smoothing: antialiased;\n  --font-smoothing: auto;\n\n  /* Compact density */\n  --compact-font-size-monospace-small: 9px;\n  --compact-font-size-monospace-normal: 11px;\n  --compact-font-size-monospace-large: 15px;\n  --compact-font-size-sans-small: 10px;\n  --compact-font-size-sans-normal: 12px;\n  --compact-font-size-sans-large: 14px;\n  --compact-line-height-data: 18px;\n  --compact-root-font-size: 16px;\n\n  /* Comfortable density */\n  --comfortable-font-size-monospace-small: 10px;\n  --comfortable-font-size-monospace-normal: 13px;\n  --comfortable-font-size-monospace-large: 17px;\n  --comfortable-font-size-sans-small: 12px;\n  --comfortable-font-size-sans-normal: 14px;\n  --comfortable-font-size-sans-large: 16px;\n  --comfortable-line-height-data: 22px;\n  --comfortable-root-font-size: 20px;\n\n  /* GitHub.com system fonts */\n  --font-family-monospace: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo,\n    Courier, monospace;\n  --font-family-sans: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica,\n    Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol;\n\n  /* Constant values shared between JS and CSS */\n  --interaction-commit-size: 10px;\n  --interaction-label-width: 200px;\n}\n", ""]);

// exports


/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "initialize", function() { return /* binding */ initialize; });

// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__(0);
var external_react_default = /*#__PURE__*/__webpack_require__.n(external_react_);

// EXTERNAL MODULE: ../react-devtools-shared/src/bridge.js
var src_bridge = __webpack_require__(48);

// EXTERNAL MODULE: ../react-devtools-shared/src/events.js
var events = __webpack_require__(25);

// EXTERNAL MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/util/util.js
var util = __webpack_require__(76);

// EXTERNAL MODULE: ../react-devtools-shared/src/constants.js
var constants = __webpack_require__(3);

// EXTERNAL MODULE: ../react-devtools-shared/src/types.js
var types = __webpack_require__(1);

// EXTERNAL MODULE: ../react-devtools-shared/src/utils.js
var utils = __webpack_require__(2);

// EXTERNAL MODULE: ../react-devtools-shared/src/storage.js
var storage = __webpack_require__(7);

// EXTERNAL MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/json5/dist/index.js
var dist = __webpack_require__(77);
var dist_default = /*#__PURE__*/__webpack_require__.n(dist);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/utils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function printElement(element, includeWeight = false) {
  let prefix = ' ';

  if (element.children.length > 0) {
    prefix = element.isCollapsed ? 'â–¸' : 'â–¾';
  }

  let key = '';

  if (element.key !== null) {
    key = ` key="${element.key}"`;
  }

  let hocDisplayNames = null;

  if (element.hocDisplayNames !== null) {
    hocDisplayNames = [...element.hocDisplayNames];
  }

  const hocs = hocDisplayNames === null ? '' : ` [${hocDisplayNames.join('][')}]`;
  let suffix = '';

  if (includeWeight) {
    suffix = ` (${element.isCollapsed ? 1 : element.weight})`;
  }

  return `${'  '.repeat(element.depth + 1)}${prefix} <${element.displayName || 'null'}${key}>${hocs}${suffix}`;
}
function printOwnersList(elements, includeWeight = false) {
  return elements.map(element => printElement(element, includeWeight)).join('\n');
}
function printStore(store, includeWeight = false) {
  const snapshotLines = [];
  let rootWeight = 0;
  store.roots.forEach(rootID => {
    const _ref = store.getElementByID(rootID),
          weight = _ref.weight;

    snapshotLines.push('[root]' + (includeWeight ? ` (${weight})` : ''));

    for (let i = rootWeight; i < rootWeight + weight; i++) {
      const element = store.getElementAtIndex(i);

      if (element == null) {
        throw Error(`Could not find element at index ${i}`);
      }

      snapshotLines.push(printElement(element, includeWeight));
    }

    rootWeight += weight;
  }); // Make sure the pretty-printed test align with the Store's reported number of total rows.

  if (rootWeight !== store.numElements) {
    throw Error(`Inconsistent Store state. Individual root weights (${rootWeight}) do not match total weight (${store.numElements})`);
  } // If roots have been unmounted, verify that they've been removed from maps.
  // This helps ensure the Store doesn't leak memory.


  store.assertExpectedRootMapSizes();
  return snapshotLines.join('\n');
} // We use JSON.parse to parse string values
// e.g. 'foo' is not valid JSON but it is a valid string
// so this method replaces e.g. 'foo' with "foo"

function sanitizeForParse(value) {
  if (typeof value === 'string') {
    if (value.length >= 2 && value.charAt(0) === "'" && value.charAt(value.length - 1) === "'") {
      return '"' + value.substr(1, value.length - 2) + '"';
    }
  }

  return value;
}
function smartParse(value) {
  switch (value) {
    case 'Infinity':
      return Infinity;

    case 'NaN':
      return NaN;

    case 'undefined':
      return undefined;

    default:
      return dist_default.a.parse(sanitizeForParse(value));
  }
}
function smartStringify(value) {
  if (typeof value === 'number') {
    if (Number.isNaN(value)) {
      return 'NaN';
    } else if (!Number.isFinite(value)) {
      return 'Infinity';
    }
  } else if (value === undefined) {
    return 'undefined';
  }

  return JSON.stringify(value);
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/utils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

const commitGradient = ['var(--color-commit-gradient-0)', 'var(--color-commit-gradient-1)', 'var(--color-commit-gradient-2)', 'var(--color-commit-gradient-3)', 'var(--color-commit-gradient-4)', 'var(--color-commit-gradient-5)', 'var(--color-commit-gradient-6)', 'var(--color-commit-gradient-7)', 'var(--color-commit-gradient-8)', 'var(--color-commit-gradient-9)']; // Combines info from the Store (frontend) and renderer interfaces (backend) into the format required by the Profiler UI.
// This format can then be quickly exported (and re-imported).

function prepareProfilingDataFrontendFromBackendAndStore(dataBackends, operationsByRootID, snapshotsByRootID) {
  const dataForRoots = new Map();
  dataBackends.forEach(dataBackend => {
    dataBackend.dataForRoots.forEach(({
      commitData,
      displayName,
      initialTreeBaseDurations,
      interactionCommits,
      interactions,
      rootID
    }) => {
      const operations = operationsByRootID.get(rootID);

      if (operations == null) {
        throw Error(`Could not find profiling operations for root ${rootID}`);
      }

      const snapshots = snapshotsByRootID.get(rootID);

      if (snapshots == null) {
        throw Error(`Could not find profiling snapshots for root ${rootID}`);
      } // Do not filter empty commits from the profiler data!
      // We used to do this, but it was error prone (see #18798).
      // A commit may appear to be empty (no actual durations) because of component filters,
      // but filtering these empty commits causes interaction commit indices to be off by N.
      // This not only corrupts the resulting data, but also potentially causes runtime errors.
      //
      // For that matter, hiding "empty" commits might cause confusion too.
      // A commit *did happen* even if none of the components the Profiler is showing were involved.


      const convertedCommitData = commitData.map((commitDataBackend, commitIndex) => ({
        changeDescriptions: commitDataBackend.changeDescriptions != null ? new Map(commitDataBackend.changeDescriptions) : null,
        duration: commitDataBackend.duration,
        fiberActualDurations: new Map(commitDataBackend.fiberActualDurations),
        fiberSelfDurations: new Map(commitDataBackend.fiberSelfDurations),
        interactionIDs: commitDataBackend.interactionIDs,
        priorityLevel: commitDataBackend.priorityLevel,
        timestamp: commitDataBackend.timestamp
      }));
      dataForRoots.set(rootID, {
        commitData: convertedCommitData,
        displayName,
        initialTreeBaseDurations: new Map(initialTreeBaseDurations),
        interactionCommits: new Map(interactionCommits),
        interactions: new Map(interactions),
        operations,
        rootID,
        snapshots
      });
    });
  });
  return {
    dataForRoots,
    imported: false
  };
} // Converts a Profiling data export into the format required by the Store.

function prepareProfilingDataFrontendFromExport(profilingDataExport) {
  const version = profilingDataExport.version;

  if (version !== constants["h" /* PROFILER_EXPORT_VERSION */]) {
    throw Error(`Unsupported profiler export version "${version}"`);
  }

  const dataForRoots = new Map();
  profilingDataExport.dataForRoots.forEach(({
    commitData,
    displayName,
    initialTreeBaseDurations,
    interactionCommits,
    interactions,
    operations,
    rootID,
    snapshots
  }) => {
    dataForRoots.set(rootID, {
      commitData: commitData.map(({
        changeDescriptions,
        duration,
        fiberActualDurations,
        fiberSelfDurations,
        interactionIDs,
        priorityLevel,
        timestamp
      }) => ({
        changeDescriptions: changeDescriptions != null ? new Map(changeDescriptions) : null,
        duration,
        fiberActualDurations: new Map(fiberActualDurations),
        fiberSelfDurations: new Map(fiberSelfDurations),
        interactionIDs,
        priorityLevel,
        timestamp
      })),
      displayName,
      initialTreeBaseDurations: new Map(initialTreeBaseDurations),
      interactionCommits: new Map(interactionCommits),
      interactions: new Map(interactions),
      operations,
      rootID,
      snapshots: new Map(snapshots)
    });
  });
  return {
    dataForRoots,
    imported: true
  };
} // Converts a Store Profiling data into a format that can be safely (JSON) serialized for export.

function prepareProfilingDataExport(profilingDataFrontend) {
  const dataForRoots = [];
  profilingDataFrontend.dataForRoots.forEach(({
    commitData,
    displayName,
    initialTreeBaseDurations,
    interactionCommits,
    interactions,
    operations,
    rootID,
    snapshots
  }) => {
    dataForRoots.push({
      commitData: commitData.map(({
        changeDescriptions,
        duration,
        fiberActualDurations,
        fiberSelfDurations,
        interactionIDs,
        priorityLevel,
        timestamp
      }) => ({
        changeDescriptions: changeDescriptions != null ? Array.from(changeDescriptions.entries()) : null,
        duration,
        fiberActualDurations: Array.from(fiberActualDurations.entries()),
        fiberSelfDurations: Array.from(fiberSelfDurations.entries()),
        interactionIDs,
        priorityLevel,
        timestamp
      })),
      displayName,
      initialTreeBaseDurations: Array.from(initialTreeBaseDurations.entries()),
      interactionCommits: Array.from(interactionCommits.entries()),
      interactions: Array.from(interactions.entries()),
      operations,
      rootID,
      snapshots: Array.from(snapshots.entries())
    });
  });
  return {
    version: constants["h" /* PROFILER_EXPORT_VERSION */],
    dataForRoots
  };
}
const getGradientColor = value => {
  const maxIndex = commitGradient.length - 1;
  let index;

  if (Number.isNaN(value)) {
    index = 0;
  } else if (!Number.isFinite(value)) {
    index = maxIndex;
  } else {
    index = Math.max(0, Math.min(maxIndex, value)) * maxIndex;
  }

  return commitGradient[Math.round(index)];
};
const formatDuration = duration => Math.round(duration * 10) / 10 || '<0.1';
const formatPercentage = percentage => Math.round(percentage * 100);
const formatTime = timestamp => Math.round(Math.round(timestamp) / 100) / 10;
const scale = (minValue, maxValue, minRange, maxRange) => (value, fallbackValue) => maxValue - minValue === 0 ? fallbackValue : (value - minValue) / (maxValue - minValue) * (maxRange - minRange);
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/CommitTreeBuilder.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */





const debug = (methodName, ...args) => {
  if (constants["q" /* __DEBUG__ */]) {
    console.log(`%cCommitTreeBuilder %c${methodName}`, 'color: pink; font-weight: bold;', 'font-weight: bold;', ...args);
  }
};

const rootToCommitTreeMap = new Map();
function getCommitTree({
  commitIndex,
  profilerStore,
  rootID
}) {
  if (!rootToCommitTreeMap.has(rootID)) {
    rootToCommitTreeMap.set(rootID, []);
  }

  const commitTrees = rootToCommitTreeMap.get(rootID);

  if (commitIndex < commitTrees.length) {
    return commitTrees[commitIndex];
  }

  const profilingData = profilerStore.profilingData;

  if (profilingData === null) {
    throw Error(`No profiling data available`);
  }

  const dataForRoot = profilingData.dataForRoots.get(rootID);

  if (dataForRoot == null) {
    throw Error(`Could not find profiling data for root "${rootID}"`);
  }

  const operations = dataForRoot.operations; // Commits are generated sequentially and cached.
  // If this is the very first commit, start with the cached snapshot and apply the first mutation.
  // Otherwise load (or generate) the previous commit and append a mutation to it.

  if (commitIndex === 0) {
    const nodes = new Map(); // Construct the initial tree.

    recursivelyInitializeTree(rootID, 0, nodes, dataForRoot); // Mutate the tree

    if (operations != null && commitIndex < operations.length) {
      const commitTree = updateTree({
        nodes,
        rootID
      }, operations[commitIndex]);

      if (constants["q" /* __DEBUG__ */]) {
        __printTree(commitTree);
      }

      commitTrees.push(commitTree);
      return commitTree;
    }
  } else {
    const previousCommitTree = getCommitTree({
      commitIndex: commitIndex - 1,
      profilerStore,
      rootID
    });

    if (operations != null && commitIndex < operations.length) {
      const commitTree = updateTree(previousCommitTree, operations[commitIndex]);

      if (constants["q" /* __DEBUG__ */]) {
        __printTree(commitTree);
      }

      commitTrees.push(commitTree);
      return commitTree;
    }
  }

  throw Error(`getCommitTree(): Unable to reconstruct tree for root "${rootID}" and commit ${commitIndex}`);
}

function recursivelyInitializeTree(id, parentID, nodes, dataForRoot) {
  const node = dataForRoot.snapshots.get(id);

  if (node != null) {
    nodes.set(id, {
      id,
      children: node.children,
      displayName: node.displayName,
      hocDisplayNames: node.hocDisplayNames,
      key: node.key,
      parentID,
      treeBaseDuration: dataForRoot.initialTreeBaseDurations.get(id),
      type: node.type
    });
    node.children.forEach(childID => recursivelyInitializeTree(childID, id, nodes, dataForRoot));
  }
}

function updateTree(commitTree, operations) {
  // Clone the original tree so edits don't affect it.
  const nodes = new Map(commitTree.nodes); // Clone nodes before mutating them so edits don't affect them.

  const getClonedNode = id => {
    const clonedNode = Object.assign({}, nodes.get(id));
    nodes.set(id, clonedNode);
    return clonedNode;
  };

  let i = 2;
  let id = null; // Reassemble the string table.

  const stringTable = [null // ID = 0 corresponds to the null string.
  ];
  const stringTableSize = operations[i++];
  const stringTableEnd = i + stringTableSize;

  while (i < stringTableEnd) {
    const nextLength = operations[i++];
    const nextString = Object(utils["s" /* utfDecodeString */])(operations.slice(i, i + nextLength));
    stringTable.push(nextString);
    i += nextLength;
  }

  while (i < operations.length) {
    const operation = operations[i];

    switch (operation) {
      case constants["l" /* TREE_OPERATION_ADD */]:
        id = operations[i + 1];
        const type = operations[i + 2];
        i += 3;

        if (nodes.has(id)) {
          throw new Error('Commit tree already contains fiber ' + id + '. This is a bug in React DevTools.');
        }

        if (type === types["m" /* ElementTypeRoot */]) {
          i++; // supportsProfiling flag

          i++; // hasOwnerMetadata flag

          if (constants["q" /* __DEBUG__ */]) {
            debug('Add', `new root fiber ${id}`);
          }

          const node = {
            children: [],
            displayName: null,
            hocDisplayNames: null,
            id,
            key: null,
            parentID: 0,
            treeBaseDuration: 0,
            // This will be updated by a subsequent operation
            type
          };
          nodes.set(id, node);
        } else {
          const parentID = operations[i];
          i++;
          i++; // ownerID

          const displayNameStringID = operations[i];
          const displayName = stringTable[displayNameStringID];
          i++;
          const keyStringID = operations[i];
          const key = stringTable[keyStringID];
          i++;

          if (constants["q" /* __DEBUG__ */]) {
            debug('Add', `fiber ${id} (${displayName || 'null'}) as child of ${parentID}`);
          }

          const parentNode = getClonedNode(parentID);
          parentNode.children = parentNode.children.concat(id);
          const node = {
            children: [],
            displayName,
            hocDisplayNames: null,
            id,
            key,
            parentID,
            treeBaseDuration: 0,
            // This will be updated by a subsequent operation
            type
          };
          nodes.set(id, node);
        }

        break;

      case constants["m" /* TREE_OPERATION_REMOVE */]:
        {
          const removeLength = operations[i + 1];
          i += 2;

          for (let removeIndex = 0; removeIndex < removeLength; removeIndex++) {
            id = operations[i];
            i++;

            if (!nodes.has(id)) {
              throw new Error('Commit tree does not contain fiber ' + id + '. This is a bug in React DevTools.');
            }

            const node = getClonedNode(id);
            const parentID = node.parentID;
            nodes.delete(id);

            if (!nodes.has(parentID)) {// No-op
            } else {
              const parentNode = getClonedNode(parentID);

              if (constants["q" /* __DEBUG__ */]) {
                debug('Remove', `fiber ${id} from parent ${parentID}`);
              }

              parentNode.children = parentNode.children.filter(childID => childID !== id);
            }
          }

          break;
        }

      case constants["n" /* TREE_OPERATION_REORDER_CHILDREN */]:
        {
          id = operations[i + 1];
          const numChildren = operations[i + 2];
          const children = operations.slice(i + 3, i + 3 + numChildren);
          i = i + 3 + numChildren;

          if (constants["q" /* __DEBUG__ */]) {
            debug('Re-order', `fiber ${id} children ${children.join(',')}`);
          }

          const node = getClonedNode(id);
          node.children = Array.from(children);
          break;
        }

      case constants["o" /* TREE_OPERATION_UPDATE_TREE_BASE_DURATION */]:
        {
          id = operations[i + 1];
          const node = getClonedNode(id);
          node.treeBaseDuration = operations[i + 2] / 1000; // Convert microseconds back to milliseconds;

          if (constants["q" /* __DEBUG__ */]) {
            debug('Update', `fiber ${id} treeBaseDuration to ${node.treeBaseDuration}`);
          }

          i += 3;
          break;
        }

      default:
        throw Error(`Unsupported Bridge operation ${operation}`);
    }
  }

  return {
    nodes,
    rootID: commitTree.rootID
  };
}

function invalidateCommitTrees() {
  rootToCommitTreeMap.clear();
} // DEBUG

const __printTree = commitTree => {
  if (constants["q" /* __DEBUG__ */]) {
    const nodes = commitTree.nodes,
          rootID = commitTree.rootID;
    console.group('__printTree()');
    const queue = [rootID, 0];

    while (queue.length > 0) {
      const id = queue.shift();
      const depth = queue.shift();
      const node = nodes.get(id);

      if (node == null) {
        throw Error(`Could not find node with id "${id}" in commit tree`);
      }

      console.log(`${'â€¢'.repeat(depth)}${node.id}:${node.displayName || ''} ${node.key ? `key:"${node.key}"` : ''} (${node.treeBaseDuration})`);
      node.children.forEach(childID => {
        queue.push(childID, depth + 1);
      });
    }

    console.groupEnd();
  }
};
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/FlamegraphChartBuilder.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


const cachedChartData = new Map();
function getChartData({
  commitIndex,
  commitTree,
  profilerStore,
  rootID
}) {
  const commitDatum = profilerStore.getCommitData(rootID, commitIndex);
  const fiberActualDurations = commitDatum.fiberActualDurations,
        fiberSelfDurations = commitDatum.fiberSelfDurations;
  const nodes = commitTree.nodes;
  const chartDataKey = `${rootID}-${commitIndex}`;

  if (cachedChartData.has(chartDataKey)) {
    return cachedChartData.get(chartDataKey);
  }

  const idToDepthMap = new Map();
  const renderPathNodes = new Set();
  const rows = [];
  let maxDepth = 0;
  let maxSelfDuration = 0; // Generate flame graph structure using tree base durations.

  const walkTree = (id, rightOffset, currentDepth) => {
    idToDepthMap.set(id, currentDepth);
    const node = nodes.get(id);

    if (node == null) {
      throw Error(`Could not find node with id "${id}" in commit tree`);
    }

    const children = node.children,
          displayName = node.displayName,
          hocDisplayNames = node.hocDisplayNames,
          key = node.key,
          treeBaseDuration = node.treeBaseDuration;
    const actualDuration = fiberActualDurations.get(id) || 0;
    const selfDuration = fiberSelfDurations.get(id) || 0;
    const didRender = fiberActualDurations.has(id);
    const name = displayName || 'Anonymous';
    const maybeKey = key !== null ? ` key="${key}"` : '';
    let maybeBadge = '';

    if (hocDisplayNames !== null && hocDisplayNames.length > 0) {
      maybeBadge = ` (${hocDisplayNames[0]})`;
    }

    let label = `${name}${maybeBadge}${maybeKey}`;

    if (didRender) {
      label += ` (${formatDuration(selfDuration)}ms of ${formatDuration(actualDuration)}ms)`;
    }

    maxDepth = Math.max(maxDepth, currentDepth);
    maxSelfDuration = Math.max(maxSelfDuration, selfDuration);
    const chartNode = {
      actualDuration,
      didRender,
      id,
      label,
      name,
      offset: rightOffset - treeBaseDuration,
      selfDuration,
      treeBaseDuration
    };

    if (currentDepth > rows.length) {
      rows.push([chartNode]);
    } else {
      rows[currentDepth - 1].push(chartNode);
    }

    for (let i = children.length - 1; i >= 0; i--) {
      const childID = children[i];
      const childChartNode = walkTree(childID, rightOffset, currentDepth + 1);
      rightOffset -= childChartNode.treeBaseDuration;
    }

    return chartNode;
  };

  let baseDuration = 0; // Special case to handle unmounted roots.

  if (nodes.size > 0) {
    // Skip over the root; we don't want to show it in the flamegraph.
    const root = nodes.get(rootID);

    if (root == null) {
      throw Error(`Could not find root node with id "${rootID}" in commit tree`);
    } // Don't assume a single root.
    // Component filters or Fragments might lead to multiple "roots" in a flame graph.


    for (let i = root.children.length - 1; i >= 0; i--) {
      const id = root.children[i];
      const node = nodes.get(id);

      if (node == null) {
        throw Error(`Could not find node with id "${id}" in commit tree`);
      }

      baseDuration += node.treeBaseDuration;
      walkTree(id, baseDuration, 1);
    }

    fiberActualDurations.forEach((duration, id) => {
      let node = nodes.get(id);

      if (node != null) {
        let currentID = node.parentID;

        while (currentID !== 0) {
          if (renderPathNodes.has(currentID)) {
            // We've already walked this path; we can skip it.
            break;
          } else {
            renderPathNodes.add(currentID);
          }

          node = nodes.get(currentID);
          currentID = node != null ? node.parentID : 0;
        }
      }
    });
  }

  const chartData = {
    baseDuration,
    depth: maxDepth,
    idToDepthMap,
    maxSelfDuration,
    renderPathNodes,
    rows
  };
  cachedChartData.set(chartDataKey, chartData);
  return chartData;
}
function invalidateChartData() {
  cachedChartData.clear();
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/InteractionsChartBuilder.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

const InteractionsChartBuilder_cachedChartData = new Map();
function InteractionsChartBuilder_getChartData({
  profilerStore,
  rootID
}) {
  if (InteractionsChartBuilder_cachedChartData.has(rootID)) {
    return InteractionsChartBuilder_cachedChartData.get(rootID);
  }

  const dataForRoot = profilerStore.getDataForRoot(rootID);

  if (dataForRoot == null) {
    throw Error(`Could not find profiling data for root "${rootID}"`);
  }

  const commitData = dataForRoot.commitData,
        interactions = dataForRoot.interactions;
  const lastInteractionTime = commitData.length > 0 ? commitData[commitData.length - 1].timestamp : 0;
  let maxCommitDuration = 0;
  commitData.forEach(commitDatum => {
    maxCommitDuration = Math.max(maxCommitDuration, commitDatum.duration);
  });
  const chartData = {
    interactions: Array.from(interactions.values()),
    lastInteractionTime,
    maxCommitDuration
  };
  InteractionsChartBuilder_cachedChartData.set(rootID, chartData);
  return chartData;
}
function InteractionsChartBuilder_invalidateChartData() {
  InteractionsChartBuilder_cachedChartData.clear();
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/RankedChartBuilder.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



const RankedChartBuilder_cachedChartData = new Map();
function RankedChartBuilder_getChartData({
  commitIndex,
  commitTree,
  profilerStore,
  rootID
}) {
  const commitDatum = profilerStore.getCommitData(rootID, commitIndex);
  const fiberActualDurations = commitDatum.fiberActualDurations,
        fiberSelfDurations = commitDatum.fiberSelfDurations;
  const nodes = commitTree.nodes;
  const chartDataKey = `${rootID}-${commitIndex}`;

  if (RankedChartBuilder_cachedChartData.has(chartDataKey)) {
    return RankedChartBuilder_cachedChartData.get(chartDataKey);
  }

  let maxSelfDuration = 0;
  const chartNodes = [];
  fiberActualDurations.forEach((actualDuration, id) => {
    const node = nodes.get(id);

    if (node == null) {
      throw Error(`Could not find node with id "${id}" in commit tree`);
    }

    const displayName = node.displayName,
          key = node.key,
          parentID = node.parentID,
          type = node.type; // Don't show the root node in this chart.

    if (parentID === 0) {
      return;
    }

    const selfDuration = fiberSelfDurations.get(id) || 0;
    maxSelfDuration = Math.max(maxSelfDuration, selfDuration);
    const name = displayName || 'Anonymous';
    const maybeKey = key !== null ? ` key="${key}"` : '';
    let maybeBadge = '';

    if (type === types["g" /* ElementTypeForwardRef */]) {
      maybeBadge = ' (ForwardRef)';
    } else if (type === types["j" /* ElementTypeMemo */]) {
      maybeBadge = ' (Memo)';
    }

    const label = `${name}${maybeBadge}${maybeKey} (${formatDuration(selfDuration)}ms)`;
    chartNodes.push({
      id,
      label,
      name,
      value: selfDuration
    });
  });
  const chartData = {
    maxValue: maxSelfDuration,
    nodes: chartNodes.sort((a, b) => b.value - a.value)
  };
  RankedChartBuilder_cachedChartData.set(chartDataKey, chartData);
  return chartData;
}
function RankedChartBuilder_invalidateChartData() {
  RankedChartBuilder_cachedChartData.clear();
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/ProfilingCache.js
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */





class ProfilingCache_ProfilingCache {
  constructor(profilerStore) {
    _defineProperty(this, "_fiberCommits", new Map());

    _defineProperty(this, "getCommitTree", ({
      commitIndex,
      rootID
    }) => getCommitTree({
      commitIndex,
      profilerStore: this._profilerStore,
      rootID
    }));

    _defineProperty(this, "getFiberCommits", ({
      fiberID,
      rootID
    }) => {
      const cachedFiberCommits = this._fiberCommits.get(fiberID);

      if (cachedFiberCommits != null) {
        return cachedFiberCommits;
      }

      const fiberCommits = [];

      const dataForRoot = this._profilerStore.getDataForRoot(rootID);

      dataForRoot.commitData.forEach((commitDatum, commitIndex) => {
        if (commitDatum.fiberActualDurations.has(fiberID)) {
          fiberCommits.push(commitIndex);
        }
      });

      this._fiberCommits.set(fiberID, fiberCommits);

      return fiberCommits;
    });

    _defineProperty(this, "getFlamegraphChartData", ({
      commitIndex,
      commitTree,
      rootID
    }) => getChartData({
      commitIndex,
      commitTree,
      profilerStore: this._profilerStore,
      rootID
    }));

    _defineProperty(this, "getInteractionsChartData", ({
      rootID
    }) => InteractionsChartBuilder_getChartData({
      profilerStore: this._profilerStore,
      rootID
    }));

    _defineProperty(this, "getRankedChartData", ({
      commitIndex,
      commitTree,
      rootID
    }) => RankedChartBuilder_getChartData({
      commitIndex,
      commitTree,
      profilerStore: this._profilerStore,
      rootID
    }));

    this._profilerStore = profilerStore;
  }

  invalidate() {
    this._fiberCommits.clear();

    invalidateCommitTrees();
    invalidateChartData();
    InteractionsChartBuilder_invalidateChartData();
    RankedChartBuilder_invalidateChartData();
  }

}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/ProfilerStore.js
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function ProfilerStore_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */




class ProfilerStore_ProfilerStore extends events["a" /* default */] {
  // Suspense cache for lazily calculating derived profiling data.
  // Temporary store of profiling data from the backend renderer(s).
  // This data will be converted to the ProfilingDataFrontend format after being collected from all renderers.
  // Data from the most recently completed profiling session,
  // or data that has been imported from a previously exported session.
  // This object contains all necessary data to drive the Profiler UI interface,
  // even though some of it is lazily parsed/derived via the ProfilingCache.
  // Snapshot of all attached renderer IDs.
  // Once profiling is finished, this snapshot will be used to query renderers for profiling data.
  //
  // This map is initialized when profiling starts and updated when a new root is added while profiling;
  // Upon completion, it is converted into the exportable ProfilingDataFrontend format.
  // Snapshot of the state of the main Store (including all roots) when profiling started.
  // Once profiling is finished, this snapshot can be used along with "operations" messages emitted during profiling,
  // to reconstruct the state of each root for each commit.
  // It's okay to use a single root to store this information because node IDs are unique across all roots.
  //
  // This map is initialized when profiling starts and updated when a new root is added while profiling;
  // Upon completion, it is converted into the exportable ProfilingDataFrontend format.
  // Map of root (id) to a list of tree mutation that occur during profiling.
  // Once profiling is finished, these mutations can be used, along with the initial tree snapshots,
  // to reconstruct the state of each root for each commit.
  //
  // This map is only updated while profiling is in progress;
  // Upon completion, it is converted into the exportable ProfilingDataFrontend format.
  // The backend is currently profiling.
  // When profiling is in progress, operations are stored so that we can later reconstruct past commit trees.
  // Tracks whether a specific renderer logged any profiling data during the most recent session.
  // After profiling, data is requested from each attached renderer using this queue.
  // So long as this queue is not empty, the store is retrieving and processing profiling data from the backend.
  constructor(bridge, store, defaultIsProfiling) {
    super();

    ProfilerStore_defineProperty(this, "_dataBackends", []);

    ProfilerStore_defineProperty(this, "_dataFrontend", null);

    ProfilerStore_defineProperty(this, "_initialRendererIDs", new Set());

    ProfilerStore_defineProperty(this, "_initialSnapshotsByRootID", new Map());

    ProfilerStore_defineProperty(this, "_inProgressOperationsByRootID", new Map());

    ProfilerStore_defineProperty(this, "_isProfiling", false);

    ProfilerStore_defineProperty(this, "_rendererIDsThatReportedProfilingData", new Set());

    ProfilerStore_defineProperty(this, "_rendererQueue", new Set());

    ProfilerStore_defineProperty(this, "_takeProfilingSnapshotRecursive", (elementID, profilingSnapshots) => {
      const element = this._store.getElementByID(elementID);

      if (element !== null) {
        const snapshotNode = {
          id: elementID,
          children: element.children.slice(0),
          displayName: element.displayName,
          hocDisplayNames: element.hocDisplayNames,
          key: element.key,
          type: element.type
        };
        profilingSnapshots.set(elementID, snapshotNode);
        element.children.forEach(childID => this._takeProfilingSnapshotRecursive(childID, profilingSnapshots));
      }
    });

    ProfilerStore_defineProperty(this, "onBridgeOperations", operations => {
      // The first two values are always rendererID and rootID
      const rendererID = operations[0];
      const rootID = operations[1];

      if (this._isProfiling) {
        let profilingOperations = this._inProgressOperationsByRootID.get(rootID);

        if (profilingOperations == null) {
          profilingOperations = [operations];

          this._inProgressOperationsByRootID.set(rootID, profilingOperations);
        } else {
          profilingOperations.push(operations);
        }

        if (!this._initialRendererIDs.has(rendererID)) {
          this._initialRendererIDs.add(rendererID);
        }

        if (!this._initialSnapshotsByRootID.has(rootID)) {
          this._initialSnapshotsByRootID.set(rootID, new Map());
        }

        this._rendererIDsThatReportedProfilingData.add(rendererID);
      }
    });

    ProfilerStore_defineProperty(this, "onBridgeProfilingData", dataBackend => {
      if (this._isProfiling) {
        // This should never happen, but if it does- ignore previous profiling data.
        return;
      }

      const rendererID = dataBackend.rendererID;

      if (!this._rendererQueue.has(rendererID)) {
        throw Error(`Unexpected profiling data update from renderer "${rendererID}"`);
      }

      this._dataBackends.push(dataBackend);

      this._rendererQueue.delete(rendererID);

      if (this._rendererQueue.size === 0) {
        this._dataFrontend = prepareProfilingDataFrontendFromBackendAndStore(this._dataBackends, this._inProgressOperationsByRootID, this._initialSnapshotsByRootID);

        this._dataBackends.splice(0);

        this.emit('isProcessingData');
      }
    });

    ProfilerStore_defineProperty(this, "onBridgeShutdown", () => {
      this._bridge.removeListener('operations', this.onBridgeOperations);

      this._bridge.removeListener('profilingData', this.onBridgeProfilingData);

      this._bridge.removeListener('profilingStatus', this.onProfilingStatus);

      this._bridge.removeListener('shutdown', this.onBridgeShutdown);
    });

    ProfilerStore_defineProperty(this, "onProfilingStatus", isProfiling => {
      if (isProfiling) {
        this._dataBackends.splice(0);

        this._dataFrontend = null;

        this._initialRendererIDs.clear();

        this._initialSnapshotsByRootID.clear();

        this._inProgressOperationsByRootID.clear();

        this._rendererIDsThatReportedProfilingData.clear();

        this._rendererQueue.clear(); // Record all renderer IDs initially too (in case of unmount)
        // eslint-disable-next-line no-for-of-loops/no-for-of-loops


        var _iterator = _createForOfIteratorHelper(this._store.rootIDToRendererID.values()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            const rendererID = _step.value;

            if (!this._initialRendererIDs.has(rendererID)) {
              this._initialRendererIDs.add(rendererID);
            }
          } // Record snapshot of tree at the time profiling is started.
          // This info is required to handle cases of e.g. nodes being removed during profiling.

        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        this._store.roots.forEach(rootID => {
          const profilingSnapshots = new Map();

          this._initialSnapshotsByRootID.set(rootID, profilingSnapshots);

          this._takeProfilingSnapshotRecursive(rootID, profilingSnapshots);
        });
      }

      if (this._isProfiling !== isProfiling) {
        this._isProfiling = isProfiling; // Invalidate suspense cache if profiling data is being (re-)recorded.
        // Note that we clear again, in case any views read from the cache while profiling.
        // (That would have resolved a now-stale value without any profiling data.)

        this._cache.invalidate();

        this.emit('isProfiling'); // If we've just finished a profiling session, we need to fetch data stored in each renderer interface
        // and re-assemble it on the front-end into a format (ProfilingDataFrontend) that can power the Profiler UI.
        // During this time, DevTools UI should probably not be interactive.

        if (!isProfiling) {
          this._dataBackends.splice(0);

          this._rendererQueue.clear(); // Only request data from renderers that actually logged it.
          // This avoids unnecessary bridge requests and also avoids edge case mixed renderer bugs.
          // (e.g. when v15 and v16 are both present)


          this._rendererIDsThatReportedProfilingData.forEach(rendererID => {
            if (!this._rendererQueue.has(rendererID)) {
              this._rendererQueue.add(rendererID);

              this._bridge.send('getProfilingData', {
                rendererID
              });
            }
          });

          this.emit('isProcessingData');
        }
      }
    });

    this._bridge = bridge;
    this._isProfiling = defaultIsProfiling;
    this._store = store;
    bridge.addListener('operations', this.onBridgeOperations);
    bridge.addListener('profilingData', this.onBridgeProfilingData);
    bridge.addListener('profilingStatus', this.onProfilingStatus);
    bridge.addListener('shutdown', this.onBridgeShutdown); // It's possible that profiling has already started (e.g. "reload and start profiling")
    // so the frontend needs to ask the backend for its status after mounting.

    bridge.send('getProfilingStatus');
    this._cache = new ProfilingCache_ProfilingCache(this);
  }

  getCommitData(rootID, commitIndex) {
    if (this._dataFrontend !== null) {
      const dataForRoot = this._dataFrontend.dataForRoots.get(rootID);

      if (dataForRoot != null) {
        const commitDatum = dataForRoot.commitData[commitIndex];

        if (commitDatum != null) {
          return commitDatum;
        }
      }
    }

    throw Error(`Could not find commit data for root "${rootID}" and commit ${commitIndex}`);
  }

  getDataForRoot(rootID) {
    if (this._dataFrontend !== null) {
      const dataForRoot = this._dataFrontend.dataForRoots.get(rootID);

      if (dataForRoot != null) {
        return dataForRoot;
      }
    }

    throw Error(`Could not find commit data for root "${rootID}"`);
  } // Profiling data has been recorded for at least one root.


  get didRecordCommits() {
    return this._dataFrontend !== null && this._dataFrontend.dataForRoots.size > 0;
  }

  get isProcessingData() {
    return this._rendererQueue.size > 0 || this._dataBackends.length > 0;
  }

  get isProfiling() {
    return this._isProfiling;
  }

  get profilingCache() {
    return this._cache;
  }

  get profilingData() {
    return this._dataFrontend;
  }

  set profilingData(value) {
    if (this._isProfiling) {
      console.warn('Profiling data cannot be updated while profiling is in progress.');
      return;
    }

    this._dataBackends.splice(0);

    this._dataFrontend = value;

    this._initialRendererIDs.clear();

    this._initialSnapshotsByRootID.clear();

    this._inProgressOperationsByRootID.clear();

    this._cache.invalidate();

    this.emit('profilingData');
  }

  clear() {
    this._dataBackends.splice(0);

    this._dataFrontend = null;

    this._initialRendererIDs.clear();

    this._initialSnapshotsByRootID.clear();

    this._inProgressOperationsByRootID.clear();

    this._rendererQueue.clear(); // Invalidate suspense cache if profiling data is being (re-)recorded.
    // Note that we clear now because any existing data is "stale".


    this._cache.invalidate();

    this.emit('profilingData');
  }

  startProfiling() {
    this._bridge.send('startProfiling', this._store.recordChangeDescriptions); // Don't actually update the local profiling boolean yet!
    // Wait for onProfilingStatus() to confirm the status has changed.
    // This ensures the frontend and backend are in sync wrt which commits were profiled.
    // We do this to avoid mismatches on e.g. CommitTreeBuilder that would cause errors.

  }

  stopProfiling() {
    this._bridge.send('stopProfiling'); // Don't actually update the local profiling boolean yet!
    // Wait for onProfilingStatus() to confirm the status has changed.
    // This ensures the frontend and backend are in sync wrt which commits were profiled.
    // We do this to avoid mismatches on e.g. CommitTreeBuilder that would cause errors.

  }

}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/store.js
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { store_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || store_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function store_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return store_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return store_arrayLikeToArray(o, minLen); }

function store_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function store_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */










const store_debug = (methodName, ...args) => {
  if (constants["q" /* __DEBUG__ */]) {
    console.log(`%cStore %c${methodName}`, 'color: green; font-weight: bold;', 'font-weight: bold;', ...args);
  }
};

const LOCAL_STORAGE_COLLAPSE_ROOTS_BY_DEFAULT_KEY = 'React::DevTools::collapseNodesByDefault';
const LOCAL_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = 'React::DevTools::recordChangeDescriptions';

/**
 * The store is the single source of truth for updates from the backend.
 * ContextProviders can subscribe to the Store for specific things they want to provide.
 */
class store_Store extends events["a" /* default */] {
  // Should new nodes be collapsed by default when added to the tree?
  // At least one of the injected renderers contains (DEV only) owner metadata.
  // Map of ID to (mutable) Element.
  // Elements are mutated to avoid excessive cloning during tree updates.
  // The InspectedElementContext also relies on this mutability for its WeakMap usage.
  // Should the React Native style editor panel be shown?
  // Can the backend use the Storage API (e.g. localStorage)?
  // If not, features like reload-and-profile will not work correctly and must be disabled.
  // Map of element (id) to the set of elements (ids) it owns.
  // This map enables getOwnersListForElement() to avoid traversing the entire tree.
  // Incremented each time the store is mutated.
  // This enables a passive effect to detect a mutation between render and commit phase.
  // This Array must be treated as immutable!
  // Passive effects will check it for changes between render and mount.
  // Renderer ID is needed to support inspection fiber props, state, and hooks.
  // These options may be initially set by a confiugraiton option when constructing the Store.
  // In the case of "supportsProfiling", the option may be updated based on the injected renderers.
  // Total number of visible elements (within all roots).
  // Used for windowing purposes.
  constructor(bridge, config) {
    super();

    store_defineProperty(this, "_collapseNodesByDefault", true);

    store_defineProperty(this, "_hasOwnerMetadata", false);

    store_defineProperty(this, "_idToElement", new Map());

    store_defineProperty(this, "_isNativeStyleEditorSupported", false);

    store_defineProperty(this, "_isBackendStorageAPISupported", false);

    store_defineProperty(this, "_nativeStyleEditorValidAttributes", null);

    store_defineProperty(this, "_ownersMap", new Map());

    store_defineProperty(this, "_recordChangeDescriptions", false);

    store_defineProperty(this, "_revision", 0);

    store_defineProperty(this, "_roots", []);

    store_defineProperty(this, "_rootIDToCapabilities", new Map());

    store_defineProperty(this, "_rootIDToRendererID", new Map());

    store_defineProperty(this, "_supportsNativeInspection", true);

    store_defineProperty(this, "_supportsProfiling", false);

    store_defineProperty(this, "_supportsReloadAndProfile", false);

    store_defineProperty(this, "_supportsTraceUpdates", false);

    store_defineProperty(this, "_unsupportedRendererVersionDetected", false);

    store_defineProperty(this, "_weightAcrossRoots", 0);

    store_defineProperty(this, "_adjustParentTreeWeight", (parentElement, weightDelta) => {
      let isInsideCollapsedSubTree = false;

      while (parentElement != null) {
        parentElement.weight += weightDelta; // Additions and deletions within a collapsed subtree should not bubble beyond the collapsed parent.
        // Their weight will bubble up when the parent is expanded.

        if (parentElement.isCollapsed) {
          isInsideCollapsedSubTree = true;
          break;
        }

        parentElement = this._idToElement.get(parentElement.parentID);
      } // Additions and deletions within a collapsed subtree should not affect the overall number of elements.


      if (!isInsideCollapsedSubTree) {
        this._weightAcrossRoots += weightDelta;
      }
    });

    store_defineProperty(this, "onBridgeNativeStyleEditorSupported", ({
      isSupported,
      validAttributes
    }) => {
      this._isNativeStyleEditorSupported = isSupported;
      this._nativeStyleEditorValidAttributes = validAttributes || null;
      this.emit('supportsNativeStyleEditor');
    });

    store_defineProperty(this, "onBridgeOperations", operations => {
      if (constants["q" /* __DEBUG__ */]) {
        console.groupCollapsed('onBridgeOperations');
        store_debug('onBridgeOperations', operations.join(','));
      }

      let haveRootsChanged = false; // The first two values are always rendererID and rootID

      const rendererID = operations[0];
      const addedElementIDs = []; // This is a mapping of removed ID -> parent ID:

      const removedElementIDs = new Map(); // We'll use the parent ID to adjust selection if it gets deleted.

      let i = 2; // Reassemble the string table.

      const stringTable = [null // ID = 0 corresponds to the null string.
      ];
      const stringTableSize = operations[i++];
      const stringTableEnd = i + stringTableSize;

      while (i < stringTableEnd) {
        const nextLength = operations[i++];
        const nextString = Object(utils["s" /* utfDecodeString */])(operations.slice(i, i + nextLength));
        stringTable.push(nextString);
        i += nextLength;
      }

      while (i < operations.length) {
        const operation = operations[i];

        switch (operation) {
          case constants["l" /* TREE_OPERATION_ADD */]:
            {
              const id = operations[i + 1];
              const type = operations[i + 2];
              i += 3;

              if (this._idToElement.has(id)) {
                throw Error(`Cannot add node ${id} because a node with that id is already in the Store.`);
              }

              let ownerID = 0;
              let parentID = null;

              if (type === types["m" /* ElementTypeRoot */]) {
                if (constants["q" /* __DEBUG__ */]) {
                  store_debug('Add', `new root node ${id}`);
                }

                const supportsProfiling = operations[i] > 0;
                i++;
                const hasOwnerMetadata = operations[i] > 0;
                i++;
                this._roots = this._roots.concat(id);

                this._rootIDToRendererID.set(id, rendererID);

                this._rootIDToCapabilities.set(id, {
                  hasOwnerMetadata,
                  supportsProfiling
                });

                this._idToElement.set(id, {
                  children: [],
                  depth: -1,
                  displayName: null,
                  hocDisplayNames: null,
                  id,
                  isCollapsed: false,
                  // Never collapse roots; it would hide the entire tree.
                  key: null,
                  ownerID: 0,
                  parentID: 0,
                  type,
                  weight: 0
                });

                haveRootsChanged = true;
              } else {
                parentID = operations[i];
                i++;
                ownerID = operations[i];
                i++;
                const displayNameStringID = operations[i];
                const displayName = stringTable[displayNameStringID];
                i++;
                const keyStringID = operations[i];
                const key = stringTable[keyStringID];
                i++;

                if (constants["q" /* __DEBUG__ */]) {
                  store_debug('Add', `node ${id} (${displayName || 'null'}) as child of ${parentID}`);
                }

                if (!this._idToElement.has(parentID)) {
                  throw Error(`Cannot add child ${id} to parent ${parentID} because parent node was not found in the Store.`);
                }

                const parentElement = this._idToElement.get(parentID);

                parentElement.children.push(id);

                const _separateDisplayNameA = Object(utils["p" /* separateDisplayNameAndHOCs */])(displayName, type),
                      _separateDisplayNameA2 = _slicedToArray(_separateDisplayNameA, 2),
                      displayNameWithoutHOCs = _separateDisplayNameA2[0],
                      hocDisplayNames = _separateDisplayNameA2[1];

                const element = {
                  children: [],
                  depth: parentElement.depth + 1,
                  displayName: displayNameWithoutHOCs,
                  hocDisplayNames,
                  id,
                  isCollapsed: this._collapseNodesByDefault,
                  key,
                  ownerID,
                  parentID: parentElement.id,
                  type,
                  weight: 1
                };

                this._idToElement.set(id, element);

                addedElementIDs.push(id);

                this._adjustParentTreeWeight(parentElement, 1);

                if (ownerID > 0) {
                  let set = this._ownersMap.get(ownerID);

                  if (set === undefined) {
                    set = new Set();

                    this._ownersMap.set(ownerID, set);
                  }

                  set.add(id);
                }
              }

              break;
            }

          case constants["m" /* TREE_OPERATION_REMOVE */]:
            {
              const removeLength = operations[i + 1];
              i += 2;

              for (let removeIndex = 0; removeIndex < removeLength; removeIndex++) {
                const id = operations[i];

                if (!this._idToElement.has(id)) {
                  throw Error(`Cannot remove node ${id} because no matching node was found in the Store.`);
                }

                i += 1;

                const element = this._idToElement.get(id);

                const children = element.children,
                      ownerID = element.ownerID,
                      parentID = element.parentID,
                      weight = element.weight;

                if (children.length > 0) {
                  throw new Error(`Node ${id} was removed before its children.`);
                }

                this._idToElement.delete(id);

                let parentElement = null;

                if (parentID === 0) {
                  if (constants["q" /* __DEBUG__ */]) {
                    store_debug('Remove', `node ${id} root`);
                  }

                  this._roots = this._roots.filter(rootID => rootID !== id);

                  this._rootIDToRendererID.delete(id);

                  this._rootIDToCapabilities.delete(id);

                  haveRootsChanged = true;
                } else {
                  if (constants["q" /* __DEBUG__ */]) {
                    store_debug('Remove', `node ${id} from parent ${parentID}`);
                  }

                  parentElement = this._idToElement.get(parentID);

                  if (parentElement === undefined) {
                    throw Error(`Cannot remove node ${id} from parent ${parentID} because no matching node was found in the Store.`);
                  }

                  const index = parentElement.children.indexOf(id);
                  parentElement.children.splice(index, 1);
                }

                this._adjustParentTreeWeight(parentElement, -weight);

                removedElementIDs.set(id, parentID);

                this._ownersMap.delete(id);

                if (ownerID > 0) {
                  const set = this._ownersMap.get(ownerID);

                  if (set !== undefined) {
                    set.delete(id);
                  }
                }
              }

              break;
            }

          case constants["n" /* TREE_OPERATION_REORDER_CHILDREN */]:
            {
              const id = operations[i + 1];
              const numChildren = operations[i + 2];
              i += 3;

              if (!this._idToElement.has(id)) {
                throw Error(`Cannot reorder children for node ${id} because no matching node was found in the Store.`);
              }

              const element = this._idToElement.get(id);

              const children = element.children;

              if (children.length !== numChildren) {
                throw Error(`Children cannot be added or removed during a reorder operation.`);
              }

              for (let j = 0; j < numChildren; j++) {
                const childID = operations[i + j];
                children[j] = childID;

                if (false) {}
              }

              i += numChildren;

              if (constants["q" /* __DEBUG__ */]) {
                store_debug('Re-order', `Node ${id} children ${children.join(',')}`);
              }

              break;
            }

          case constants["o" /* TREE_OPERATION_UPDATE_TREE_BASE_DURATION */]:
            // Base duration updates are only sent while profiling is in progress.
            // We can ignore them at this point.
            // The profiler UI uses them lazily in order to generate the tree.
            i += 3;
            break;

          default:
            throw Error(`Unsupported Bridge operation ${operation}`);
        }
      }

      this._revision++;

      if (haveRootsChanged) {
        const prevSupportsProfiling = this._supportsProfiling;
        this._hasOwnerMetadata = false;
        this._supportsProfiling = false;

        this._rootIDToCapabilities.forEach(({
          hasOwnerMetadata,
          supportsProfiling
        }) => {
          if (hasOwnerMetadata) {
            this._hasOwnerMetadata = true;
          }

          if (supportsProfiling) {
            this._supportsProfiling = true;
          }
        });

        this.emit('roots');

        if (this._supportsProfiling !== prevSupportsProfiling) {
          this.emit('supportsProfiling');
        }
      }

      if (constants["q" /* __DEBUG__ */]) {
        console.log(printStore(this, true));
        console.groupEnd();
      }

      this.emit('mutated', [addedElementIDs, removedElementIDs]);
    });

    store_defineProperty(this, "onBridgeOverrideComponentFilters", componentFilters => {
      this._componentFilters = componentFilters;
      Object(utils["o" /* saveComponentFilters */])(componentFilters);
    });

    store_defineProperty(this, "onBridgeShutdown", () => {
      if (constants["q" /* __DEBUG__ */]) {
        store_debug('onBridgeShutdown', 'unsubscribing from Bridge');
      }

      this._bridge.removeListener('operations', this.onBridgeOperations);

      this._bridge.removeListener('shutdown', this.onBridgeShutdown);

      this._bridge.removeListener('isBackendStorageAPISupported', this.onBridgeStorageSupported);
    });

    store_defineProperty(this, "onBridgeStorageSupported", isBackendStorageAPISupported => {
      this._isBackendStorageAPISupported = isBackendStorageAPISupported;
      this.emit('supportsReloadAndProfile');
    });

    store_defineProperty(this, "onBridgeUnsupportedRendererVersion", () => {
      this._unsupportedRendererVersionDetected = true;
      this.emit('unsupportedRendererVersionDetected');
    });

    if (constants["q" /* __DEBUG__ */]) {
      store_debug('constructor', 'subscribing to Bridge');
    }

    this._collapseNodesByDefault = Object(storage["a" /* localStorageGetItem */])(LOCAL_STORAGE_COLLAPSE_ROOTS_BY_DEFAULT_KEY) === 'true';
    this._recordChangeDescriptions = Object(storage["a" /* localStorageGetItem */])(LOCAL_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY) === 'true';
    this._componentFilters = Object(utils["k" /* getSavedComponentFilters */])();
    let isProfiling = false;

    if (config != null) {
      isProfiling = config.isProfiling === true;
      const supportsNativeInspection = config.supportsNativeInspection,
            supportsProfiling = config.supportsProfiling,
            supportsReloadAndProfile = config.supportsReloadAndProfile,
            supportsTraceUpdates = config.supportsTraceUpdates;
      this._supportsNativeInspection = supportsNativeInspection !== false;

      if (supportsProfiling) {
        this._supportsProfiling = true;
      }

      if (supportsReloadAndProfile) {
        this._supportsReloadAndProfile = true;
      }

      if (supportsTraceUpdates) {
        this._supportsTraceUpdates = true;
      }
    }

    this._bridge = bridge;
    bridge.addListener('operations', this.onBridgeOperations);
    bridge.addListener('overrideComponentFilters', this.onBridgeOverrideComponentFilters);
    bridge.addListener('shutdown', this.onBridgeShutdown);
    bridge.addListener('isBackendStorageAPISupported', this.onBridgeStorageSupported);
    bridge.addListener('isNativeStyleEditorSupported', this.onBridgeNativeStyleEditorSupported);
    bridge.addListener('unsupportedRendererVersion', this.onBridgeUnsupportedRendererVersion);
    this._profilerStore = new ProfilerStore_ProfilerStore(bridge, this, isProfiling);
  } // This is only used in tests to avoid memory leaks.


  assertExpectedRootMapSizes() {
    if (this.roots.length === 0) {
      // The only safe time to assert these maps are empty is when the store is empty.
      this.assertMapSizeMatchesRootCount(this._idToElement, '_idToElement');
      this.assertMapSizeMatchesRootCount(this._ownersMap, '_ownersMap');
    } // These maps should always be the same size as the number of roots


    this.assertMapSizeMatchesRootCount(this._rootIDToCapabilities, '_rootIDToCapabilities');
    this.assertMapSizeMatchesRootCount(this._rootIDToRendererID, '_rootIDToRendererID');
  } // This is only used in tests to avoid memory leaks.


  assertMapSizeMatchesRootCount(map, mapName) {
    const expectedSize = this.roots.length;

    if (map.size !== expectedSize) {
      throw new Error(`Expected ${mapName} to contain ${expectedSize} items, but it contains ${map.size} items\n\n${Object(util["inspect"])(map, {
        depth: 20
      })}`);
    }
  }

  get collapseNodesByDefault() {
    return this._collapseNodesByDefault;
  }

  set collapseNodesByDefault(value) {
    this._collapseNodesByDefault = value;
    Object(storage["b" /* localStorageSetItem */])(LOCAL_STORAGE_COLLAPSE_ROOTS_BY_DEFAULT_KEY, value ? 'true' : 'false');
    this.emit('collapseNodesByDefault');
  }

  get componentFilters() {
    return this._componentFilters;
  }

  set componentFilters(value) {
    if (this._profilerStore.isProfiling) {
      // Re-mounting a tree while profiling is in progress might break a lot of assumptions.
      // If necessary, we could support this- but it doesn't seem like a necessary use case.
      throw Error('Cannot modify filter preferences while profiling');
    } // Filter updates are expensive to apply (since they impact the entire tree).
    // Let's determine if they've changed and avoid doing this work if they haven't.


    const prevEnabledComponentFilters = this._componentFilters.filter(filter => filter.isEnabled);

    const nextEnabledComponentFilters = value.filter(filter => filter.isEnabled);
    let haveEnabledFiltersChanged = prevEnabledComponentFilters.length !== nextEnabledComponentFilters.length;

    if (!haveEnabledFiltersChanged) {
      for (let i = 0; i < nextEnabledComponentFilters.length; i++) {
        const prevFilter = prevEnabledComponentFilters[i];
        const nextFilter = nextEnabledComponentFilters[i];

        if (Object(utils["r" /* shallowDiffers */])(prevFilter, nextFilter)) {
          haveEnabledFiltersChanged = true;
          break;
        }
      }
    }

    this._componentFilters = value; // Update persisted filter preferences stored in localStorage.

    Object(utils["o" /* saveComponentFilters */])(value); // Notify the renderer that filter prefernces have changed.
    // This is an expensive opreation; it unmounts and remounts the entire tree,
    // so only do it if the set of enabled component filters has changed.

    if (haveEnabledFiltersChanged) {
      this._bridge.send('updateComponentFilters', value);
    }

    this.emit('componentFilters');
  }

  get hasOwnerMetadata() {
    return this._hasOwnerMetadata;
  }

  get nativeStyleEditorValidAttributes() {
    return this._nativeStyleEditorValidAttributes;
  }

  get numElements() {
    return this._weightAcrossRoots;
  }

  get profilerStore() {
    return this._profilerStore;
  }

  get recordChangeDescriptions() {
    return this._recordChangeDescriptions;
  }

  set recordChangeDescriptions(value) {
    this._recordChangeDescriptions = value;
    Object(storage["b" /* localStorageSetItem */])(LOCAL_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY, value ? 'true' : 'false');
    this.emit('recordChangeDescriptions');
  }

  get revision() {
    return this._revision;
  }

  get rootIDToRendererID() {
    return this._rootIDToRendererID;
  }

  get roots() {
    return this._roots;
  }

  get supportsNativeInspection() {
    return this._supportsNativeInspection;
  }

  get supportsNativeStyleEditor() {
    return this._isNativeStyleEditorSupported;
  }

  get supportsProfiling() {
    return this._supportsProfiling;
  }

  get supportsReloadAndProfile() {
    // Does the DevTools shell support reloading and eagerly injecting the renderer interface?
    // And if so, can the backend use the localStorage API?
    // Both of these are required for the reload-and-profile feature to work.
    return this._supportsReloadAndProfile && this._isBackendStorageAPISupported;
  }

  get supportsTraceUpdates() {
    return this._supportsTraceUpdates;
  }

  get unsupportedRendererVersionDetected() {
    return this._unsupportedRendererVersionDetected;
  }

  containsElement(id) {
    return this._idToElement.get(id) != null;
  }

  getElementAtIndex(index) {
    if (index < 0 || index >= this.numElements) {
      console.warn(`Invalid index ${index} specified; store contains ${this.numElements} items.`);
      return null;
    } // Find which root this element is in...


    let rootID;
    let root;
    let rootWeight = 0;

    for (let i = 0; i < this._roots.length; i++) {
      rootID = this._roots[i];
      root = this._idToElement.get(rootID);

      if (root.children.length === 0) {
        continue;
      } else if (rootWeight + root.weight > index) {
        break;
      } else {
        rootWeight += root.weight;
      }
    } // Find the element in the tree using the weight of each node...
    // Skip over the root itself, because roots aren't visible in the Elements tree.


    let currentElement = root;
    let currentWeight = rootWeight - 1;

    while (index !== currentWeight) {
      const numChildren = currentElement.children.length;

      for (let i = 0; i < numChildren; i++) {
        const childID = currentElement.children[i];

        const child = this._idToElement.get(childID);

        const childWeight = child.isCollapsed ? 1 : child.weight;

        if (index <= currentWeight + childWeight) {
          currentWeight++;
          currentElement = child;
          break;
        } else {
          currentWeight += childWeight;
        }
      }
    }

    return currentElement || null;
  }

  getElementIDAtIndex(index) {
    const element = this.getElementAtIndex(index);
    return element === null ? null : element.id;
  }

  getElementByID(id) {
    const element = this._idToElement.get(id);

    if (element == null) {
      console.warn(`No element found with id "${id}"`);
      return null;
    }

    return element;
  }

  getIndexOfElementID(id) {
    const element = this.getElementByID(id);

    if (element === null || element.parentID === 0) {
      return null;
    } // Walk up the tree to the root.
    // Increment the index by one for each node we encounter,
    // and by the weight of all nodes to the left of the current one.
    // This should be a relatively fast way of determining the index of a node within the tree.


    let previousID = id;
    let currentID = element.parentID;
    let index = 0;

    while (true) {
      const current = this._idToElement.get(currentID);

      const children = current.children;

      for (let i = 0; i < children.length; i++) {
        const childID = children[i];

        if (childID === previousID) {
          break;
        }

        const child = this._idToElement.get(childID);

        index += child.isCollapsed ? 1 : child.weight;
      }

      if (current.parentID === 0) {
        // We found the root; stop crawling.
        break;
      }

      index++;
      previousID = current.id;
      currentID = current.parentID;
    } // At this point, the current ID is a root (from the previous loop).
    // We also need to offset the index by previous root weights.


    for (let i = 0; i < this._roots.length; i++) {
      const rootID = this._roots[i];

      if (rootID === currentID) {
        break;
      }

      const root = this._idToElement.get(rootID);

      index += root.weight;
    }

    return index;
  }

  getOwnersListForElement(ownerID) {
    const list = [];

    const element = this._idToElement.get(ownerID);

    if (element != null) {
      list.push(_objectSpread(_objectSpread({}, element), {}, {
        depth: 0
      }));

      const unsortedIDs = this._ownersMap.get(ownerID);

      if (unsortedIDs !== undefined) {
        const depthMap = new Map([[ownerID, 0]]); // Items in a set are ordered based on insertion.
        // This does not correlate with their order in the tree.
        // So first we need to order them.
        // I wish we could avoid this sorting operation; we could sort at insertion time,
        // but then we'd have to pay sorting costs even if the owners list was never used.
        // Seems better to defer the cost, since the set of ids is probably pretty small.

        const sortedIDs = Array.from(unsortedIDs).sort((idA, idB) => this.getIndexOfElementID(idA) - this.getIndexOfElementID(idB)); // Next we need to determine the appropriate depth for each element in the list.
        // The depth in the list may not correspond to the depth in the tree,
        // because the list has been filtered to remove intermediate components.
        // Perhaps the easiest way to do this is to walk up the tree until we reach either:
        // (1) another node that's already in the tree, or (2) the root (owner)
        // at which point, our depth is just the depth of that node plus one.

        sortedIDs.forEach(id => {
          const innerElement = this._idToElement.get(id);

          if (innerElement != null) {
            let parentID = innerElement.parentID;
            let depth = 0;

            while (parentID > 0) {
              if (parentID === ownerID || unsortedIDs.has(parentID)) {
                depth = depthMap.get(parentID) + 1;
                depthMap.set(id, depth);
                break;
              }

              const parent = this._idToElement.get(parentID);

              if (parent == null) {
                break;
              }

              parentID = parent.parentID;
            }

            if (depth === 0) {
              throw Error('Invalid owners list');
            }

            list.push(_objectSpread(_objectSpread({}, innerElement), {}, {
              depth
            }));
          }
        });
      }
    }

    return list;
  }

  getRendererIDForElement(id) {
    let current = this._idToElement.get(id);

    while (current != null) {
      if (current.parentID === 0) {
        const rendererID = this._rootIDToRendererID.get(current.id);

        return rendererID == null ? null : rendererID;
      } else {
        current = this._idToElement.get(current.parentID);
      }
    }

    return null;
  }

  getRootIDForElement(id) {
    let current = this._idToElement.get(id);

    while (current != null) {
      if (current.parentID === 0) {
        return current.id;
      } else {
        current = this._idToElement.get(current.parentID);
      }
    }

    return null;
  }

  isInsideCollapsedSubTree(id) {
    let current = this._idToElement.get(id);

    while (current != null) {
      if (current.parentID === 0) {
        return false;
      } else {
        current = this._idToElement.get(current.parentID);

        if (current != null && current.isCollapsed) {
          return true;
        }
      }
    }

    return false;
  } // TODO Maybe split this into two methods: expand() and collapse()


  toggleIsCollapsed(id, isCollapsed) {
    let didMutate = false;
    const element = this.getElementByID(id);

    if (element !== null) {
      if (isCollapsed) {
        if (element.type === types["m" /* ElementTypeRoot */]) {
          throw Error('Root nodes cannot be collapsed');
        }

        if (!element.isCollapsed) {
          didMutate = true;
          element.isCollapsed = true;
          const weightDelta = 1 - element.weight;

          let parentElement = this._idToElement.get(element.parentID);

          while (parentElement != null) {
            // We don't need to break on a collapsed parent in the same way as the expand case below.
            // That's because collapsing a node doesn't "bubble" and affect its parents.
            parentElement.weight += weightDelta;
            parentElement = this._idToElement.get(parentElement.parentID);
          }
        }
      } else {
        let currentElement = element;

        while (currentElement != null) {
          const oldWeight = currentElement.isCollapsed ? 1 : currentElement.weight;

          if (currentElement.isCollapsed) {
            didMutate = true;
            currentElement.isCollapsed = false;
            const newWeight = currentElement.isCollapsed ? 1 : currentElement.weight;
            const weightDelta = newWeight - oldWeight;

            let parentElement = this._idToElement.get(currentElement.parentID);

            while (parentElement != null) {
              parentElement.weight += weightDelta;

              if (parentElement.isCollapsed) {
                // It's important to break on a collapsed parent when expanding nodes.
                // That's because expanding a node "bubbles" up and expands all parents as well.
                // Breaking in this case prevents us from over-incrementing the expanded weights.
                break;
              }

              parentElement = this._idToElement.get(parentElement.parentID);
            }
          }

          currentElement = currentElement.parentID !== 0 ? this.getElementByID(currentElement.parentID) : null;
        }
      } // Only re-calculate weights and emit an "update" event if the store was mutated.


      if (didMutate) {
        let weightAcrossRoots = 0;

        this._roots.forEach(rootID => {
          const _ref = this.getElementByID(rootID),
                weight = _ref.weight;

          weightAcrossRoots += weight;
        });

        this._weightAcrossRoots = weightAcrossRoots; // The Tree context's search reducer expects an explicit list of ids for nodes that were added or removed.
        // In this  case, we can pass it empty arrays since nodes in a collapsed tree are still there (just hidden).
        // Updating the selected search index later may require auto-expanding a collapsed subtree though.

        this.emit('mutated', [[], new Map()]);
      }
    }
  }

}
// EXTERNAL MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/@reach/menu-button/styles.css
var styles = __webpack_require__(94);

// EXTERNAL MODULE: ../react-devtools-shared/node_modules/@reach/tooltip/styles.css
var tooltip_styles = __webpack_require__(97);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/context.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


const BridgeContext = /*#__PURE__*/Object(external_react_["createContext"])(null);
BridgeContext.displayName = 'BridgeContext';
const StoreContext = /*#__PURE__*/Object(external_react_["createContext"])(null);
StoreContext.displayName = 'StoreContext';
const ContextMenuContext = /*#__PURE__*/Object(external_react_["createContext"])({
  isEnabledForInspectedElement: false,
  viewAttributeSourceFunction: null
});
ContextMenuContext.displayName = 'ContextMenuContext';
// EXTERNAL MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/react-virtualized-auto-sizer/dist/index.esm.js
var index_esm = __webpack_require__(27);

// CONCATENATED MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}
// CONCATENATED MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
// CONCATENATED MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
// EXTERNAL MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/memoize-one/esm/index.js
var esm = __webpack_require__(28);

// EXTERNAL MODULE: external "react-dom"
var external_react_dom_ = __webpack_require__(10);

// CONCATENATED MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}
// CONCATENATED MODULE: ../react-devtools-shared/src/node_modules/react-window/dist/index.esm.js






 // Animation frame based implementation of setTimeout.
// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js

var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';
var now = hasNativePerformanceNow ? function () {
  return performance.now();
} : function () {
  return Date.now();
};

function cancelTimeout(timeoutID) {
  cancelAnimationFrame(timeoutID.id);
}

function requestTimeout(callback, delay) {
  var start = now();

  function tick() {
    if (now() - start >= delay) {
      callback.call(null);
    } else {
      timeoutID.id = requestAnimationFrame(tick);
    }
  }

  var timeoutID = {
    id: requestAnimationFrame(tick)
  };
  return timeoutID;
}

var size = -1; // This utility copied from "dom-helpers" package.

function getScrollbarSize(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }

  if (size === -1 || recalculate) {
    var div = document.createElement('div');
    var style = div.style;
    style.width = '50px';
    style.height = '50px';
    style.overflow = 'scroll';
    document.body.appendChild(div);
    size = div.offsetWidth - div.clientWidth;
    document.body.removeChild(div);
  }

  return size;
}

var cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.
// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).
// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.
// The safest way to check this is to intentionally set a negative offset,
// and then verify that the subsequent "scroll" event matches the negative offset.
// If it does not match, then we can assume a non-standard RTL scroll implementation.

function getRTLOffsetType(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }

  if (cachedRTLResult === null || recalculate) {
    var outerDiv = document.createElement('div');
    var outerStyle = outerDiv.style;
    outerStyle.width = '50px';
    outerStyle.height = '50px';
    outerStyle.overflow = 'scroll';
    outerStyle.direction = 'rtl';
    var innerDiv = document.createElement('div');
    var innerStyle = innerDiv.style;
    innerStyle.width = '100px';
    innerStyle.height = '100px';
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);

    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = 'positive-descending';
    } else {
      outerDiv.scrollLeft = 1;

      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = 'negative';
      } else {
        cachedRTLResult = 'positive-ascending';
      }
    }

    document.body.removeChild(outerDiv);
    return cachedRTLResult;
  }

  return cachedRTLResult;
}

var IS_SCROLLING_DEBOUNCE_INTERVAL = 150;

var defaultItemKey = function defaultItemKey(_ref) {
  var columnIndex = _ref.columnIndex,
      data = _ref.data,
      rowIndex = _ref.rowIndex;
  return rowIndex + ":" + columnIndex;
}; // In DEV mode, this Set helps us only log a warning once per component instance.
// This avoids spamming the console every time a render happens.


var devWarningsOverscanCount = null;
var devWarningsOverscanRowsColumnsCount = null;
var devWarningsTagName = null;

if (false) {}

function createGridComponent(_ref2) {
  var _class, _temp;

  var getColumnOffset = _ref2.getColumnOffset,
      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,
      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,
      getColumnWidth = _ref2.getColumnWidth,
      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,
      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,
      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,
      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,
      getRowHeight = _ref2.getRowHeight,
      getRowOffset = _ref2.getRowOffset,
      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,
      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,
      initInstanceProps = _ref2.initInstanceProps,
      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,
      validateProps = _ref2.validateProps;
  return _temp = _class = /*#__PURE__*/function (_PureComponent) {
    _inheritsLoose(Grid, _PureComponent); // Always use explicit constructor for React components.
    // It produces less code after transpilation. (#26)
    // eslint-disable-next-line no-useless-constructor


    function Grid(props) {
      var _this;

      _this = _PureComponent.call(this, props) || this;
      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));
      _this._resetIsScrollingTimeoutId = null;
      _this._outerRef = void 0;
      _this.state = {
        instance: _assertThisInitialized(_assertThisInitialized(_this)),
        isScrolling: false,
        horizontalScrollDirection: 'forward',
        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,
        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,
        scrollUpdateWasRequested: false,
        verticalScrollDirection: 'forward'
      };
      _this._callOnItemsRendered = void 0;
      _this._callOnItemsRendered = Object(esm["a" /* default */])(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {
        return _this.props.onItemsRendered({
          overscanColumnStartIndex: overscanColumnStartIndex,
          overscanColumnStopIndex: overscanColumnStopIndex,
          overscanRowStartIndex: overscanRowStartIndex,
          overscanRowStopIndex: overscanRowStopIndex,
          visibleColumnStartIndex: visibleColumnStartIndex,
          visibleColumnStopIndex: visibleColumnStopIndex,
          visibleRowStartIndex: visibleRowStartIndex,
          visibleRowStopIndex: visibleRowStopIndex
        });
      });
      _this._callOnScroll = void 0;
      _this._callOnScroll = Object(esm["a" /* default */])(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {
        return _this.props.onScroll({
          horizontalScrollDirection: horizontalScrollDirection,
          scrollLeft: scrollLeft,
          scrollTop: scrollTop,
          verticalScrollDirection: verticalScrollDirection,
          scrollUpdateWasRequested: scrollUpdateWasRequested
        });
      });
      _this._getItemStyle = void 0;

      _this._getItemStyle = function (rowIndex, columnIndex) {
        var _this$props = _this.props,
            columnWidth = _this$props.columnWidth,
            direction = _this$props.direction,
            rowHeight = _this$props.rowHeight;

        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);

        var key = rowIndex + ":" + columnIndex;
        var style;

        if (itemStyleCache.hasOwnProperty(key)) {
          style = itemStyleCache[key];
        } else {
          var _style;

          itemStyleCache[key] = style = (_style = {
            position: 'absolute'
          }, _style[direction === 'rtl' ? 'right' : 'left'] = getColumnOffset(_this.props, columnIndex, _this._instanceProps), _style.top = getRowOffset(_this.props, rowIndex, _this._instanceProps), _style.height = getRowHeight(_this.props, rowIndex, _this._instanceProps), _style.width = getColumnWidth(_this.props, columnIndex, _this._instanceProps), _style);
        }

        return style;
      };

      _this._getItemStyleCache = void 0;
      _this._getItemStyleCache = Object(esm["a" /* default */])(function (_, __, ___) {
        return {};
      });

      _this._onScroll = function (event) {
        var _event$currentTarget = event.currentTarget,
            clientHeight = _event$currentTarget.clientHeight,
            clientWidth = _event$currentTarget.clientWidth,
            scrollLeft = _event$currentTarget.scrollLeft,
            scrollTop = _event$currentTarget.scrollTop,
            scrollHeight = _event$currentTarget.scrollHeight,
            scrollWidth = _event$currentTarget.scrollWidth; // Force flush sync for scroll updates to reduce visual checkerboarding.

        Object(external_react_dom_["flushSync"])(() => {
          _this.setState(function (prevState) {
            if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {
              // Scroll position may have been updated by cDM/cDU,
              // In which case we don't need to trigger another render,
              // And we don't want to update state.isScrolling.
              return null;
            }

            var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.
            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).
            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.
            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.

            var calculatedScrollLeft = scrollLeft;

            if (direction === 'rtl') {
              switch (getRTLOffsetType()) {
                case 'negative':
                  calculatedScrollLeft = -scrollLeft;
                  break;

                case 'positive-descending':
                  calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;
                  break;
              }
            } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.


            calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));
            var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
            return {
              isScrolling: true,
              horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',
              scrollLeft: calculatedScrollLeft,
              scrollTop: calculatedScrollTop,
              verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',
              scrollUpdateWasRequested: false
            };
          }, _this._resetIsScrollingDebounced);
        });
      };

      _this._outerRefSetter = function (ref) {
        var outerRef = _this.props.outerRef;
        _this._outerRef = ref;

        if (typeof outerRef === 'function') {
          outerRef(ref);
        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {
          outerRef.current = ref;
        }
      };

      _this._resetIsScrollingDebounced = function () {
        if (_this._resetIsScrollingTimeoutId !== null) {
          cancelTimeout(_this._resetIsScrollingTimeoutId);
        }

        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);
      };

      _this._resetIsScrolling = function () {
        _this._resetIsScrollingTimeoutId = null;

        _this.setState({
          isScrolling: false
        }, function () {
          // Clear style cache after state update has been committed.
          // This way we don't break pure sCU for items that don't use isScrolling param.
          _this._getItemStyleCache(-1);
        });
      };

      return _this;
    }

    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      validateSharedProps(nextProps, prevState);
      validateProps(nextProps);
      return null;
    };

    var _proto = Grid.prototype;

    _proto.scrollTo = function scrollTo(_ref3) {
      var scrollLeft = _ref3.scrollLeft,
          scrollTop = _ref3.scrollTop;

      if (scrollLeft !== undefined) {
        scrollLeft = Math.max(0, scrollLeft);
      }

      if (scrollTop !== undefined) {
        scrollTop = Math.max(0, scrollTop);
      }

      this.setState(function (prevState) {
        if (scrollLeft === undefined) {
          scrollLeft = prevState.scrollLeft;
        }

        if (scrollTop === undefined) {
          scrollTop = prevState.scrollTop;
        }

        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {
          return null;
        }

        return {
          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',
          scrollLeft: scrollLeft,
          scrollTop: scrollTop,
          scrollUpdateWasRequested: true,
          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'
        };
      }, this._resetIsScrollingDebounced);
    };

    _proto.scrollToItem = function scrollToItem(_ref4) {
      var _ref4$align = _ref4.align,
          align = _ref4$align === void 0 ? 'auto' : _ref4$align,
          columnIndex = _ref4.columnIndex,
          rowIndex = _ref4.rowIndex;
      var _this$props2 = this.props,
          columnCount = _this$props2.columnCount,
          height = _this$props2.height,
          rowCount = _this$props2.rowCount,
          width = _this$props2.width;
      var _this$state = this.state,
          scrollLeft = _this$state.scrollLeft,
          scrollTop = _this$state.scrollTop;
      var scrollbarSize = getScrollbarSize();

      if (columnIndex !== undefined) {
        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));
      }

      if (rowIndex !== undefined) {
        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));
      }

      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);
      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,
      // to ensure it's fully visible.
      // But we only need to account for its size when it's actually visible.

      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;
      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;
      this.scrollTo({
        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,
        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop
      });
    };

    _proto.componentDidMount = function componentDidMount() {
      var _this$props3 = this.props,
          initialScrollLeft = _this$props3.initialScrollLeft,
          initialScrollTop = _this$props3.initialScrollTop;

      if (this._outerRef != null) {
        var outerRef = this._outerRef;

        if (typeof initialScrollLeft === 'number') {
          outerRef.scrollLeft = initialScrollLeft;
        }

        if (typeof initialScrollTop === 'number') {
          outerRef.scrollTop = initialScrollTop;
        }
      }

      this._callPropsCallbacks();
    };

    _proto.componentDidUpdate = function componentDidUpdate() {
      var direction = this.props.direction;
      var _this$state2 = this.state,
          scrollLeft = _this$state2.scrollLeft,
          scrollTop = _this$state2.scrollTop,
          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;

      if (scrollUpdateWasRequested && this._outerRef != null) {
        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.
        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).
        // So we need to determine which browser behavior we're dealing with, and mimic it.
        var outerRef = this._outerRef;

        if (direction === 'rtl') {
          switch (getRTLOffsetType()) {
            case 'negative':
              outerRef.scrollLeft = -scrollLeft;
              break;

            case 'positive-ascending':
              outerRef.scrollLeft = scrollLeft;
              break;

            default:
              var clientWidth = outerRef.clientWidth,
                  scrollWidth = outerRef.scrollWidth;
              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;
              break;
          }
        } else {
          outerRef.scrollLeft = Math.max(0, scrollLeft);
        }

        outerRef.scrollTop = Math.max(0, scrollTop);
      }

      this._callPropsCallbacks();
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this._resetIsScrollingTimeoutId !== null) {
        cancelTimeout(this._resetIsScrollingTimeoutId);
      }
    };

    _proto.render = function render() {
      var _this$props4 = this.props,
          children = _this$props4.children,
          className = _this$props4.className,
          columnCount = _this$props4.columnCount,
          direction = _this$props4.direction,
          height = _this$props4.height,
          innerRef = _this$props4.innerRef,
          innerElementType = _this$props4.innerElementType,
          innerTagName = _this$props4.innerTagName,
          itemData = _this$props4.itemData,
          _this$props4$itemKey = _this$props4.itemKey,
          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,
          outerElementType = _this$props4.outerElementType,
          outerTagName = _this$props4.outerTagName,
          rowCount = _this$props4.rowCount,
          style = _this$props4.style,
          useIsScrolling = _this$props4.useIsScrolling,
          width = _this$props4.width;
      var isScrolling = this.state.isScrolling;

      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),
          columnStartIndex = _this$_getHorizontalR[0],
          columnStopIndex = _this$_getHorizontalR[1];

      var _this$_getVerticalRan = this._getVerticalRangeToRender(),
          rowStartIndex = _this$_getVerticalRan[0],
          rowStopIndex = _this$_getVerticalRan[1];

      var items = [];

      if (columnCount > 0 && rowCount) {
        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {
          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {
            items.push( /*#__PURE__*/Object(external_react_["createElement"])(children, {
              columnIndex: _columnIndex,
              data: itemData,
              isScrolling: useIsScrolling ? isScrolling : undefined,
              key: itemKey({
                columnIndex: _columnIndex,
                data: itemData,
                rowIndex: _rowIndex
              }),
              rowIndex: _rowIndex,
              style: this._getItemStyle(_rowIndex, _columnIndex)
            }));
          }
        }
      } // Read this value AFTER items have been created,
      // So their actual sizes (if variable) are taken into consideration.


      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);
      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);
      return /*#__PURE__*/Object(external_react_["createElement"])(outerElementType || outerTagName || 'div', {
        className: className,
        onScroll: this._onScroll,
        ref: this._outerRefSetter,
        style: _extends({
          position: 'relative',
          height: height,
          width: width,
          overflow: 'auto',
          WebkitOverflowScrolling: 'touch',
          willChange: 'transform',
          direction: direction
        }, style)
      }, /*#__PURE__*/Object(external_react_["createElement"])(innerElementType || innerTagName || 'div', {
        children: items,
        ref: innerRef,
        style: {
          height: estimatedTotalHeight,
          pointerEvents: isScrolling ? 'none' : undefined,
          width: estimatedTotalWidth
        }
      }));
    };

    _proto._callPropsCallbacks = function _callPropsCallbacks() {
      var _this$props5 = this.props,
          columnCount = _this$props5.columnCount,
          onItemsRendered = _this$props5.onItemsRendered,
          onScroll = _this$props5.onScroll,
          rowCount = _this$props5.rowCount;

      if (typeof onItemsRendered === 'function') {
        if (columnCount > 0 && rowCount > 0) {
          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),
              _overscanColumnStartIndex = _this$_getHorizontalR2[0],
              _overscanColumnStopIndex = _this$_getHorizontalR2[1],
              _visibleColumnStartIndex = _this$_getHorizontalR2[2],
              _visibleColumnStopIndex = _this$_getHorizontalR2[3];

          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),
              _overscanRowStartIndex = _this$_getVerticalRan2[0],
              _overscanRowStopIndex = _this$_getVerticalRan2[1],
              _visibleRowStartIndex = _this$_getVerticalRan2[2],
              _visibleRowStopIndex = _this$_getVerticalRan2[3];

          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);
        }
      }

      if (typeof onScroll === 'function') {
        var _this$state3 = this.state,
            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,
            _scrollLeft = _this$state3.scrollLeft,
            _scrollTop = _this$state3.scrollTop,
            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,
            _verticalScrollDirection = _this$state3.verticalScrollDirection;

        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);
      }
    }; // Lazily create and cache item styles while scrolling,
    // So that pure component sCU will prevent re-renders.
    // We maintain this cache, and pass a style prop rather than index,
    // So that List can clear cached styles and force item re-render if necessary.


    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {
      var _this$props6 = this.props,
          columnCount = _this$props6.columnCount,
          overscanColumnCount = _this$props6.overscanColumnCount,
          overscanColumnsCount = _this$props6.overscanColumnsCount,
          overscanCount = _this$props6.overscanCount,
          rowCount = _this$props6.rowCount;
      var _this$state4 = this.state,
          horizontalScrollDirection = _this$state4.horizontalScrollDirection,
          isScrolling = _this$state4.isScrolling,
          scrollLeft = _this$state4.scrollLeft;
      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;

      if (columnCount === 0 || rowCount === 0) {
        return [0, 0, 0, 0];
      }

      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);
      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.
      // If there isn't at least one extra item, tab loops back around.

      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;
      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    };

    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {
      var _this$props7 = this.props,
          columnCount = _this$props7.columnCount,
          overscanCount = _this$props7.overscanCount,
          overscanRowCount = _this$props7.overscanRowCount,
          overscanRowsCount = _this$props7.overscanRowsCount,
          rowCount = _this$props7.rowCount;
      var _this$state5 = this.state,
          isScrolling = _this$state5.isScrolling,
          verticalScrollDirection = _this$state5.verticalScrollDirection,
          scrollTop = _this$state5.scrollTop;
      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;

      if (columnCount === 0 || rowCount === 0) {
        return [0, 0, 0, 0];
      }

      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);
      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.
      // If there isn't at least one extra item, tab loops back around.

      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;
      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    };

    return Grid;
  }(external_react_["PureComponent"]), _class.defaultProps = {
    direction: 'ltr',
    itemData: undefined,
    useIsScrolling: false
  }, _temp;
}

var validateSharedProps = function validateSharedProps(_ref5, _ref6) {
  var children = _ref5.children,
      direction = _ref5.direction,
      height = _ref5.height,
      innerTagName = _ref5.innerTagName,
      outerTagName = _ref5.outerTagName,
      overscanColumnsCount = _ref5.overscanColumnsCount,
      overscanCount = _ref5.overscanCount,
      overscanRowsCount = _ref5.overscanRowsCount,
      width = _ref5.width;
  var instance = _ref6.instance;

  if (false) {}
};

var DEFAULT_ESTIMATED_ITEM_SIZE = 50;

var index_esm_getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {
  var rowCount = _ref.rowCount;
  var rowMetadataMap = _ref2.rowMetadataMap,
      estimatedRowHeight = _ref2.estimatedRowHeight,
      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;
  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.
  // https://github.com/bvaughn/react-window/pull/138

  if (lastMeasuredRowIndex >= rowCount) {
    lastMeasuredRowIndex = rowCount - 1;
  }

  if (lastMeasuredRowIndex >= 0) {
    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];
    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;
  }

  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;
  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;
  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;
};

var index_esm_getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {
  var columnCount = _ref3.columnCount;
  var columnMetadataMap = _ref4.columnMetadataMap,
      estimatedColumnWidth = _ref4.estimatedColumnWidth,
      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;
  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.
  // https://github.com/bvaughn/react-window/pull/138

  if (lastMeasuredColumnIndex >= columnCount) {
    lastMeasuredColumnIndex = columnCount - 1;
  }

  if (lastMeasuredColumnIndex >= 0) {
    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];
    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;
  }

  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;
  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;
  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;
};

var getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {
  var itemMetadataMap, itemSize, lastMeasuredIndex;

  if (itemType === 'column') {
    itemMetadataMap = instanceProps.columnMetadataMap;
    itemSize = props.columnWidth;
    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;
  } else {
    itemMetadataMap = instanceProps.rowMetadataMap;
    itemSize = props.rowHeight;
    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;
  }

  if (index > lastMeasuredIndex) {
    var offset = 0;

    if (lastMeasuredIndex >= 0) {
      var itemMetadata = itemMetadataMap[lastMeasuredIndex];
      offset = itemMetadata.offset + itemMetadata.size;
    }

    for (var i = lastMeasuredIndex + 1; i <= index; i++) {
      var size = itemSize(i);
      itemMetadataMap[i] = {
        offset: offset,
        size: size
      };
      offset += size;
    }

    if (itemType === 'column') {
      instanceProps.lastMeasuredColumnIndex = index;
    } else {
      instanceProps.lastMeasuredRowIndex = index;
    }
  }

  return itemMetadataMap[index];
};

var findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {
  var itemMetadataMap, lastMeasuredIndex;

  if (itemType === 'column') {
    itemMetadataMap = instanceProps.columnMetadataMap;
    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;
  } else {
    itemMetadataMap = instanceProps.rowMetadataMap;
    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;
  }

  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;

  if (lastMeasuredItemOffset >= offset) {
    // If we've already measured items within this range just use a binary search as it's faster.
    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);
  } else {
    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.
    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.
    // The overall complexity for this approach is O(log n).
    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);
  }
};

var findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {
  while (low <= high) {
    var middle = low + Math.floor((high - low) / 2);
    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;

    if (currentOffset === offset) {
      return middle;
    } else if (currentOffset < offset) {
      low = middle + 1;
    } else if (currentOffset > offset) {
      high = middle - 1;
    }
  }

  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};

var findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {
  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;
  var interval = 1;

  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {
    index += interval;
    interval *= 2;
  }

  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);
};

var index_esm_getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {
  var size = itemType === 'column' ? props.width : props.height;
  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,
  // To ensure it reflects actual measurements instead of just estimates.

  var estimatedTotalSize = itemType === 'column' ? index_esm_getEstimatedTotalWidth(props, instanceProps) : index_esm_getEstimatedTotalHeight(props, instanceProps);
  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));
  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);

  if (align === 'smart') {
    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
      align = 'auto';
    } else {
      align = 'center';
    }
  }

  switch (align) {
    case 'start':
      return maxOffset;

    case 'end':
      return minOffset;

    case 'center':
      return Math.round(minOffset + (maxOffset - minOffset) / 2);

    case 'auto':
    default:
      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
        return scrollOffset;
      } else if (minOffset > maxOffset) {
        // Because we only take into account the scrollbar size when calculating minOffset
        // this value can be larger than maxOffset when at the end of the list
        return minOffset;
      } else if (scrollOffset < minOffset) {
        return minOffset;
      } else {
        return maxOffset;
      }

  }
};

var VariableSizeGrid = /*#__PURE__*/createGridComponent({
  getColumnOffset: function getColumnOffset(props, index, instanceProps) {
    return getItemMetadata('column', props, index, instanceProps).offset;
  },
  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {
    return findNearestItem('column', props, instanceProps, scrollLeft);
  },
  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {
    var columnCount = props.columnCount,
        width = props.width;
    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);
    var maxOffset = scrollLeft + width;
    var offset = itemMetadata.offset + itemMetadata.size;
    var stopIndex = startIndex;

    while (stopIndex < columnCount - 1 && offset < maxOffset) {
      stopIndex++;
      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;
    }

    return stopIndex;
  },
  getColumnWidth: function getColumnWidth(props, index, instanceProps) {
    return instanceProps.columnMetadataMap[index].size;
  },
  getEstimatedTotalHeight: index_esm_getEstimatedTotalHeight,
  getEstimatedTotalWidth: index_esm_getEstimatedTotalWidth,
  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {
    return index_esm_getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);
  },
  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {
    return index_esm_getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);
  },
  getRowOffset: function getRowOffset(props, index, instanceProps) {
    return getItemMetadata('row', props, index, instanceProps).offset;
  },
  getRowHeight: function getRowHeight(props, index, instanceProps) {
    return instanceProps.rowMetadataMap[index].size;
  },
  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {
    return findNearestItem('row', props, instanceProps, scrollTop);
  },
  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {
    var rowCount = props.rowCount,
        height = props.height;
    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);
    var maxOffset = scrollTop + height;
    var offset = itemMetadata.offset + itemMetadata.size;
    var stopIndex = startIndex;

    while (stopIndex < rowCount - 1 && offset < maxOffset) {
      stopIndex++;
      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;
    }

    return stopIndex;
  },
  initInstanceProps: function initInstanceProps(props, instance) {
    var _ref5 = props,
        estimatedColumnWidth = _ref5.estimatedColumnWidth,
        estimatedRowHeight = _ref5.estimatedRowHeight;
    var instanceProps = {
      columnMetadataMap: {},
      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,
      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,
      lastMeasuredColumnIndex: -1,
      lastMeasuredRowIndex: -1,
      rowMetadataMap: {}
    };

    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {
      if (shouldForceUpdate === void 0) {
        shouldForceUpdate = true;
      }

      instance.resetAfterIndices({
        columnIndex: columnIndex,
        shouldForceUpdate: shouldForceUpdate
      });
    };

    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {
      if (shouldForceUpdate === void 0) {
        shouldForceUpdate = true;
      }

      instance.resetAfterIndices({
        rowIndex: rowIndex,
        shouldForceUpdate: shouldForceUpdate
      });
    };

    instance.resetAfterIndices = function (_ref6) {
      var columnIndex = _ref6.columnIndex,
          rowIndex = _ref6.rowIndex,
          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,
          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;

      if (typeof columnIndex === 'number') {
        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);
      }

      if (typeof rowIndex === 'number') {
        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);
      } // We could potentially optimize further by only evicting styles after this index,
      // But since styles are only cached while scrolling is in progress-
      // It seems an unnecessary optimization.
      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.


      instance._getItemStyleCache(-1);

      if (shouldForceUpdate) {
        instance.forceUpdate();
      }
    };

    return instanceProps;
  },
  shouldResetStyleCacheOnItemSizeChange: false,
  validateProps: function validateProps(_ref7) {
    var columnWidth = _ref7.columnWidth,
        rowHeight = _ref7.rowHeight;

    if (false) {}
  }
});
var IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;

var defaultItemKey$1 = function defaultItemKey(index, data) {
  return index;
}; // In DEV mode, this Set helps us only log a warning once per component instance.
// This avoids spamming the console every time a render happens.


var devWarningsDirection = null;
var devWarningsTagName$1 = null;

if (false) {}

function createListComponent(_ref) {
  var _class, _temp;

  var getItemOffset = _ref.getItemOffset,
      getEstimatedTotalSize = _ref.getEstimatedTotalSize,
      getItemSize = _ref.getItemSize,
      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,
      getStartIndexForOffset = _ref.getStartIndexForOffset,
      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,
      initInstanceProps = _ref.initInstanceProps,
      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,
      validateProps = _ref.validateProps;
  return _temp = _class = /*#__PURE__*/function (_PureComponent) {
    _inheritsLoose(List, _PureComponent); // Always use explicit constructor for React components.
    // It produces less code after transpilation. (#26)
    // eslint-disable-next-line no-useless-constructor


    function List(props) {
      var _this;

      _this = _PureComponent.call(this, props) || this;
      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));
      _this._outerRef = void 0;
      _this._resetIsScrollingTimeoutId = null;
      _this.state = {
        instance: _assertThisInitialized(_assertThisInitialized(_this)),
        isScrolling: false,
        scrollDirection: 'forward',
        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,
        scrollUpdateWasRequested: false
      };
      _this._callOnItemsRendered = void 0;
      _this._callOnItemsRendered = Object(esm["a" /* default */])(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {
        return _this.props.onItemsRendered({
          overscanStartIndex: overscanStartIndex,
          overscanStopIndex: overscanStopIndex,
          visibleStartIndex: visibleStartIndex,
          visibleStopIndex: visibleStopIndex
        });
      });
      _this._callOnScroll = void 0;
      _this._callOnScroll = Object(esm["a" /* default */])(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {
        return _this.props.onScroll({
          scrollDirection: scrollDirection,
          scrollOffset: scrollOffset,
          scrollUpdateWasRequested: scrollUpdateWasRequested
        });
      });
      _this._getItemStyle = void 0;

      _this._getItemStyle = function (index) {
        var _this$props = _this.props,
            direction = _this$props.direction,
            itemSize = _this$props.itemSize,
            layout = _this$props.layout;

        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);

        var style;

        if (itemStyleCache.hasOwnProperty(index)) {
          style = itemStyleCache[index];
        } else {
          var _style;

          var _offset = getItemOffset(_this.props, index, _this._instanceProps);

          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction "horizontal"

          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
          itemStyleCache[index] = style = (_style = {
            position: 'absolute'
          }, _style[direction === 'rtl' ? 'right' : 'left'] = isHorizontal ? _offset : 0, _style.top = !isHorizontal ? _offset : 0, _style.height = !isHorizontal ? size : '100%', _style.width = isHorizontal ? size : '100%', _style);
        }

        return style;
      };

      _this._getItemStyleCache = void 0;
      _this._getItemStyleCache = Object(esm["a" /* default */])(function (_, __, ___) {
        return {};
      });

      _this._onScrollHorizontal = function (event) {
        var _event$currentTarget = event.currentTarget,
            clientWidth = _event$currentTarget.clientWidth,
            scrollLeft = _event$currentTarget.scrollLeft,
            scrollWidth = _event$currentTarget.scrollWidth; // Force flush sync for scroll updates to reduce visual checkerboarding.

        Object(external_react_dom_["flushSync"])(() => {
          _this.setState(function (prevState) {
            if (prevState.scrollOffset === scrollLeft) {
              // Scroll position may have been updated by cDM/cDU,
              // In which case we don't need to trigger another render,
              // And we don't want to update state.isScrolling.
              return null;
            }

            var direction = _this.props.direction;
            var scrollOffset = scrollLeft;

            if (direction === 'rtl') {
              // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.
              // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).
              // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.
              // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.
              switch (getRTLOffsetType()) {
                case 'negative':
                  scrollOffset = -scrollLeft;
                  break;

                case 'positive-descending':
                  scrollOffset = scrollWidth - clientWidth - scrollLeft;
                  break;
              }
            } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.


            scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
            return {
              isScrolling: true,
              scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',
              scrollOffset: scrollOffset,
              scrollUpdateWasRequested: false
            };
          }, _this._resetIsScrollingDebounced);
        });
      };

      _this._onScrollVertical = function (event) {
        var _event$currentTarget2 = event.currentTarget,
            clientHeight = _event$currentTarget2.clientHeight,
            scrollHeight = _event$currentTarget2.scrollHeight,
            scrollTop = _event$currentTarget2.scrollTop; // Force flush sync for scroll updates to reduce visual checkerboarding.

        Object(external_react_dom_["flushSync"])(() => {
          _this.setState(function (prevState) {
            if (prevState.scrollOffset === scrollTop) {
              // Scroll position may have been updated by cDM/cDU,
              // In which case we don't need to trigger another render,
              // And we don't want to update state.isScrolling.
              return null;
            } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.


            var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
            return {
              isScrolling: true,
              scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',
              scrollOffset: scrollOffset,
              scrollUpdateWasRequested: false
            };
          }, _this._resetIsScrollingDebounced);
        });
      };

      _this._outerRefSetter = function (ref) {
        var outerRef = _this.props.outerRef;
        _this._outerRef = ref;

        if (typeof outerRef === 'function') {
          outerRef(ref);
        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {
          outerRef.current = ref;
        }
      };

      _this._resetIsScrollingDebounced = function () {
        if (_this._resetIsScrollingTimeoutId !== null) {
          cancelTimeout(_this._resetIsScrollingTimeoutId);
        }

        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);
      };

      _this._resetIsScrolling = function () {
        _this._resetIsScrollingTimeoutId = null;

        _this.setState({
          isScrolling: false
        }, function () {
          // Clear style cache after state update has been committed.
          // This way we don't break pure sCU for items that don't use isScrolling param.
          _this._getItemStyleCache(-1, null);
        });
      };

      return _this;
    }

    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      validateSharedProps$1(nextProps, prevState);
      validateProps(nextProps);
      return null;
    };

    var _proto = List.prototype;

    _proto.scrollTo = function scrollTo(scrollOffset) {
      scrollOffset = Math.max(0, scrollOffset);
      this.setState(function (prevState) {
        if (prevState.scrollOffset === scrollOffset) {
          return null;
        }

        return {
          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',
          scrollOffset: scrollOffset,
          scrollUpdateWasRequested: true
        };
      }, this._resetIsScrollingDebounced);
    };

    _proto.scrollToItem = function scrollToItem(index, align) {
      if (align === void 0) {
        align = 'auto';
      }

      var itemCount = this.props.itemCount;
      var scrollOffset = this.state.scrollOffset;
      index = Math.max(0, Math.min(index, itemCount - 1));
      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));
    };

    _proto.componentDidMount = function componentDidMount() {
      var _this$props2 = this.props,
          direction = _this$props2.direction,
          initialScrollOffset = _this$props2.initialScrollOffset,
          layout = _this$props2.layout;

      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {
        var outerRef = this._outerRef; // TODO Deprecate direction "horizontal"

        if (direction === 'horizontal' || layout === 'horizontal') {
          outerRef.scrollLeft = initialScrollOffset;
        } else {
          outerRef.scrollTop = initialScrollOffset;
        }
      }

      this._callPropsCallbacks();
    };

    _proto.componentDidUpdate = function componentDidUpdate() {
      var _this$props3 = this.props,
          direction = _this$props3.direction,
          layout = _this$props3.layout;
      var _this$state = this.state,
          scrollOffset = _this$state.scrollOffset,
          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;

      if (scrollUpdateWasRequested && this._outerRef != null) {
        var outerRef = this._outerRef; // TODO Deprecate direction "horizontal"

        if (direction === 'horizontal' || layout === 'horizontal') {
          if (direction === 'rtl') {
            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.
            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).
            // So we need to determine which browser behavior we're dealing with, and mimic it.
            switch (getRTLOffsetType()) {
              case 'negative':
                outerRef.scrollLeft = -scrollOffset;
                break;

              case 'positive-ascending':
                outerRef.scrollLeft = scrollOffset;
                break;

              default:
                var clientWidth = outerRef.clientWidth,
                    scrollWidth = outerRef.scrollWidth;
                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                break;
            }
          } else {
            outerRef.scrollLeft = scrollOffset;
          }
        } else {
          outerRef.scrollTop = scrollOffset;
        }
      }

      this._callPropsCallbacks();
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this._resetIsScrollingTimeoutId !== null) {
        cancelTimeout(this._resetIsScrollingTimeoutId);
      }
    };

    _proto.render = function render() {
      var _this$props4 = this.props,
          children = _this$props4.children,
          className = _this$props4.className,
          direction = _this$props4.direction,
          height = _this$props4.height,
          innerRef = _this$props4.innerRef,
          innerElementType = _this$props4.innerElementType,
          innerTagName = _this$props4.innerTagName,
          itemCount = _this$props4.itemCount,
          itemData = _this$props4.itemData,
          _this$props4$itemKey = _this$props4.itemKey,
          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,
          layout = _this$props4.layout,
          outerElementType = _this$props4.outerElementType,
          outerTagName = _this$props4.outerTagName,
          style = _this$props4.style,
          useIsScrolling = _this$props4.useIsScrolling,
          width = _this$props4.width;
      var isScrolling = this.state.isScrolling; // TODO Deprecate direction "horizontal"

      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;

      var _this$_getRangeToRend = this._getRangeToRender(),
          startIndex = _this$_getRangeToRend[0],
          stopIndex = _this$_getRangeToRend[1];

      var items = [];

      if (itemCount > 0) {
        for (var _index = startIndex; _index <= stopIndex; _index++) {
          items.push( /*#__PURE__*/Object(external_react_["createElement"])(children, {
            data: itemData,
            key: itemKey(_index, itemData),
            index: _index,
            isScrolling: useIsScrolling ? isScrolling : undefined,
            style: this._getItemStyle(_index)
          }));
        }
      } // Read this value AFTER items have been created,
      // So their actual sizes (if variable) are taken into consideration.


      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);
      return /*#__PURE__*/Object(external_react_["createElement"])(outerElementType || outerTagName || 'div', {
        className: className,
        onScroll: onScroll,
        ref: this._outerRefSetter,
        style: _extends({
          position: 'relative',
          height: height,
          width: width,
          overflow: 'auto',
          WebkitOverflowScrolling: 'touch',
          willChange: 'transform',
          direction: direction
        }, style)
      }, /*#__PURE__*/Object(external_react_["createElement"])(innerElementType || innerTagName || 'div', {
        children: items,
        ref: innerRef,
        style: {
          height: isHorizontal ? '100%' : estimatedTotalSize,
          pointerEvents: isScrolling ? 'none' : undefined,
          width: isHorizontal ? estimatedTotalSize : '100%'
        }
      }));
    };

    _proto._callPropsCallbacks = function _callPropsCallbacks() {
      if (typeof this.props.onItemsRendered === 'function') {
        var itemCount = this.props.itemCount;

        if (itemCount > 0) {
          var _this$_getRangeToRend2 = this._getRangeToRender(),
              _overscanStartIndex = _this$_getRangeToRend2[0],
              _overscanStopIndex = _this$_getRangeToRend2[1],
              _visibleStartIndex = _this$_getRangeToRend2[2],
              _visibleStopIndex = _this$_getRangeToRend2[3];

          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);
        }
      }

      if (typeof this.props.onScroll === 'function') {
        var _this$state2 = this.state,
            _scrollDirection = _this$state2.scrollDirection,
            _scrollOffset = _this$state2.scrollOffset,
            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;

        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);
      }
    }; // Lazily create and cache item styles while scrolling,
    // So that pure component sCU will prevent re-renders.
    // We maintain this cache, and pass a style prop rather than index,
    // So that List can clear cached styles and force item re-render if necessary.


    _proto._getRangeToRender = function _getRangeToRender() {
      var _this$props5 = this.props,
          itemCount = _this$props5.itemCount,
          overscanCount = _this$props5.overscanCount;
      var _this$state3 = this.state,
          isScrolling = _this$state3.isScrolling,
          scrollDirection = _this$state3.scrollDirection,
          scrollOffset = _this$state3.scrollOffset;

      if (itemCount === 0) {
        return [0, 0, 0, 0];
      }

      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);
      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.
      // If there isn't at least one extra item, tab loops back around.

      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;
      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    };

    return List;
  }(external_react_["PureComponent"]), _class.defaultProps = {
    direction: 'ltr',
    itemData: undefined,
    layout: 'vertical',
    overscanCount: 2,
    useIsScrolling: false
  }, _temp;
} // NOTE: I considered further wrapping individual items with a pure ListItem component.
// This would avoid ever calling the render function for the same index more than once,
// But it would also add the overhead of a lot of components/fibers.
// I assume people already do this (render function returning a class component),
// So my doing it would just unnecessarily double the wrappers.


var validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {
  var children = _ref2.children,
      direction = _ref2.direction,
      height = _ref2.height,
      layout = _ref2.layout,
      innerTagName = _ref2.innerTagName,
      outerTagName = _ref2.outerTagName,
      width = _ref2.width;
  var instance = _ref3.instance;

  if (false) { var isHorizontal; }
};

var DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;

var getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {
  var _ref = props,
      itemSize = _ref.itemSize;
  var itemMetadataMap = instanceProps.itemMetadataMap,
      lastMeasuredIndex = instanceProps.lastMeasuredIndex;

  if (index > lastMeasuredIndex) {
    var offset = 0;

    if (lastMeasuredIndex >= 0) {
      var itemMetadata = itemMetadataMap[lastMeasuredIndex];
      offset = itemMetadata.offset + itemMetadata.size;
    }

    for (var i = lastMeasuredIndex + 1; i <= index; i++) {
      var size = itemSize(i);
      itemMetadataMap[i] = {
        offset: offset,
        size: size
      };
      offset += size;
    }

    instanceProps.lastMeasuredIndex = index;
  }

  return itemMetadataMap[index];
};

var findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {
  var itemMetadataMap = instanceProps.itemMetadataMap,
      lastMeasuredIndex = instanceProps.lastMeasuredIndex;
  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;

  if (lastMeasuredItemOffset >= offset) {
    // If we've already measured items within this range just use a binary search as it's faster.
    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);
  } else {
    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.
    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.
    // The overall complexity for this approach is O(log n).
    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);
  }
};

var findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {
  while (low <= high) {
    var middle = low + Math.floor((high - low) / 2);
    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;

    if (currentOffset === offset) {
      return middle;
    } else if (currentOffset < offset) {
      low = middle + 1;
    } else if (currentOffset > offset) {
      high = middle - 1;
    }
  }

  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};

var findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {
  var itemCount = props.itemCount;
  var interval = 1;

  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {
    index += interval;
    interval *= 2;
  }

  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);
};

var index_esm_getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {
  var itemCount = _ref2.itemCount;
  var itemMetadataMap = _ref3.itemMetadataMap,
      estimatedItemSize = _ref3.estimatedItemSize,
      lastMeasuredIndex = _ref3.lastMeasuredIndex;
  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.
  // https://github.com/bvaughn/react-window/pull/138

  if (lastMeasuredIndex >= itemCount) {
    lastMeasuredIndex = itemCount - 1;
  }

  if (lastMeasuredIndex >= 0) {
    var itemMetadata = itemMetadataMap[lastMeasuredIndex];
    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;
  }

  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;
  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;
  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
};

var VariableSizeList = /*#__PURE__*/createListComponent({
  getItemOffset: function getItemOffset(props, index, instanceProps) {
    return getItemMetadata$1(props, index, instanceProps).offset;
  },
  getItemSize: function getItemSize(props, index, instanceProps) {
    return instanceProps.itemMetadataMap[index].size;
  },
  getEstimatedTotalSize: index_esm_getEstimatedTotalSize,
  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {
    var direction = props.direction,
        height = props.height,
        layout = props.layout,
        width = props.width; // TODO Deprecate direction "horizontal"

    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
    var size = isHorizontal ? width : height;
    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,
    // To ensure it reflects actual measurements instead of just estimates.

    var estimatedTotalSize = index_esm_getEstimatedTotalSize(props, instanceProps);
    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));
    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);

    if (align === 'smart') {
      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
        align = 'auto';
      } else {
        align = 'center';
      }
    }

    switch (align) {
      case 'start':
        return maxOffset;

      case 'end':
        return minOffset;

      case 'center':
        return Math.round(minOffset + (maxOffset - minOffset) / 2);

      case 'auto':
      default:
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }

    }
  },
  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {
    return findNearestItem$1(props, instanceProps, offset);
  },
  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {
    var direction = props.direction,
        height = props.height,
        itemCount = props.itemCount,
        layout = props.layout,
        width = props.width; // TODO Deprecate direction "horizontal"

    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
    var size = isHorizontal ? width : height;
    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);
    var maxOffset = scrollOffset + size;
    var offset = itemMetadata.offset + itemMetadata.size;
    var stopIndex = startIndex;

    while (stopIndex < itemCount - 1 && offset < maxOffset) {
      stopIndex++;
      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;
    }

    return stopIndex;
  },
  initInstanceProps: function initInstanceProps(props, instance) {
    var _ref4 = props,
        estimatedItemSize = _ref4.estimatedItemSize;
    var instanceProps = {
      itemMetadataMap: {},
      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,
      lastMeasuredIndex: -1
    };

    instance.resetAfterIndex = function (index, shouldForceUpdate) {
      if (shouldForceUpdate === void 0) {
        shouldForceUpdate = true;
      }

      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,
      // But since styles are only cached while scrolling is in progress-
      // It seems an unnecessary optimization.
      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.

      instance._getItemStyleCache(-1);

      if (shouldForceUpdate) {
        instance.forceUpdate();
      }
    };

    return instanceProps;
  },
  shouldResetStyleCacheOnItemSizeChange: false,
  validateProps: function validateProps(_ref5) {
    var itemSize = _ref5.itemSize;

    if (false) {}
  }
});
var FixedSizeGrid = /*#__PURE__*/createGridComponent({
  getColumnOffset: function getColumnOffset(_ref, index) {
    var columnWidth = _ref.columnWidth;
    return index * columnWidth;
  },
  getColumnWidth: function getColumnWidth(_ref2, index) {
    var columnWidth = _ref2.columnWidth;
    return columnWidth;
  },
  getRowOffset: function getRowOffset(_ref3, index) {
    var rowHeight = _ref3.rowHeight;
    return index * rowHeight;
  },
  getRowHeight: function getRowHeight(_ref4, index) {
    var rowHeight = _ref4.rowHeight;
    return rowHeight;
  },
  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {
    var rowCount = _ref5.rowCount,
        rowHeight = _ref5.rowHeight;
    return rowHeight * rowCount;
  },
  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {
    var columnCount = _ref6.columnCount,
        columnWidth = _ref6.columnWidth;
    return columnWidth * columnCount;
  },
  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {
    var columnCount = _ref7.columnCount,
        columnWidth = _ref7.columnWidth,
        width = _ref7.width;
    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);
    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);
    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);

    if (align === 'smart') {
      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {
        align = 'auto';
      } else {
        align = 'center';
      }
    }

    switch (align) {
      case 'start':
        return maxOffset;

      case 'end':
        return minOffset;

      case 'center':
        // "Centered" offset is usually the average of the min and max.
        // But near the edges of the list, this doesn't hold true.
        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);

        if (middleOffset < Math.ceil(width / 2)) {
          return 0; // near the beginning
        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {
          return lastColumnOffset; // near the end
        } else {
          return middleOffset;
        }

      case 'auto':
      default:
        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {
          return scrollLeft;
        } else if (minOffset > maxOffset) {
          // Because we only take into account the scrollbar size when calculating minOffset
          // this value can be larger than maxOffset when at the end of the list
          return minOffset;
        } else if (scrollLeft < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }

    }
  },
  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {
    var rowHeight = _ref8.rowHeight,
        height = _ref8.height,
        rowCount = _ref8.rowCount;
    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);
    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);
    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);

    if (align === 'smart') {
      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {
        align = 'auto';
      } else {
        align = 'center';
      }
    }

    switch (align) {
      case 'start':
        return maxOffset;

      case 'end':
        return minOffset;

      case 'center':
        // "Centered" offset is usually the average of the min and max.
        // But near the edges of the list, this doesn't hold true.
        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);

        if (middleOffset < Math.ceil(height / 2)) {
          return 0; // near the beginning
        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {
          return lastRowOffset; // near the end
        } else {
          return middleOffset;
        }

      case 'auto':
      default:
        if (scrollTop >= minOffset && scrollTop <= maxOffset) {
          return scrollTop;
        } else if (minOffset > maxOffset) {
          // Because we only take into account the scrollbar size when calculating minOffset
          // this value can be larger than maxOffset when at the end of the list
          return minOffset;
        } else if (scrollTop < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }

    }
  },
  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {
    var columnWidth = _ref9.columnWidth,
        columnCount = _ref9.columnCount;
    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));
  },
  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {
    var columnWidth = _ref10.columnWidth,
        columnCount = _ref10.columnCount,
        width = _ref10.width;
    var left = startIndex * columnWidth;
    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);
    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive
    ));
  },
  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {
    var rowHeight = _ref11.rowHeight,
        rowCount = _ref11.rowCount;
    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));
  },
  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {
    var rowHeight = _ref12.rowHeight,
        rowCount = _ref12.rowCount,
        height = _ref12.height;
    var top = startIndex * rowHeight;
    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);
    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive
    ));
  },
  initInstanceProps: function initInstanceProps(props) {// Noop
  },
  shouldResetStyleCacheOnItemSizeChange: true,
  validateProps: function validateProps(_ref13) {
    var columnWidth = _ref13.columnWidth,
        rowHeight = _ref13.rowHeight;

    if (false) {}
  }
});
var FixedSizeList = /*#__PURE__*/createListComponent({
  getItemOffset: function getItemOffset(_ref, index) {
    var itemSize = _ref.itemSize;
    return index * itemSize;
  },
  getItemSize: function getItemSize(_ref2, index) {
    var itemSize = _ref2.itemSize;
    return itemSize;
  },
  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {
    var itemCount = _ref3.itemCount,
        itemSize = _ref3.itemSize;
    return itemSize * itemCount;
  },
  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset) {
    var direction = _ref4.direction,
        height = _ref4.height,
        itemCount = _ref4.itemCount,
        itemSize = _ref4.itemSize,
        layout = _ref4.layout,
        width = _ref4.width; // TODO Deprecate direction "horizontal"

    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
    var size = isHorizontal ? width : height;
    var lastItemOffset = Math.max(0, itemCount * itemSize - size);
    var maxOffset = Math.min(lastItemOffset, index * itemSize);
    var minOffset = Math.max(0, index * itemSize - size + itemSize);

    if (align === 'smart') {
      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
        align = 'auto';
      } else {
        align = 'center';
      }
    }

    switch (align) {
      case 'start':
        return maxOffset;

      case 'end':
        return minOffset;

      case 'center':
        {
          // "Centered" offset is usually the average of the min and max.
          // But near the edges of the list, this doesn't hold true.
          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);

          if (middleOffset < Math.ceil(size / 2)) {
            return 0; // near the beginning
          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {
            return lastItemOffset; // near the end
          } else {
            return middleOffset;
          }
        }

      case 'auto':
      default:
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }

    }
  },
  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {
    var itemCount = _ref5.itemCount,
        itemSize = _ref5.itemSize;
    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));
  },
  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {
    var direction = _ref6.direction,
        height = _ref6.height,
        itemCount = _ref6.itemCount,
        itemSize = _ref6.itemSize,
        layout = _ref6.layout,
        width = _ref6.width; // TODO Deprecate direction "horizontal"

    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
    var offset = startIndex * itemSize;
    var size = isHorizontal ? width : height;
    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);
    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive
    ));
  },
  initInstanceProps: function initInstanceProps(props) {// Noop
  },
  shouldResetStyleCacheOnItemSizeChange: true,
  validateProps: function validateProps(_ref7) {
    var itemSize = _ref7.itemSize;

    if (false) {}
  }
}); // Pulled from react-compat
// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349

function shallowDiffers(prev, next) {
  for (var attribute in prev) {
    if (!(attribute in next)) {
      return true;
    }
  }

  for (var _attribute in next) {
    if (prev[_attribute] !== next[_attribute]) {
      return true;
    }
  }

  return false;
} // It knows to compare individual style props and ignore the wrapper object.
// See https://reactjs.org/docs/react-api.html#reactmemo


function areEqual(prevProps, nextProps) {
  var prevStyle = prevProps.style,
      prevRest = _objectWithoutPropertiesLoose(prevProps, ["style"]);

  var nextStyle = nextProps.style,
      nextRest = _objectWithoutPropertiesLoose(nextProps, ["style"]);

  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);
} // It knows to compare individual style props and ignore the wrapper object.
// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate


function shouldComponentUpdate(nextProps, nextState) {
  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);
}


// EXTERNAL MODULE: external "scheduler"
var external_scheduler_ = __webpack_require__(55);

// EXTERNAL MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/escape-string-regexp/index.js
var escape_string_regexp = __webpack_require__(78);
var escape_string_regexp_default = /*#__PURE__*/__webpack_require__.n(escape_string_regexp);

// EXTERNAL MODULE: ../react-devtools-shared/src/hydration.js
var hydration = __webpack_require__(8);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/utils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



function alphaSortEntries(entryA, entryB) {
  const a = entryA[0];
  const b = entryB[0];

  if ('' + +a === a) {
    if ('' + +b !== b) {
      return -1;
    }

    return +a < +b ? -1 : 1;
  }

  return a < b ? -1 : 1;
}
function createRegExp(string) {
  // Allow /regex/ syntax with optional last /
  if (string[0] === '/') {
    // Cut off first slash
    string = string.substring(1); // Cut off last slash, but only if it's there

    if (string[string.length - 1] === '/') {
      string = string.substring(0, string.length - 1);
    }

    try {
      return new RegExp(string, 'i');
    } catch (err) {
      // Bad regex. Make it not match anything.
      // TODO: maybe warn in console?
      return new RegExp('.^');
    }
  }

  function isLetter(char) {
    return char.toLowerCase() !== char.toUpperCase();
  }

  function matchAnyCase(char) {
    if (!isLetter(char)) {
      // Don't mess with special characters like [.
      return char;
    }

    return '[' + char.toLowerCase() + char.toUpperCase() + ']';
  } // 'item' should match 'Item' and 'ListItem', but not 'InviteMom'.
  // To do this, we'll slice off 'tem' and check first letter separately.


  const escaped = escape_string_regexp_default()(string);
  const firstChar = escaped[0];
  let restRegex = ''; // For 'item' input, restRegex becomes '[tT][eE][mM]'
  // We can't simply make it case-insensitive because first letter case matters.

  for (let i = 1; i < escaped.length; i++) {
    restRegex += matchAnyCase(escaped[i]);
  }

  if (!isLetter(firstChar)) {
    // We can't put a non-character like [ in a group
    // so we fall back to the simple case.
    return new RegExp(firstChar + restRegex);
  } // Construct a smarter regex.


  return new RegExp( // For example:
  // (^[iI]|I)[tT][eE][mM]
  // Matches:
  // 'Item'
  // 'ListItem'
  // but not 'InviteMom'
  '(^' + matchAnyCase(firstChar) + '|' + firstChar.toUpperCase() + ')' + restRegex);
}
function getMetaValueLabel(data) {
  if (hasOwnProperty.call(data, hydration["d" /* meta */].preview_long)) {
    return data[hydration["d" /* meta */].preview_long];
  } else {
    return Object(utils["b" /* formatDataForPreview */])(data, true);
  }
}

function sanitize(data) {
  for (const key in data) {
    const value = data[key];

    if (value && value[hydration["d" /* meta */].type]) {
      data[key] = getMetaValueLabel(value);
    } else if (value != null) {
      if (Array.isArray(value)) {
        sanitize(value);
      } else if (typeof value === 'object') {
        sanitize(value);
      }
    }
  }
}

function serializeDataForCopy(props) {
  const cloned = Object.assign({}, props);
  sanitize(cloned);

  try {
    return JSON.stringify(cloned, null, 2);
  } catch (error) {
    return '';
  }
}
function serializeHooksForCopy(hooks) {
  // $FlowFixMe "HooksTree is not an object"
  const cloned = Object.assign([], hooks);
  const queue = [...cloned];

  while (queue.length > 0) {
    const current = queue.pop(); // These aren't meaningful

    delete current.id;
    delete current.isStateEditable;

    if (current.subHooks.length > 0) {
      queue.push(...current.subHooks);
    }
  }

  sanitize(cloned);

  try {
    return JSON.stringify(cloned, null, 2);
  } catch (error) {
    return '';
  }
} // Keeping this in memory seems to be enough to enable the browser to download larger profiles.
// Without this, we would see a "Download failed: network error" failure.

let downloadUrl = null;
function downloadFile(element, filename, text) {
  const blob = new Blob([text], {
    type: 'text/plain;charset=utf-8'
  });

  if (downloadUrl !== null) {
    URL.revokeObjectURL(downloadUrl);
  }

  downloadUrl = URL.createObjectURL(blob);
  element.setAttribute('href', downloadUrl);
  element.setAttribute('download', filename);
  element.click();
}
function truncateText(text, maxLength) {
  const length = text.length;

  if (length > maxLength) {
    return text.substr(0, Math.floor(maxLength / 2)) + 'â€¦' + text.substr(length - Math.ceil(maxLength / 2) - 1);
  } else {
    return text;
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/TreeContext.js
function TreeContext_slicedToArray(arr, i) { return TreeContext_arrayWithHoles(arr) || TreeContext_iterableToArrayLimit(arr, i) || TreeContext_unsupportedIterableToArray(arr, i) || TreeContext_nonIterableRest(); }

function TreeContext_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function TreeContext_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TreeContext_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TreeContext_arrayLikeToArray(o, minLen); }

function TreeContext_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function TreeContext_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function TreeContext_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function TreeContext_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function TreeContext_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TreeContext_ownKeys(Object(source), true).forEach(function (key) { TreeContext_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TreeContext_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function TreeContext_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This context combines tree/selection state, search, and the owners stack.
// These values are managed together because changes in one often impact the others.
// Combining them enables us to avoid cascading renders.
//
// Changes to search state may impact tree state.
// For example, updating the selected search result also updates the tree's selected value.
// Search does not fundamentally change the tree though.
// It is also possible to update the selected tree value independently.
//
// Changes to owners state mask search and tree values.
// When owners stack is not empty, search is temporarily disabled,
// and tree values (e.g. num elements, selected element) are masked.
// Both tree and search values are restored when the owners stack is cleared.
//
// For this reason, changes to the tree context are processed in sequence: tree -> search -> owners
// This enables each section to potentially override (or mask) previous values.






const TreeStateContext = /*#__PURE__*/Object(external_react_["createContext"])(null);
TreeStateContext.displayName = 'TreeStateContext';
const TreeDispatcherContext = /*#__PURE__*/Object(external_react_["createContext"])(null);
TreeDispatcherContext.displayName = 'TreeDispatcherContext';

function reduceTreeState(store, state, action) {
  let numElements = state.numElements,
      ownerSubtreeLeafElementID = state.ownerSubtreeLeafElementID,
      selectedElementIndex = state.selectedElementIndex,
      selectedElementID = state.selectedElementID;
  const ownerID = state.ownerID;
  let lookupIDForIndex = true; // Base tree should ignore selected element changes when the owner's tree is active.

  if (ownerID === null) {
    switch (action.type) {
      case 'HANDLE_STORE_MUTATION':
        numElements = store.numElements; // If the currently-selected Element has been removed from the tree, update selection state.

        const removedIDs = action.payload[1]; // Find the closest parent that wasn't removed during this batch.
        // We deduce the parent-child mapping from removedIDs (id -> parentID)
        // because by now it's too late to read them from the store.

        while (selectedElementID !== null && removedIDs.has(selectedElementID)) {
          selectedElementID = removedIDs.get(selectedElementID);
        }

        if (selectedElementID === 0) {
          // The whole root was removed.
          selectedElementIndex = null;
        }

        break;

      case 'SELECT_CHILD_ELEMENT_IN_TREE':
        ownerSubtreeLeafElementID = null;

        if (selectedElementIndex !== null) {
          const selectedElement = store.getElementAtIndex(selectedElementIndex);

          if (selectedElement !== null && selectedElement.children.length > 0 && !selectedElement.isCollapsed) {
            const firstChildID = selectedElement.children[0];
            const firstChildIndex = store.getIndexOfElementID(firstChildID);

            if (firstChildIndex !== null) {
              selectedElementIndex = firstChildIndex;
            }
          }
        }

        break;

      case 'SELECT_ELEMENT_AT_INDEX':
        ownerSubtreeLeafElementID = null;
        selectedElementIndex = action.payload;
        break;

      case 'SELECT_ELEMENT_BY_ID':
        ownerSubtreeLeafElementID = null; // Skip lookup in this case; it would be redundant.
        // It might also cause problems if the specified element was inside of a (not yet expanded) subtree.

        lookupIDForIndex = false;
        selectedElementID = action.payload;
        selectedElementIndex = selectedElementID === null ? null : store.getIndexOfElementID(selectedElementID);
        break;

      case 'SELECT_NEXT_ELEMENT_IN_TREE':
        ownerSubtreeLeafElementID = null;

        if (selectedElementIndex === null || selectedElementIndex + 1 >= numElements) {
          selectedElementIndex = 0;
        } else {
          selectedElementIndex++;
        }

        break;

      case 'SELECT_NEXT_SIBLING_IN_TREE':
        ownerSubtreeLeafElementID = null;

        if (selectedElementIndex !== null) {
          const selectedElement = store.getElementAtIndex(selectedElementIndex);

          if (selectedElement !== null && selectedElement.parentID !== 0) {
            const parent = store.getElementByID(selectedElement.parentID);

            if (parent !== null) {
              const children = parent.children;
              const selectedChildIndex = children.indexOf(selectedElement.id);
              const nextChildID = selectedChildIndex < children.length - 1 ? children[selectedChildIndex + 1] : children[0];
              selectedElementIndex = store.getIndexOfElementID(nextChildID);
            }
          }
        }

        break;

      case 'SELECT_OWNER_LIST_NEXT_ELEMENT_IN_TREE':
        if (selectedElementIndex !== null) {
          if (ownerSubtreeLeafElementID !== null && ownerSubtreeLeafElementID !== selectedElementID) {
            const leafElement = store.getElementByID(ownerSubtreeLeafElementID);

            if (leafElement !== null) {
              let currentElement = leafElement;

              while (currentElement !== null) {
                if (currentElement.ownerID === selectedElementID) {
                  selectedElementIndex = store.getIndexOfElementID(currentElement.id);
                  break;
                } else if (currentElement.ownerID !== 0) {
                  currentElement = store.getElementByID(currentElement.ownerID);
                }
              }
            }
          }
        }

        break;

      case 'SELECT_OWNER_LIST_PREVIOUS_ELEMENT_IN_TREE':
        if (selectedElementIndex !== null) {
          if (ownerSubtreeLeafElementID === null) {
            // If this is the first time we're stepping through the owners tree,
            // pin the current component as the owners list leaf.
            // This will enable us to step back down to this component.
            ownerSubtreeLeafElementID = selectedElementID;
          }

          const selectedElement = store.getElementAtIndex(selectedElementIndex);

          if (selectedElement !== null && selectedElement.ownerID !== 0) {
            const ownerIndex = store.getIndexOfElementID(selectedElement.ownerID);

            if (ownerIndex !== null) {
              selectedElementIndex = ownerIndex;
            }
          }
        }

        break;

      case 'SELECT_PARENT_ELEMENT_IN_TREE':
        ownerSubtreeLeafElementID = null;

        if (selectedElementIndex !== null) {
          const selectedElement = store.getElementAtIndex(selectedElementIndex);

          if (selectedElement !== null && selectedElement.parentID !== 0) {
            const parentIndex = store.getIndexOfElementID(selectedElement.parentID);

            if (parentIndex !== null) {
              selectedElementIndex = parentIndex;
            }
          }
        }

        break;

      case 'SELECT_PREVIOUS_ELEMENT_IN_TREE':
        ownerSubtreeLeafElementID = null;

        if (selectedElementIndex === null || selectedElementIndex === 0) {
          selectedElementIndex = numElements - 1;
        } else {
          selectedElementIndex--;
        }

        break;

      case 'SELECT_PREVIOUS_SIBLING_IN_TREE':
        ownerSubtreeLeafElementID = null;

        if (selectedElementIndex !== null) {
          const selectedElement = store.getElementAtIndex(selectedElementIndex);

          if (selectedElement !== null && selectedElement.parentID !== 0) {
            const parent = store.getElementByID(selectedElement.parentID);

            if (parent !== null) {
              const children = parent.children;
              const selectedChildIndex = children.indexOf(selectedElement.id);
              const nextChildID = selectedChildIndex > 0 ? children[selectedChildIndex - 1] : children[children.length - 1];
              selectedElementIndex = store.getIndexOfElementID(nextChildID);
            }
          }
        }

        break;

      default:
        // React can bailout of no-op updates.
        return state;
    }
  } // Keep selected item ID and index in sync.


  if (lookupIDForIndex && selectedElementIndex !== state.selectedElementIndex) {
    if (selectedElementIndex === null) {
      selectedElementID = null;
    } else {
      selectedElementID = store.getElementIDAtIndex(selectedElementIndex);
    }
  }

  return TreeContext_objectSpread(TreeContext_objectSpread({}, state), {}, {
    numElements,
    ownerSubtreeLeafElementID,
    selectedElementIndex,
    selectedElementID
  });
}

function reduceSearchState(store, state, action) {
  let searchIndex = state.searchIndex,
      searchResults = state.searchResults,
      searchText = state.searchText,
      selectedElementID = state.selectedElementID,
      selectedElementIndex = state.selectedElementIndex;
  const ownerID = state.ownerID;
  const prevSearchIndex = searchIndex;
  const prevSearchText = searchText;
  const numPrevSearchResults = searchResults.length; // We track explicitly whether search was requested because
  // we might want to search even if search index didn't change.
  // For example, if you press "next result" on a search with a single
  // result but a different current selection, we'll set this to true.

  let didRequestSearch = false; // Search isn't supported when the owner's tree is active.

  if (ownerID === null) {
    switch (action.type) {
      case 'GO_TO_NEXT_SEARCH_RESULT':
        if (numPrevSearchResults > 0) {
          didRequestSearch = true;
          searchIndex = searchIndex + 1 < numPrevSearchResults ? searchIndex + 1 : 0;
        }

        break;

      case 'GO_TO_PREVIOUS_SEARCH_RESULT':
        if (numPrevSearchResults > 0) {
          didRequestSearch = true;
          searchIndex = searchIndex > 0 ? searchIndex - 1 : numPrevSearchResults - 1;
        }

        break;

      case 'HANDLE_STORE_MUTATION':
        if (searchText !== '') {
          const _payload = TreeContext_slicedToArray(action.payload, 2),
                addedElementIDs = _payload[0],
                removedElementIDs = _payload[1];

          removedElementIDs.forEach((parentID, id) => {
            // Prune this item from the search results.
            const index = searchResults.indexOf(id);

            if (index >= 0) {
              searchResults = searchResults.slice(0, index).concat(searchResults.slice(index + 1)); // If the results are now empty, also deselect things.

              if (searchResults.length === 0) {
                searchIndex = null;
              } else if (searchIndex >= searchResults.length) {
                searchIndex = searchResults.length - 1;
              }
            }
          });
          addedElementIDs.forEach(id => {
            const element = store.getElementByID(id); // It's possible that multiple tree operations will fire before this action has run.
            // So it's important to check for elements that may have been added and then removed.

            if (element !== null) {
              const displayName = element.displayName; // Add this item to the search results if it matches.

              const regExp = createRegExp(searchText);

              if (displayName !== null && regExp.test(displayName)) {
                const newElementIndex = store.getIndexOfElementID(id);
                let foundMatch = false;

                for (let index = 0; index < searchResults.length; index++) {
                  const resultID = searchResults[index];

                  if (newElementIndex < store.getIndexOfElementID(resultID)) {
                    foundMatch = true;
                    searchResults = searchResults.slice(0, index).concat(resultID).concat(searchResults.slice(index));
                    break;
                  }
                }

                if (!foundMatch) {
                  searchResults = searchResults.concat(id);
                }

                searchIndex = searchIndex === null ? 0 : searchIndex;
              }
            }
          });
        }

        break;

      case 'SET_SEARCH_TEXT':
        searchIndex = null;
        searchResults = [];
        searchText = action.payload;

        if (searchText !== '') {
          const regExp = createRegExp(searchText);
          store.roots.forEach(rootID => {
            recursivelySearchTree(store, rootID, regExp, searchResults);
          });

          if (searchResults.length > 0) {
            if (prevSearchIndex === null) {
              if (selectedElementIndex !== null) {
                searchIndex = getNearestResultIndex(store, searchResults, selectedElementIndex);
              } else {
                searchIndex = 0;
              }
            } else {
              searchIndex = Math.min(prevSearchIndex, searchResults.length - 1);
            }
          }
        }

        break;

      default:
        // React can bailout of no-op updates.
        return state;
    }
  }

  if (searchText !== prevSearchText) {
    const newSearchIndex = searchResults.indexOf(selectedElementID);

    if (newSearchIndex === -1) {
      // Only move the selection if the new query
      // doesn't match the current selection anymore.
      didRequestSearch = true;
    } else {
      // Selected item still matches the new search query.
      // Adjust the index to reflect its position in new results.
      searchIndex = newSearchIndex;
    }
  }

  if (didRequestSearch && searchIndex !== null) {
    selectedElementID = searchResults[searchIndex];
    selectedElementIndex = store.getIndexOfElementID(selectedElementID);
  }

  return TreeContext_objectSpread(TreeContext_objectSpread({}, state), {}, {
    selectedElementID,
    selectedElementIndex,
    searchIndex,
    searchResults,
    searchText
  });
}

function reduceOwnersState(store, state, action) {
  let numElements = state.numElements,
      selectedElementID = state.selectedElementID,
      selectedElementIndex = state.selectedElementIndex,
      ownerID = state.ownerID,
      ownerFlatTree = state.ownerFlatTree;
  const searchIndex = state.searchIndex,
        searchResults = state.searchResults,
        searchText = state.searchText;
  let prevSelectedElementIndex = selectedElementIndex;

  switch (action.type) {
    case 'HANDLE_STORE_MUTATION':
      if (ownerID !== null) {
        if (!store.containsElement(ownerID)) {
          ownerID = null;
          ownerFlatTree = null;
          selectedElementID = null;
        } else {
          ownerFlatTree = store.getOwnersListForElement(ownerID);

          if (selectedElementID !== null) {
            // Mutation might have caused the index of this ID to shift.
            selectedElementIndex = ownerFlatTree.findIndex(element => element.id === selectedElementID);
          }
        }
      } else {
        if (selectedElementID !== null) {
          // Mutation might have caused the index of this ID to shift.
          selectedElementIndex = store.getIndexOfElementID(selectedElementID);
        }
      }

      if (selectedElementIndex === -1) {
        // If we couldn't find this ID after mutation, unselect it.
        selectedElementIndex = null;
        selectedElementID = null;
      }

      break;

    case 'RESET_OWNER_STACK':
      ownerID = null;
      ownerFlatTree = null;
      selectedElementIndex = selectedElementID !== null ? store.getIndexOfElementID(selectedElementID) : null;
      break;

    case 'SELECT_ELEMENT_AT_INDEX':
      if (ownerFlatTree !== null) {
        selectedElementIndex = action.payload;
      }

      break;

    case 'SELECT_ELEMENT_BY_ID':
      if (ownerFlatTree !== null) {
        const payload = action.payload;

        if (payload === null) {
          selectedElementIndex = null;
        } else {
          selectedElementIndex = ownerFlatTree.findIndex(element => element.id === payload); // If the selected element is outside of the current owners list,
          // exit the list and select the element in the main tree.
          // This supports features like toggling Suspense.

          if (selectedElementIndex !== null && selectedElementIndex < 0) {
            ownerID = null;
            ownerFlatTree = null;
            selectedElementIndex = store.getIndexOfElementID(payload);
          }
        }
      }

      break;

    case 'SELECT_NEXT_ELEMENT_IN_TREE':
      if (ownerFlatTree !== null && ownerFlatTree.length > 0) {
        if (selectedElementIndex === null) {
          selectedElementIndex = 0;
        } else if (selectedElementIndex + 1 < ownerFlatTree.length) {
          selectedElementIndex++;
        }
      }

      break;

    case 'SELECT_PREVIOUS_ELEMENT_IN_TREE':
      if (ownerFlatTree !== null && ownerFlatTree.length > 0) {
        if (selectedElementIndex !== null && selectedElementIndex > 0) {
          selectedElementIndex--;
        }
      }

      break;

    case 'SELECT_OWNER':
      // If the Store doesn't have any owners metadata, don't drill into an empty stack.
      // This is a confusing user experience.
      if (store.hasOwnerMetadata) {
        ownerID = action.payload;
        ownerFlatTree = store.getOwnersListForElement(ownerID); // Always force reset selection to be the top of the new owner tree.

        selectedElementIndex = 0;
        prevSelectedElementIndex = null;
      }

      break;

    default:
      // React can bailout of no-op updates.
      return state;
  } // Changes in the selected owner require re-calculating the owners tree.


  if (ownerFlatTree !== state.ownerFlatTree || action.type === 'HANDLE_STORE_MUTATION') {
    if (ownerFlatTree === null) {
      numElements = store.numElements;
    } else {
      numElements = ownerFlatTree.length;
    }
  } // Keep selected item ID and index in sync.


  if (selectedElementIndex !== prevSelectedElementIndex) {
    if (selectedElementIndex === null) {
      selectedElementID = null;
    } else {
      if (ownerFlatTree !== null) {
        selectedElementID = ownerFlatTree[selectedElementIndex].id;
      }
    }
  }

  return TreeContext_objectSpread(TreeContext_objectSpread({}, state), {}, {
    numElements,
    selectedElementID,
    selectedElementIndex,
    searchIndex,
    searchResults,
    searchText,
    ownerID,
    ownerFlatTree
  });
}

function reduceSuspenseState(store, state, action) {
  const type = action.type;

  switch (type) {
    case 'UPDATE_INSPECTED_ELEMENT_ID':
      if (state.inspectedElementID !== state.selectedElementID) {
        return TreeContext_objectSpread(TreeContext_objectSpread({}, state), {}, {
          inspectedElementID: state.selectedElementID
        });
      }

      break;

    default:
      break;
  } // React can bailout of no-op updates.


  return state;
}

// TODO Remove TreeContextController wrapper element once global ConsearchText.write API exists.
function TreeContextController({
  children,
  defaultInspectedElementID,
  defaultOwnerID,
  defaultSelectedElementID,
  defaultSelectedElementIndex
}) {
  const bridge = Object(external_react_["useContext"])(BridgeContext);
  const store = Object(external_react_["useContext"])(StoreContext);
  const initialRevision = Object(external_react_["useMemo"])(() => store.revision, [store]); // This reducer is created inline because it needs access to the Store.
  // The store is mutable, but the Store itself is global and lives for the lifetime of the DevTools,
  // so it's okay for the reducer to have an empty dependencies array.

  const reducer = Object(external_react_["useMemo"])(() => (state, action) => {
    const type = action.type;

    switch (type) {
      case 'GO_TO_NEXT_SEARCH_RESULT':
      case 'GO_TO_PREVIOUS_SEARCH_RESULT':
      case 'HANDLE_STORE_MUTATION':
      case 'RESET_OWNER_STACK':
      case 'SELECT_ELEMENT_AT_INDEX':
      case 'SELECT_ELEMENT_BY_ID':
      case 'SELECT_CHILD_ELEMENT_IN_TREE':
      case 'SELECT_NEXT_ELEMENT_IN_TREE':
      case 'SELECT_NEXT_SIBLING_IN_TREE':
      case 'SELECT_OWNER_LIST_NEXT_ELEMENT_IN_TREE':
      case 'SELECT_OWNER_LIST_PREVIOUS_ELEMENT_IN_TREE':
      case 'SELECT_PARENT_ELEMENT_IN_TREE':
      case 'SELECT_PREVIOUS_ELEMENT_IN_TREE':
      case 'SELECT_PREVIOUS_SIBLING_IN_TREE':
      case 'SELECT_OWNER':
      case 'UPDATE_INSPECTED_ELEMENT_ID':
      case 'SET_SEARCH_TEXT':
        state = reduceTreeState(store, state, action);
        state = reduceSearchState(store, state, action);
        state = reduceOwnersState(store, state, action);
        state = reduceSuspenseState(store, state, action); // If the selected ID is in a collapsed subtree, reset the selected index to null.
        // We'll know the correct index after the layout effect will toggle the tree,
        // and the store tree is mutated to account for that.

        if (state.selectedElementID !== null && store.isInsideCollapsedSubTree(state.selectedElementID)) {
          return TreeContext_objectSpread(TreeContext_objectSpread({}, state), {}, {
            selectedElementIndex: null
          });
        }

        return state;

      default:
        throw new Error(`Unrecognized action "${type}"`);
    }
  }, [store]);

  const _useReducer = Object(external_react_["useReducer"])(reducer, {
    // Tree
    numElements: store.numElements,
    ownerSubtreeLeafElementID: null,
    selectedElementID: defaultSelectedElementID == null ? null : defaultSelectedElementID,
    selectedElementIndex: defaultSelectedElementIndex == null ? null : defaultSelectedElementIndex,
    // Search
    searchIndex: null,
    searchResults: [],
    searchText: '',
    // Owners
    ownerID: defaultOwnerID == null ? null : defaultOwnerID,
    ownerFlatTree: null,
    // Inspection element panel
    inspectedElementID: defaultInspectedElementID == null ? null : defaultInspectedElementID
  }),
        _useReducer2 = TreeContext_slicedToArray(_useReducer, 2),
        state = _useReducer2[0],
        dispatch = _useReducer2[1];

  const dispatchWrapper = Object(external_react_["useCallback"])(action => {
    // Run the first update at "user-blocking" priority in case dispatch is called from a non-React event.
    // In this case, the current (and "next") priorities would both be "normal",
    // and suspense would potentially block both updates.
    Object(external_scheduler_["unstable_runWithPriority"])(external_scheduler_["unstable_UserBlockingPriority"], () => dispatch(action));
    Object(external_scheduler_["unstable_next"])(() => dispatch({
      type: 'UPDATE_INSPECTED_ELEMENT_ID'
    }));
  }, [dispatch]); // Listen for host element selections.

  Object(external_react_["useEffect"])(() => {
    const handleSelectFiber = id => dispatchWrapper({
      type: 'SELECT_ELEMENT_BY_ID',
      payload: id
    });

    bridge.addListener('selectFiber', handleSelectFiber);
    return () => bridge.removeListener('selectFiber', handleSelectFiber);
  }, [bridge, dispatchWrapper]); // If a newly-selected search result or inspection selection is inside of a collapsed subtree, auto expand it.
  // This needs to be a layout effect to avoid temporarily flashing an incorrect selection.

  const prevSelectedElementID = Object(external_react_["useRef"])(null);
  Object(external_react_["useLayoutEffect"])(() => {
    if (state.selectedElementID !== prevSelectedElementID.current) {
      prevSelectedElementID.current = state.selectedElementID;

      if (state.selectedElementID !== null) {
        const element = store.getElementByID(state.selectedElementID);

        if (element !== null && element.parentID > 0) {
          store.toggleIsCollapsed(element.parentID, false);
        }
      }
    }
  }, [state.selectedElementID, store]); // Mutations to the underlying tree may impact this context (e.g. search results, selection state).

  Object(external_react_["useEffect"])(() => {
    const handleStoreMutated = ([addedElementIDs, removedElementIDs]) => {
      dispatchWrapper({
        type: 'HANDLE_STORE_MUTATION',
        payload: [addedElementIDs, removedElementIDs]
      });
    }; // Since this is a passive effect, the tree may have been mutated before our initial subscription.


    if (store.revision !== initialRevision) {
      // At the moment, we can treat this as a mutation.
      // We don't know which Elements were newly added/removed, but that should be okay in this case.
      // It would only impact the search state, which is unlikely to exist yet at this point.
      dispatchWrapper({
        type: 'HANDLE_STORE_MUTATION',
        payload: [[], new Map()]
      });
    }

    store.addListener('mutated', handleStoreMutated);
    return () => store.removeListener('mutated', handleStoreMutated);
  }, [dispatchWrapper, initialRevision, store]);
  return /*#__PURE__*/external_react_["createElement"](TreeStateContext.Provider, {
    value: state
  }, /*#__PURE__*/external_react_["createElement"](TreeDispatcherContext.Provider, {
    value: dispatchWrapper
  }, children));
}

function recursivelySearchTree(store, elementID, regExp, searchResults) {
  const _ref = store.getElementByID(elementID),
        children = _ref.children,
        displayName = _ref.displayName,
        hocDisplayNames = _ref.hocDisplayNames;

  if (displayName != null && regExp.test(displayName) === true) {
    searchResults.push(elementID);
  } else if (hocDisplayNames != null && hocDisplayNames.length > 0 && hocDisplayNames.some(name => regExp.test(name)) === true) {
    searchResults.push(elementID);
  }

  children.forEach(childID => recursivelySearchTree(store, childID, regExp, searchResults));
}

function getNearestResultIndex(store, searchResults, selectedElementIndex) {
  const index = searchResults.findIndex(id => {
    const innerIndex = store.getIndexOfElementID(id);
    return innerIndex !== null && innerIndex >= selectedElementIndex;
  });
  return index === -1 ? 0 : index;
}


// EXTERNAL MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/lodash.throttle/index.js
var lodash_throttle = __webpack_require__(36);
var lodash_throttle_default = /*#__PURE__*/__webpack_require__.n(lodash_throttle);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/hooks.js
function hooks_slicedToArray(arr, i) { return hooks_arrayWithHoles(arr) || hooks_iterableToArrayLimit(arr, i) || hooks_unsupportedIterableToArray(arr, i) || hooks_nonIterableRest(); }

function hooks_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function hooks_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return hooks_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return hooks_arrayLikeToArray(o, minLen); }

function hooks_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function hooks_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function hooks_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function hooks_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function hooks_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { hooks_ownKeys(Object(source), true).forEach(function (key) { hooks_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { hooks_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function hooks_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






function useEditableValueReducer(state, action) {
  switch (action.type) {
    case 'RESET':
      return hooks_objectSpread(hooks_objectSpread({}, state), {}, {
        editableValue: smartStringify(action.externalValue),
        externalValue: action.externalValue,
        hasPendingChanges: false,
        isValid: true,
        parsedValue: action.externalValue
      });

    case 'UPDATE':
      let isNewValueValid = false;
      let newParsedValue;

      try {
        newParsedValue = smartParse(action.editableValue);
        isNewValueValid = true;
      } catch (error) {}

      return hooks_objectSpread(hooks_objectSpread({}, state), {}, {
        editableValue: sanitizeForParse(action.editableValue),
        externalValue: action.externalValue,
        hasPendingChanges: smartStringify(action.externalValue) !== action.editableValue,
        isValid: isNewValueValid,
        parsedValue: isNewValueValid ? newParsedValue : state.parsedValue
      });

    default:
      throw new Error(`Invalid action "${action.type}"`);
  }
} // Convenience hook for working with an editable value that is validated via JSON.parse.


function useEditableValue(externalValue) {
  const _useReducer = Object(external_react_["useReducer"])(useEditableValueReducer, {
    editableValue: smartStringify(externalValue),
    externalValue,
    hasPendingChanges: false,
    isValid: true,
    parsedValue: externalValue
  }),
        _useReducer2 = hooks_slicedToArray(_useReducer, 2),
        state = _useReducer2[0],
        dispatch = _useReducer2[1];

  if (!Object.is(state.externalValue, externalValue)) {
    if (!state.hasPendingChanges) {
      dispatch({
        type: 'RESET',
        externalValue
      });
    } else {
      dispatch({
        type: 'UPDATE',
        editableValue: state.editableValue,
        externalValue
      });
    }
  }

  return [state, dispatch];
}
function useIsOverflowing(containerRef, totalChildWidth) {
  const _useState = Object(external_react_["useState"])(false),
        _useState2 = hooks_slicedToArray(_useState, 2),
        isOverflowing = _useState2[0],
        setIsOverflowing = _useState2[1]; // It's important to use a layout effect, so that we avoid showing a flash of overflowed content.


  Object(external_react_["useLayoutEffect"])(() => {
    if (containerRef.current === null) {
      return () => {};
    }

    const container = containerRef.current;
    const handleResize = lodash_throttle_default()(() => setIsOverflowing(container.clientWidth <= totalChildWidth), 100);
    handleResize(); // It's important to listen to the ownerDocument.defaultView to support the browser extension.
    // Here we use portals to render individual tabs (e.g. Profiler),
    // and the root document might belong to a different window.

    const ownerWindow = container.ownerDocument.defaultView;
    ownerWindow.addEventListener('resize', handleResize);
    return () => ownerWindow.removeEventListener('resize', handleResize);
  }, [containerRef, totalChildWidth]);
  return isOverflowing;
} // Forked from https://usehooks.com/useLocalStorage/

function useLocalStorage(key, initialValue) {
  const getValueFromLocalStorage = Object(external_react_["useCallback"])(() => {
    try {
      const item = Object(storage["a" /* localStorageGetItem */])(key);

      if (item != null) {
        return JSON.parse(item);
      }
    } catch (error) {
      console.log(error);
    }

    if (typeof initialValue === 'function') {
      return initialValue();
    } else {
      return initialValue;
    }
  }, [initialValue, key]);

  const _useState3 = Object(external_react_["useState"])(getValueFromLocalStorage),
        _useState4 = hooks_slicedToArray(_useState3, 2),
        storedValue = _useState4[0],
        setStoredValue = _useState4[1];

  const setValue = Object(external_react_["useCallback"])(value => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      Object(storage["b" /* localStorageSetItem */])(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.log(error);
    }
  }, [key, storedValue]); // Listen for changes to this local storage value made from other windows.
  // This enables the e.g. "âš›ï¸ Elements" tab to update in response to changes from "âš›ï¸ Settings".

  Object(external_react_["useLayoutEffect"])(() => {
    const onStorage = event => {
      const newValue = getValueFromLocalStorage();

      if (key === event.key && storedValue !== newValue) {
        setValue(newValue);
      }
    };

    window.addEventListener('storage', onStorage);
    return () => {
      window.removeEventListener('storage', onStorage);
    };
  }, [getValueFromLocalStorage, key, storedValue, setValue]);
  return [storedValue, setValue];
}
function useModalDismissSignal(modalRef, dismissCallback, dismissOnClickOutside = true) {
  Object(external_react_["useEffect"])(() => {
    if (modalRef.current === null) {
      return () => {};
    }

    const handleDocumentKeyDown = ({
      key
    }) => {
      if (key === 'Escape') {
        dismissCallback();
      }
    };

    const handleDocumentClick = event => {
      // $FlowFixMe
      if (modalRef.current !== null && !modalRef.current.contains(event.target)) {
        event.stopPropagation();
        event.preventDefault();
        dismissCallback();
      }
    }; // It's important to listen to the ownerDocument to support the browser extension.
    // Here we use portals to render individual tabs (e.g. Profiler),
    // and the root document might belong to a different window.


    const ownerDocument = modalRef.current.ownerDocument;
    ownerDocument.addEventListener('keydown', handleDocumentKeyDown);

    if (dismissOnClickOutside) {
      ownerDocument.addEventListener('click', handleDocumentClick);
    }

    return () => {
      ownerDocument.removeEventListener('keydown', handleDocumentKeyDown);
      ownerDocument.removeEventListener('click', handleDocumentClick);
    };
  }, [modalRef, dismissCallback, dismissOnClickOutside]);
} // Copied from https://github.com/facebook/react/pull/15022

function useSubscription({
  getCurrentValue,
  subscribe
}) {
  const _useState5 = Object(external_react_["useState"])({
    getCurrentValue,
    subscribe,
    value: getCurrentValue()
  }),
        _useState6 = hooks_slicedToArray(_useState5, 2),
        state = _useState6[0],
        setState = _useState6[1];

  if (state.getCurrentValue !== getCurrentValue || state.subscribe !== subscribe) {
    setState({
      getCurrentValue,
      subscribe,
      value: getCurrentValue()
    });
  }

  Object(external_react_["useEffect"])(() => {
    let didUnsubscribe = false;

    const checkForUpdates = () => {
      if (didUnsubscribe) {
        return;
      }

      setState(prevState => {
        if (prevState.getCurrentValue !== getCurrentValue || prevState.subscribe !== subscribe) {
          return prevState;
        }

        const value = getCurrentValue();

        if (prevState.value === value) {
          return prevState;
        }

        return hooks_objectSpread(hooks_objectSpread({}, prevState), {}, {
          value
        });
      });
    };

    const unsubscribe = subscribe(checkForUpdates);
    checkForUpdates();
    return () => {
      didUnsubscribe = true;
      unsubscribe();
    };
  }, [getCurrentValue, subscribe]);
  return state.value;
}
function useHighlightNativeElement() {
  const bridge = Object(external_react_["useContext"])(BridgeContext);
  const store = Object(external_react_["useContext"])(StoreContext);
  const highlightNativeElement = Object(external_react_["useCallback"])(id => {
    const element = store.getElementByID(id);
    const rendererID = store.getRendererIDForElement(id);

    if (element !== null && rendererID !== null) {
      bridge.send('highlightNativeElement', {
        displayName: element.displayName,
        hideAfterTimeout: false,
        id,
        openNativeElementsPanel: false,
        rendererID,
        scrollIntoView: false
      });
    }
  }, [store, bridge]);
  const clearHighlightNativeElement = Object(external_react_["useCallback"])(() => {
    bridge.send('clearNativeElementHighlight');
  }, [bridge]);
  return {
    highlightNativeElement,
    clearHighlightNativeElement
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Settings/SettingsContext.js
function SettingsContext_slicedToArray(arr, i) { return SettingsContext_arrayWithHoles(arr) || SettingsContext_iterableToArrayLimit(arr, i) || SettingsContext_unsupportedIterableToArray(arr, i) || SettingsContext_nonIterableRest(); }

function SettingsContext_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function SettingsContext_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return SettingsContext_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return SettingsContext_arrayLikeToArray(o, minLen); }

function SettingsContext_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function SettingsContext_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function SettingsContext_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */





const SettingsContext = /*#__PURE__*/Object(external_react_["createContext"])(null);
SettingsContext.displayName = 'SettingsContext';

function SettingsContextController({
  browserTheme,
  children,
  componentsPortalContainer,
  profilerPortalContainer
}) {
  const bridge = Object(external_react_["useContext"])(BridgeContext);

  const _useLocalStorage = useLocalStorage('React::DevTools::displayDensity', 'compact'),
        _useLocalStorage2 = SettingsContext_slicedToArray(_useLocalStorage, 2),
        displayDensity = _useLocalStorage2[0],
        setDisplayDensity = _useLocalStorage2[1];

  const _useLocalStorage3 = useLocalStorage('React::DevTools::theme', 'auto'),
        _useLocalStorage4 = SettingsContext_slicedToArray(_useLocalStorage3, 2),
        theme = _useLocalStorage4[0],
        setTheme = _useLocalStorage4[1];

  const _useLocalStorage5 = useLocalStorage(constants["f" /* LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY */], true),
        _useLocalStorage6 = SettingsContext_slicedToArray(_useLocalStorage5, 2),
        appendComponentStack = _useLocalStorage6[0],
        setAppendComponentStack = _useLocalStorage6[1];

  const _useLocalStorage7 = useLocalStorage(constants["e" /* LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS */], false),
        _useLocalStorage8 = SettingsContext_slicedToArray(_useLocalStorage7, 2),
        breakOnConsoleErrors = _useLocalStorage8[0],
        setBreakOnConsoleErrors = _useLocalStorage8[1];

  const _useLocalStorage9 = useLocalStorage(constants["g" /* LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY */], false),
        _useLocalStorage10 = SettingsContext_slicedToArray(_useLocalStorage9, 2),
        traceUpdatesEnabled = _useLocalStorage10[0],
        setTraceUpdatesEnabled = _useLocalStorage10[1];

  const documentElements = Object(external_react_["useMemo"])(() => {
    const array = [document.documentElement];

    if (componentsPortalContainer != null) {
      array.push(componentsPortalContainer.ownerDocument.documentElement);
    }

    if (profilerPortalContainer != null) {
      array.push(profilerPortalContainer.ownerDocument.documentElement);
    }

    return array;
  }, [componentsPortalContainer, profilerPortalContainer]);
  Object(external_react_["useLayoutEffect"])(() => {
    switch (displayDensity) {
      case 'comfortable':
        updateDisplayDensity('comfortable', documentElements);
        break;

      case 'compact':
        updateDisplayDensity('compact', documentElements);
        break;

      default:
        throw Error(`Unsupported displayDensity value "${displayDensity}"`);
    }
  }, [displayDensity, documentElements]);
  Object(external_react_["useLayoutEffect"])(() => {
    switch (theme) {
      case 'light':
        updateThemeVariables('light', documentElements);
        break;

      case 'dark':
        updateThemeVariables('dark', documentElements);
        break;

      case 'auto':
        updateThemeVariables(browserTheme, documentElements);
        break;

      default:
        throw Error(`Unsupported theme value "${theme}"`);
    }
  }, [browserTheme, theme, documentElements]);
  Object(external_react_["useEffect"])(() => {
    bridge.send('updateConsolePatchSettings', {
      appendComponentStack,
      breakOnConsoleErrors
    });
  }, [bridge, appendComponentStack, breakOnConsoleErrors]);
  Object(external_react_["useEffect"])(() => {
    bridge.send('setTraceUpdatesEnabled', traceUpdatesEnabled);
  }, [bridge, traceUpdatesEnabled]);
  const value = Object(external_react_["useMemo"])(() => ({
    appendComponentStack,
    breakOnConsoleErrors,
    displayDensity,
    lineHeight: displayDensity === 'compact' ? constants["c" /* COMPACT_LINE_HEIGHT */] : constants["b" /* COMFORTABLE_LINE_HEIGHT */],
    setAppendComponentStack,
    setBreakOnConsoleErrors,
    setDisplayDensity,
    setTheme,
    setTraceUpdatesEnabled,
    theme,
    traceUpdatesEnabled
  }), [appendComponentStack, breakOnConsoleErrors, displayDensity, setAppendComponentStack, setBreakOnConsoleErrors, setDisplayDensity, setTheme, setTraceUpdatesEnabled, theme, traceUpdatesEnabled]);
  return /*#__PURE__*/external_react_["createElement"](SettingsContext.Provider, {
    value: value
  }, children);
}

function setStyleVariable(name, value, documentElements) {
  documentElements.forEach(documentElement => documentElement.style.setProperty(name, value));
}

function updateStyleHelper(themeKey, style, documentElements) {
  setStyleVariable(`--${style}`, `var(--${themeKey}-${style})`, documentElements);
}

function updateDisplayDensity(displayDensity, documentElements) {
  updateStyleHelper(displayDensity, 'font-size-monospace-normal', documentElements);
  updateStyleHelper(displayDensity, 'font-size-monospace-large', documentElements);
  updateStyleHelper(displayDensity, 'font-size-monospace-small', documentElements);
  updateStyleHelper(displayDensity, 'font-size-sans-normal', documentElements);
  updateStyleHelper(displayDensity, 'font-size-sans-large', documentElements);
  updateStyleHelper(displayDensity, 'font-size-sans-small', documentElements);
  updateStyleHelper(displayDensity, 'line-height-data', documentElements); // Sizes and paddings/margins are all rem-based,
  // so update the root font-size as well when the display preference changes.

  const computedStyle = getComputedStyle(document.body);
  const fontSize = computedStyle.getPropertyValue(`--${displayDensity}-root-font-size`);
  const root = document.querySelector(':root');
  root.style.fontSize = fontSize;
}
function updateThemeVariables(theme, documentElements) {
  updateStyleHelper(theme, 'color-attribute-name', documentElements);
  updateStyleHelper(theme, 'color-attribute-name-not-editable', documentElements);
  updateStyleHelper(theme, 'color-attribute-name-inverted', documentElements);
  updateStyleHelper(theme, 'color-attribute-value', documentElements);
  updateStyleHelper(theme, 'color-attribute-value-inverted', documentElements);
  updateStyleHelper(theme, 'color-attribute-editable-value', documentElements);
  updateStyleHelper(theme, 'color-background', documentElements);
  updateStyleHelper(theme, 'color-background-hover', documentElements);
  updateStyleHelper(theme, 'color-background-inactive', documentElements);
  updateStyleHelper(theme, 'color-background-invalid', documentElements);
  updateStyleHelper(theme, 'color-background-selected', documentElements);
  updateStyleHelper(theme, 'color-border', documentElements);
  updateStyleHelper(theme, 'color-button-background', documentElements);
  updateStyleHelper(theme, 'color-button-background-focus', documentElements);
  updateStyleHelper(theme, 'color-button', documentElements);
  updateStyleHelper(theme, 'color-button-active', documentElements);
  updateStyleHelper(theme, 'color-button-disabled', documentElements);
  updateStyleHelper(theme, 'color-button-focus', documentElements);
  updateStyleHelper(theme, 'color-button-hover', documentElements);
  updateStyleHelper(theme, 'color-commit-did-not-render-fill', documentElements);
  updateStyleHelper(theme, 'color-commit-did-not-render-fill-text', documentElements);
  updateStyleHelper(theme, 'color-commit-did-not-render-pattern', documentElements);
  updateStyleHelper(theme, 'color-commit-did-not-render-pattern-text', documentElements);
  updateStyleHelper(theme, 'color-commit-gradient-0', documentElements);
  updateStyleHelper(theme, 'color-commit-gradient-1', documentElements);
  updateStyleHelper(theme, 'color-commit-gradient-2', documentElements);
  updateStyleHelper(theme, 'color-commit-gradient-3', documentElements);
  updateStyleHelper(theme, 'color-commit-gradient-4', documentElements);
  updateStyleHelper(theme, 'color-commit-gradient-5', documentElements);
  updateStyleHelper(theme, 'color-commit-gradient-6', documentElements);
  updateStyleHelper(theme, 'color-commit-gradient-7', documentElements);
  updateStyleHelper(theme, 'color-commit-gradient-8', documentElements);
  updateStyleHelper(theme, 'color-commit-gradient-9', documentElements);
  updateStyleHelper(theme, 'color-commit-gradient-text', documentElements);
  updateStyleHelper(theme, 'color-component-name', documentElements);
  updateStyleHelper(theme, 'color-component-name-inverted', documentElements);
  updateStyleHelper(theme, 'color-component-badge-background', documentElements);
  updateStyleHelper(theme, 'color-component-badge-background-inverted', documentElements);
  updateStyleHelper(theme, 'color-component-badge-count', documentElements);
  updateStyleHelper(theme, 'color-component-badge-count-inverted', documentElements);
  updateStyleHelper(theme, 'color-context-background', documentElements);
  updateStyleHelper(theme, 'color-context-background-hover', documentElements);
  updateStyleHelper(theme, 'color-context-background-selected', documentElements);
  updateStyleHelper(theme, 'color-context-border', documentElements);
  updateStyleHelper(theme, 'color-context-text', documentElements);
  updateStyleHelper(theme, 'color-context-text-selected', documentElements);
  updateStyleHelper(theme, 'color-dim', documentElements);
  updateStyleHelper(theme, 'color-dimmer', documentElements);
  updateStyleHelper(theme, 'color-dimmest', documentElements);
  updateStyleHelper(theme, 'color-error-background', documentElements);
  updateStyleHelper(theme, 'color-error-border', documentElements);
  updateStyleHelper(theme, 'color-error-text', documentElements);
  updateStyleHelper(theme, 'color-expand-collapse-toggle', documentElements);
  updateStyleHelper(theme, 'color-link', documentElements);
  updateStyleHelper(theme, 'color-modal-background', documentElements);
  updateStyleHelper(theme, 'color-record-active', documentElements);
  updateStyleHelper(theme, 'color-record-hover', documentElements);
  updateStyleHelper(theme, 'color-record-inactive', documentElements);
  updateStyleHelper(theme, 'color-color-scroll-thumb', documentElements);
  updateStyleHelper(theme, 'color-color-scroll-track', documentElements);
  updateStyleHelper(theme, 'color-search-match', documentElements);
  updateStyleHelper(theme, 'color-shadow', documentElements);
  updateStyleHelper(theme, 'color-search-match-current', documentElements);
  updateStyleHelper(theme, 'color-selected-tree-highlight-active', documentElements);
  updateStyleHelper(theme, 'color-selected-tree-highlight-inactive', documentElements);
  updateStyleHelper(theme, 'color-tab-selected-border', documentElements);
  updateStyleHelper(theme, 'color-text', documentElements);
  updateStyleHelper(theme, 'color-text-invalid', documentElements);
  updateStyleHelper(theme, 'color-text-selected', documentElements);
  updateStyleHelper(theme, 'color-toggle-background-invalid', documentElements);
  updateStyleHelper(theme, 'color-toggle-background-on', documentElements);
  updateStyleHelper(theme, 'color-toggle-background-off', documentElements);
  updateStyleHelper(theme, 'color-toggle-text', documentElements);
  updateStyleHelper(theme, 'color-tooltip-background', documentElements);
  updateStyleHelper(theme, 'color-tooltip-text', documentElements); // Font smoothing varies based on the theme.

  updateStyleHelper(theme, 'font-smoothing', documentElements); // Update scrollbar color to match theme.
  // this CSS property is currently only supported in Firefox,
  // but it makes a significant UI improvement in dark mode.
  // https://developer.mozilla.org/en-US/docs/Web/CSS/scrollbar-color

  documentElements.forEach(documentElement => {
    // $FlowFixMe scrollbarColor is missing in CSSStyleDeclaration
    documentElement.style.scrollbarColor = `var(${`--${theme}-color-scroll-thumb`}) var(${`--${theme}-color-scroll-track`})`;
  });
}

// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/Badge.css
var Badge = __webpack_require__(69);
var Badge_default = /*#__PURE__*/__webpack_require__.n(Badge);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/Badge.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



function Badge_Badge({
  className,
  hocDisplayNames,
  type,
  children
}) {
  if (hocDisplayNames === null) {
    return null;
  }

  const totalBadgeCount = hocDisplayNames.length;
  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("div", {
    className: `${Badge_default.a.Badge} ${className || ''}`
  }, children), totalBadgeCount > 1 && /*#__PURE__*/external_react_["createElement"]("div", {
    className: Badge_default.a.ExtraLabel
  }, "+", totalBadgeCount - 1));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/ButtonIcon.css
var ButtonIcon = __webpack_require__(79);
var ButtonIcon_default = /*#__PURE__*/__webpack_require__.n(ButtonIcon);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/ButtonIcon.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


function ButtonIcon_ButtonIcon({
  className = '',
  type
}) {
  let pathData = null;

  switch (type) {
    case 'add':
      pathData = PATH_ADD;
      break;

    case 'cancel':
      pathData = PATH_CANCEL;
      break;

    case 'clear':
      pathData = PATH_CLEAR;
      break;

    case 'close':
      pathData = PATH_CLOSE;
      break;

    case 'collapsed':
      pathData = PATH_COLLAPSED;
      break;

    case 'copy':
      pathData = PATH_COPY;
      break;

    case 'delete':
      pathData = PATH_DELETE;
      break;

    case 'down':
      pathData = PATH_DOWN;
      break;

    case 'expanded':
      pathData = PATH_EXPANDED;
      break;

    case 'export':
      pathData = PATH_EXPORT;
      break;

    case 'filter':
      pathData = PATH_FILTER;
      break;

    case 'import':
      pathData = PATH_IMPORT;
      break;

    case 'log-data':
      pathData = PATH_LOG_DATA;
      break;

    case 'more':
      pathData = PATH_MORE;
      break;

    case 'next':
      pathData = PATH_NEXT;
      break;

    case 'previous':
      pathData = PATH_PREVIOUS;
      break;

    case 'record':
      pathData = PATH_RECORD;
      break;

    case 'reload':
      pathData = PATH_RELOAD;
      break;

    case 'save':
      pathData = PATH_SAVE;
      break;

    case 'search':
      pathData = PATH_SEARCH;
      break;

    case 'settings':
      pathData = PATH_SETTINGS;
      break;

    case 'suspend':
      pathData = PATH_SUSPEND;
      break;

    case 'undo':
      pathData = PATH_UNDO;
      break;

    case 'up':
      pathData = PATH_UP;
      break;

    case 'view-dom':
      pathData = PATH_VIEW_DOM;
      break;

    case 'view-source':
      pathData = PATH_VIEW_SOURCE;
      break;

    default:
      console.warn(`Unsupported type "${type}" specified for ButtonIcon`);
      break;
  }

  return /*#__PURE__*/external_react_["createElement"]("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    className: `${ButtonIcon_default.a.ButtonIcon} ${className}`,
    width: "24",
    height: "24",
    viewBox: "0 0 24 24"
  }, /*#__PURE__*/external_react_["createElement"]("path", {
    d: "M0 0h24v24H0z",
    fill: "none"
  }), /*#__PURE__*/external_react_["createElement"]("path", {
    fill: "currentColor",
    d: pathData
  }));
}
const PATH_ADD = 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z';
const PATH_CANCEL = `
  M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z
`;
const PATH_CLEAR = `
  M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM4 12c0-4.42 3.58-8 8-8 1.85 0 3.55.63 4.9 1.69L5.69
  16.9C4.63 15.55 4 13.85 4 12zm8 8c-1.85 0-3.55-.63-4.9-1.69L18.31 7.1C19.37 8.45 20 10.15 20 12c0 4.42-3.58 8-8 8z
`;
const PATH_CLOSE = 'M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z';
const PATH_COLLAPSED = 'M10 17l5-5-5-5v10z';
const PATH_COPY = `
  M3 13h2v-2H3v2zm0 4h2v-2H3v2zm2 4v-2H3a2 2 0 0 0 2 2zM3 9h2V7H3v2zm12 12h2v-2h-2v2zm4-18H9a2 2 0 0 0-2
  2v10a2 2 0 0 0 2 2h10c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 12H9V5h10v10zm-8 6h2v-2h-2v2zm-4 0h2v-2H7v2z
`;
const PATH_DELETE = `
  M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12
  13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z
`;
const PATH_DOWN = 'M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z';
const PATH_EXPANDED = 'M7 10l5 5 5-5z';
const PATH_EXPORT = 'M15.82,2.14v7H21l-9,9L3,9.18H8.18v-7ZM3,20.13H21v1.73H3Z';
const PATH_FILTER = 'M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z';
const PATH_IMPORT = 'M8.18,18.13v-7H3l9-8.95,9,9H15.82v7ZM3,20.13H21v1.73H3Z';
const PATH_LOG_DATA = `
  M20 8h-2.81c-.45-.78-1.07-1.45-1.82-1.96L17 4.41 15.59 3l-2.17 2.17C12.96 5.06 12.49 5 12 5c-.49 0-.96.06-1.41.17L8.41
  3 7 4.41l1.62 1.63C7.88 6.55 7.26 7.22 6.81 8H4v2h2.09c-.05.33-.09.66-.09 1v1H4v2h2v1c0 .34.04.67.09 1H4v2h2.81c1.04
  1.79 2.97 3 5.19 3s4.15-1.21 5.19-3H20v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20V8zm-6
  8h-4v-2h4v2zm0-4h-4v-2h4v2z
`;
const PATH_MORE = `
  M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 
  2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z
`;
const PATH_NEXT = 'M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z';
const PATH_PREVIOUS = 'M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z';
const PATH_RECORD = 'M4,12a8,8 0 1,0 16,0a8,8 0 1,0 -16,0';
const PATH_RELOAD = `
  M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0
  6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0
  3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z
`;
const PATH_SAVE = `
  M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z
`;
const PATH_SEARCH = `
  M8.5,22H3.7l-1.4-1.5V3.8l1.3-1.5h17.2l1,1.5v4.9h-1.3V4.3l-0.4-0.6H4.2L3.6,4.3V20l0.7,0.7h4.2V22z
  M23,13.9l-4.6,3.6l4.6,4.6l-1.1,1.1l-4.7-4.4l-3.3,4.4l-3.2-12.3L23,13.9z
`;
const PATH_SETTINGS = `
  M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49
  1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38
  2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11
  1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4
  1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49
  1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5
  3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z
`;
const PATH_SUSPEND = `
  M15 1H9v2h6V1zm-4 13h2V8h-2v6zm8.03-6.61l1.42-1.42c-.43-.51-.9-.99-1.41-1.41l-1.42 1.42C16.07 4.74 14.12 4 12 4c-4.97
  0-9 4.03-9 9s4.02 9 9 9 9-4.03 9-9c0-2.12-.74-4.07-1.97-5.61zM12 20c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z
`;
const PATH_UNDO = `
  M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88
  3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z
`;
const PATH_UP = 'M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z';
const PATH_VIEW_DOM = `
  M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12
  17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3
  3-1.34 3-3-1.34-3-3-3z
`;
const PATH_VIEW_SOURCE = `
  M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z
  `;
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/Element.css
var Element = __webpack_require__(22);
var Element_default = /*#__PURE__*/__webpack_require__.n(Element);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/Element.js
function Element_slicedToArray(arr, i) { return Element_arrayWithHoles(arr) || Element_iterableToArrayLimit(arr, i) || Element_unsupportedIterableToArray(arr, i) || Element_nonIterableRest(); }

function Element_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function Element_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Element_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Element_arrayLikeToArray(o, minLen); }

function Element_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function Element_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function Element_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */









function ElementView({
  data,
  index,
  style
}) {
  const store = Object(external_react_["useContext"])(StoreContext);

  const _useContext = Object(external_react_["useContext"])(TreeStateContext),
        ownerFlatTree = _useContext.ownerFlatTree,
        ownerID = _useContext.ownerID,
        selectedElementID = _useContext.selectedElementID;

  const dispatch = Object(external_react_["useContext"])(TreeDispatcherContext);
  const element = ownerFlatTree !== null ? ownerFlatTree[index] : store.getElementAtIndex(index);

  const _useState = Object(external_react_["useState"])(false),
        _useState2 = Element_slicedToArray(_useState, 2),
        isHovered = _useState2[0],
        setIsHovered = _useState2[1];

  const isNavigatingWithKeyboard = data.isNavigatingWithKeyboard,
        onElementMouseEnter = data.onElementMouseEnter,
        treeFocused = data.treeFocused;
  const id = element === null ? null : element.id;
  const isSelected = selectedElementID === id;

  const handleDoubleClick = () => {
    if (id !== null) {
      dispatch({
        type: 'SELECT_OWNER',
        payload: id
      });
    }
  };

  const handleMouseDown = ({
    metaKey
  }) => {
    if (id !== null) {
      dispatch({
        type: 'SELECT_ELEMENT_BY_ID',
        payload: metaKey ? null : id
      });
    }
  };

  const handleMouseEnter = () => {
    setIsHovered(true);

    if (id !== null) {
      onElementMouseEnter(id);
    }
  };

  const handleMouseLeave = () => {
    setIsHovered(false);
  };

  const handleKeyDoubleClick = event => {
    // Double clicks on key value are used for text selection (if the text has been truncated).
    // They should not enter the owners tree view.
    event.stopPropagation();
    event.preventDefault();
  }; // Handle elements that are removed from the tree while an async render is in progress.


  if (element == null) {
    console.warn(`<ElementView> Could not find element at index ${index}`); // This return needs to happen after hooks, since hooks can't be conditional.

    return null;
  }

  const _ref = element,
        depth = _ref.depth,
        displayName = _ref.displayName,
        hocDisplayNames = _ref.hocDisplayNames,
        key = _ref.key,
        type = _ref.type;
  let className = Element_default.a.Element;

  if (isSelected) {
    className = treeFocused ? Element_default.a.SelectedElement : Element_default.a.InactiveSelectedElement;
  } else if (isHovered && !isNavigatingWithKeyboard) {
    className = Element_default.a.HoveredElement;
  }

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: className,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onMouseDown: handleMouseDown,
    onDoubleClick: handleDoubleClick,
    style: style,
    "data-depth": depth
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: Element_default.a.Wrapper,
    style: {
      // Left offset presents the appearance of a nested tree structure.
      // We must use padding rather than margin/left because of the selected background color.
      transform: `translateX(calc(${depth} * var(--indentation-size)))`
    }
  }, ownerID === null ? /*#__PURE__*/external_react_["createElement"](ExpandCollapseToggle, {
    element: element,
    store: store
  }) : null, /*#__PURE__*/external_react_["createElement"](DisplayName, {
    displayName: displayName,
    id: id
  }), key && /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, "\xA0", /*#__PURE__*/external_react_["createElement"]("span", {
    className: Element_default.a.KeyName
  }, "key"), "=\"", /*#__PURE__*/external_react_["createElement"]("span", {
    className: Element_default.a.KeyValue,
    title: key,
    onDoubleClick: handleKeyDoubleClick
  }, key), "\""), hocDisplayNames !== null && hocDisplayNames.length > 0 ? /*#__PURE__*/external_react_["createElement"](Badge_Badge, {
    className: Element_default.a.Badge,
    hocDisplayNames: hocDisplayNames,
    type: type
  }, /*#__PURE__*/external_react_["createElement"](DisplayName, {
    displayName: hocDisplayNames[0],
    id: id
  })) : null));
} // Prevent double clicks on toggle from drilling into the owner list.

const swallowDoubleClick = event => {
  event.preventDefault();
  event.stopPropagation();
};

function ExpandCollapseToggle({
  element,
  store
}) {
  const children = element.children,
        id = element.id,
        isCollapsed = element.isCollapsed;

  const toggleCollapsed = event => {
    event.preventDefault();
    event.stopPropagation();
    store.toggleIsCollapsed(id, !isCollapsed);
  };

  const stopPropagation = event => {
    // Prevent the row from selecting
    event.stopPropagation();
  };

  if (children.length === 0) {
    return /*#__PURE__*/external_react_["createElement"]("div", {
      className: Element_default.a.ExpandCollapseToggle
    });
  }

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: Element_default.a.ExpandCollapseToggle,
    onMouseDown: stopPropagation,
    onClick: toggleCollapsed,
    onDoubleClick: swallowDoubleClick
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: isCollapsed ? 'collapsed' : 'expanded'
  }));
}

function DisplayName({
  displayName,
  id
}) {
  const _useContext2 = Object(external_react_["useContext"])(TreeStateContext),
        searchIndex = _useContext2.searchIndex,
        searchResults = _useContext2.searchResults,
        searchText = _useContext2.searchText;

  const isSearchResult = Object(external_react_["useMemo"])(() => {
    return searchResults.includes(id);
  }, [id, searchResults]);
  const isCurrentResult = searchIndex !== null && id === searchResults[searchIndex];

  if (!isSearchResult || displayName === null) {
    return displayName;
  }

  const match = createRegExp(searchText).exec(displayName);

  if (match === null) {
    return displayName;
  }

  const startIndex = match.index;
  const stopIndex = startIndex + match[0].length;
  const children = [];

  if (startIndex > 0) {
    children.push( /*#__PURE__*/external_react_["createElement"]("span", {
      key: "begin"
    }, displayName.slice(0, startIndex)));
  }

  children.push( /*#__PURE__*/external_react_["createElement"]("mark", {
    key: "middle",
    className: isCurrentResult ? Element_default.a.CurrentHighlight : Element_default.a.Highlight
  }, displayName.slice(startIndex, stopIndex)));

  if (stopIndex < displayName.length) {
    children.push( /*#__PURE__*/external_react_["createElement"]("span", {
      key: "end"
    }, displayName.slice(stopIndex)));
  }

  return children;
}
// CONCATENATED MODULE: ../react-devtools-shared/node_modules/@reach/auto-id/es/index.js
 // Could use UUID but if we hit 9,007,199,254,740,991 unique components over
// the lifetime of the app before it gets reloaded, I mean ... come on.
// I don't even know what xillion that is.
// /me googles
// Oh duh, quadrillion. Nine quadrillion components. I think we're okay.

var es_id = 0;

var genId = function genId() {
  return ++es_id;
};

var es_useId = function useId() {
  var _useState = Object(external_react_["useState"])(null),
      id = _useState[0],
      setId = _useState[1];

  Object(external_react_["useEffect"])(function () {
    return setId(genId());
  }, []);
  return id;
};
// CONCATENATED MODULE: ../react-devtools-shared/node_modules/@reach/utils/es/index.js
var checkedPkgs = {};

var checkStyles = function checkStyles() {};

if (false) {}


var wrapEvent = function wrapEvent(theirHandler, ourHandler) {
  return function (event) {
    theirHandler && theirHandler(event);

    if (!event.defaultPrevented) {
      return ourHandler(event);
    }
  };
};
var assignRef = function assignRef(ref, value) {
  if (ref == null) return;

  if (typeof ref === "function") {
    ref(value);
  } else {
    try {
      ref.current = value;
    } catch (error) {
      throw new Error("Cannot assign value \"" + value + "\" to ref \"" + ref + "\"");
    }
  }
};
// EXTERNAL MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/prop-types/index.js
var prop_types = __webpack_require__(26);

// CONCATENATED MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/@reach/component-component/es/index.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _objectWithoutProperties(obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
}




var cleanProps = function cleanProps(props) {
  var initialState = props.initialState,
      getInitialState = props.getInitialState,
      refs = props.refs,
      getRefs = props.getRefs,
      didMount = props.didMount,
      didUpdate = props.didUpdate,
      willUnmount = props.willUnmount,
      getSnapshotBeforeUpdate = props.getSnapshotBeforeUpdate,
      shouldUpdate = props.shouldUpdate,
      render = props.render,
      rest = _objectWithoutProperties(props, ["initialState", "getInitialState", "refs", "getRefs", "didMount", "didUpdate", "willUnmount", "getSnapshotBeforeUpdate", "shouldUpdate", "render"]);

  return rest;
};

var es_Component = function (_React$Component) {
  _inherits(Component, _React$Component);

  function Component() {
    var _temp, _this, _ret;

    _classCallCheck(this, Component);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), _possibleConstructorReturn(_this, _ret);
  }

  Component.prototype.getArgs = function getArgs() {
    var state = this.state,
        props = this.props,
        setState = this._setState,
        forceUpdate = this._forceUpdate,
        refs = this._refs;
    return {
      state: state,
      props: cleanProps(props),
      refs: refs,
      setState: setState,
      forceUpdate: forceUpdate
    };
  };

  Component.prototype.componentDidMount = function componentDidMount() {
    if (this.props.didMount) this.props.didMount(this.getArgs());
  };

  Component.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
    if (this.props.shouldUpdate) return this.props.shouldUpdate({
      props: this.props,
      state: this.state,
      nextProps: cleanProps(nextProps),
      nextState: nextState
    });else return true;
  };

  Component.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.props.willUnmount) this.props.willUnmount({
      state: this.state,
      props: cleanProps(this.props),
      refs: this._refs
    });
  };

  Component.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState, snapshot) {
    if (this.props.didUpdate) this.props.didUpdate(Object.assign(this.getArgs(), {
      prevProps: cleanProps(prevProps),
      prevState: prevState
    }), snapshot);
  };

  Component.prototype.getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate(prevProps, prevState) {
    if (this.props.getSnapshotBeforeUpdate) {
      return this.props.getSnapshotBeforeUpdate(Object.assign(this.getArgs(), {
        prevProps: cleanProps(prevProps),
        prevState: prevState
      }));
    } else {
      return null;
    }
  };

  Component.prototype.render = function render() {
    var _props = this.props,
        children = _props.children,
        render = _props.render;
    return render ? render(this.getArgs()) : typeof children === "function" ? children(this.getArgs()) : children || null;
  };

  return Component;
}(external_react_default.a.Component);

es_Component.defaultProps = {
  getInitialState: function getInitialState() {},
  getRefs: function getRefs() {
    return {};
  }
};

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.state = this.props.initialState || this.props.getInitialState(this.props);
  this._refs = this.props.refs || this.props.getRefs(this.getArgs());

  this._setState = function () {
    return _this2.setState.apply(_this2, arguments);
  };

  this._forceUpdate = function () {
    return _this2.forceUpdate.apply(_this2, arguments);
  };
};

 false ? undefined : void 0;
/* harmony default export */ var es = (es_Component);
// CONCATENATED MODULE: ../react-devtools-shared/node_modules/@reach/portal/es/index.js




var es_Portal = function Portal(_ref) {
  var children = _ref.children,
      _ref$type = _ref.type,
      type = _ref$type === undefined ? "reach-portal" : _ref$type;
  return /*#__PURE__*/external_react_default.a.createElement(es, {
    getRefs: function getRefs() {
      return {
        mountNode: null,
        portalNode: null
      };
    },
    didMount: function didMount(_ref2) {
      var refs = _ref2.refs,
          forceUpdate = _ref2.forceUpdate; // It's possible that the content we are portal has, itself, been portaled.
      // In that case, it's important to append to the correct document element.

      var ownerDocument = refs.mountNode.ownerDocument;
      refs.portalNode = ownerDocument.createElement(type);
      ownerDocument.body.appendChild(refs.portalNode);
      forceUpdate();
    },
    willUnmount: function willUnmount(_ref3) {
      var portalNode = _ref3.refs.portalNode;
      portalNode.ownerDocument.body.removeChild(portalNode);
    },
    render: function render(_ref4) {
      var refs = _ref4.refs;
      var portalNode = refs.portalNode;

      if (!portalNode) {
        return /*#__PURE__*/external_react_default.a.createElement("div", {
          ref: function ref(div) {
            return refs.mountNode = div;
          }
        });
      } else {
        return /*#__PURE__*/Object(external_react_dom_["createPortal"])(children, portalNode);
      }
    }
  });
};

/* harmony default export */ var portal_es = (es_Portal);
// CONCATENATED MODULE: ../react-devtools-shared/node_modules/@reach/visually-hidden/es/index.js
var es_extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};


var es_style = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  width: "1px",
  margin: "-1px",
  padding: 0,
  overflow: "hidden",
  position: "absolute"
};
/* harmony default export */ var visually_hidden_es = (function (props) {
  return /*#__PURE__*/external_react_default.a.createElement("div", es_extends({
    style: es_style
  }, props));
});
// CONCATENATED MODULE: ../react-devtools-shared/node_modules/@reach/observe-rect/dist/index.m.js
var t = ["width", "height", "top", "right", "bottom", "left"],
    n = function n(_n, e) {
  return void 0 === _n && (_n = {}), void 0 === e && (e = {}), t.some(function (t) {
    return _n[t] !== e[t];
  });
};

/* harmony default export */ var index_m = (function (t, e) {
  var o,
      i,
      r = function r() {
    var u = t.getBoundingClientRect();
    n(u, o) && e(o = u), i = requestAnimationFrame(r);
  };

  return {
    observe: r,
    unobserve: function unobserve() {
      cancelAnimationFrame(i);
    }
  };
});
;
// CONCATENATED MODULE: ../react-devtools-shared/node_modules/@reach/rect/es/index.js
var rect_es_extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};






var es_render = function render(_ref) {
  var refs = _ref.refs,
      children = _ref.props.children,
      rect = _ref.state.rect;
  return children({
    ref: function ref(node) {
      return refs.node = node;
    },
    rect: rect
  });
};

var es_didMount = function didMount(_ref2) {
  var setState = _ref2.setState,
      refs = _ref2.refs,
      props = _ref2.props;

  if (!refs.node) {
    console.warn("You need to place the ref");
    return;
  }

  refs.observer = index_m(refs.node, function (rect) {
    props.onChange && props.onChange(rect);
    setState({
      rect: rect
    });
  });

  if (props.observe) {
    refs.observer.observe();
  }
};

var didUpdate = function didUpdate(_ref3) {
  var refs = _ref3.refs,
      props = _ref3.props,
      prevProps = _ref3.prevProps;

  if (props.observe && !prevProps.observe) {
    refs.observer.observe();
  } else if (!props.observe && prevProps.observe) {
    refs.observer.unobserve();
  }
};

var willUnmount = function willUnmount(_ref4) {
  var refs = _ref4.refs;
  refs.observer.unobserve();
};

var es_Rect = function Rect(props) {
  return /*#__PURE__*/external_react_default.a.createElement(es, rect_es_extends({}, props, {
    refs: {
      node: undefined,
      observer: undefined
    },
    initialState: {
      rect: undefined
    },
    didMount: es_didMount,
    didUpdate: didUpdate,
    willUnmount: willUnmount,
    render: es_render
  }));
};

 false ? undefined : void 0;
es_Rect.defaultProps = {
  observe: true
};
function useRect(nodeRef) {
  var observe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  var _useState = Object(external_react_["useState"])(null),
      rect = _useState[0],
      setRect = _useState[1];

  var observerRef = Object(external_react_["useRef"])(null);
  Object(external_react_["useLayoutEffect"])(function () {
    if (!observerRef.current) {
      observerRef.current = index_m(nodeRef.current, setRect);
    }

    if (observe) {
      observerRef.current.observe();
    }

    return function () {
      return observerRef.current.unobserve();
    };
  }, [observe]);
  return rect;
}
/* harmony default export */ var rect_es = (es_Rect);
// CONCATENATED MODULE: ../react-devtools-shared/node_modules/@reach/tooltip/es/index.js
var tooltip_es_extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var _states;

function es_objectWithoutProperties(obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
} ////////////////////////////////////////////////////////////////////////////////
// Welcome to @reach/tooltip!
//
// Quick definitions:
//
// - "on rest" or "rested on": describes when the element receives mouse hover
//   after a short delay (and hopefully soon, touch longpress).
//
// - "activation": describes a mouse click, keyboard enter, or keyboard space.
//
// Only one tooltip can be visible at a time, so we use a global state chart to
// describe the various states and transitions between states that are
// possible. With the all the timeouts involved with tooltips it's important to
// "make impossible states impossible" with a state machine.
//
// It's also okay to use these module globals because you don't server render
// tooltips. None of the state is changed outside of user events.
//
// There are a few features that are important to understand.
//
// 1. Tooltips don't show up until the user has rested on one, we don't
//    want tooltips popupping up as you move your mouse around the page.
//
// 2. Once any tooltip becomes visible, other tooltips nearby should skip
//    resting and display immediately.
//
// 3. Tooltips stick around for a little bit after blur/mouseleave.
//
// TODO: Research longpress tooltips on Android, iOS
// - Probably want to position it by default above, since your thumb
//   is below and would cover it
// - I'm thinking after longpress, display the tooltip and cancel any click
//   events. Then on touchend, so they can read it display the tooltip for
//   a little while longer in case their hand was obstructing the tooltip.

/* eslint-disable default-case */








 ////////////////////////////////////////////////////////////////////////////////
// ~The states~
// nothing goin' on

var IDLE = "idle"; // we're considering showing the tooltip, but we're gonna wait a sec

var FOCUSED = "focused"; // IT'S ON

var VISIBLE = "visible"; // Focus has left, but we want to keep it visible for a sec

var LEAVING_VISIBLE = "leavingVisible"; // The user clicked the tool, so we want to hide the thing, we can't just use
// IDLE because we need to ignore mousemove, etc.

var DISMISSED = "dismissed";
var chart = {
  initial: IDLE,
  states: (_states = {}, _states[IDLE] = {
    enter: clearContextId,
    on: {
      mouseenter: FOCUSED,
      focus: VISIBLE
    }
  }, _states[FOCUSED] = {
    enter: startRestTimer,
    leave: clearRestTimer,
    on: {
      mousemove: FOCUSED,
      mouseleave: IDLE,
      mousedown: DISMISSED,
      blur: IDLE,
      rest: VISIBLE
    }
  }, _states[VISIBLE] = {
    on: {
      focus: FOCUSED,
      mouseenter: FOCUSED,
      mouseleave: LEAVING_VISIBLE,
      blur: LEAVING_VISIBLE,
      mousedown: DISMISSED,
      selectWithKeyboard: DISMISSED,
      globalMouseMove: LEAVING_VISIBLE
    }
  }, _states[LEAVING_VISIBLE] = {
    enter: startLeavingVisibleTimer,
    leave: function leave() {
      clearLeavingVisibleTimer();
      clearContextId();
    },
    on: {
      mouseenter: VISIBLE,
      focus: VISIBLE,
      timecomplete: IDLE
    }
  }, _states[DISMISSED] = {
    leave: function leave() {
      // allows us to come on back later w/o entering something else first
      es_context.id = null;
    },
    on: {
      mouseleave: IDLE,
      blur: IDLE
    }
  }, _states)
}; // chart context allows us to persist some data around, in Tooltip all we use
// is the id of the current tooltip being interacted with.

var es_context = {
  id: null
};
var es_state = chart.initial; ////////////////////////////////////////////////////////////////////////////////
// Finds the next state from the current state + action. If the chart doesn't
// describe that transition, it will throw.
//
// It also manages lifecycles of the machine, (enter/leave hooks on the state
// chart)

function transition(action, newContext) {
  var stateDef = chart.states[es_state];
  var nextState = stateDef.on[action]; // Really useful for debugging
  // console.log({ action, state, nextState, contextId: context.id });

  if (!nextState) {
    throw new Error("Unknown state for action \"" + action + "\" from state \"" + es_state + "\"");
  }

  if (stateDef.leave) {
    stateDef.leave();
  }

  if (newContext) {
    es_context = newContext;
  }

  var nextDef = chart.states[nextState];

  if (nextDef.enter) {
    nextDef.enter();
  }

  es_state = nextState;
  notify();
} ////////////////////////////////////////////////////////////////////////////////
// Subscriptions:
//
// We could require apps to render a <TooltipProvider> around the app and use
// React context to notify Tooltips of changes to our state machine, instead
// we manage subscriptions ourselves and simplify the Tooltip API.
//
// Maybe if default context could take a hook (instead of just a static value)
// that was rendered at the root for us, that'd be cool! But it doesn't.


var subscriptions = [];

function es_subscribe(fn) {
  subscriptions.push(fn);
  return function () {
    subscriptions.splice(subscriptions.indexOf(fn), 1);
  };
}

function notify() {
  subscriptions.forEach(function (fn) {
    return fn(es_state, es_context);
  });
} ////////////////////////////////////////////////////////////////////////////////
// Timeouts:
// Manages when the user "rests" on an element. Keeps the interface from being
// flashing tooltips all the time as the user moves the mouse around the screen.


var restTimeout = void 0;

function startRestTimer() {
  clearTimeout(restTimeout);
  restTimeout = setTimeout(function () {
    return transition("rest");
  }, 100);
}

function clearRestTimer() {
  clearTimeout(restTimeout);
} // Manages the delay to hide the tooltip after rest leaves.


var leavingVisibleTimer = void 0;

function startLeavingVisibleTimer() {
  clearTimeout(leavingVisibleTimer);
  leavingVisibleTimer = setTimeout(function () {
    return transition("timecomplete");
  }, 500);
}

function clearLeavingVisibleTimer() {
  clearTimeout(leavingVisibleTimer);
} // allows us to come on back later w/o entering something else first after the
// user leaves or dismisses


function clearContextId() {
  es_context.id = null;
} ////////////////////////////////////////////////////////////////////////////////
// THE HOOK! It's about time we got to the goods!


function useTooltip() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      onMouseEnter = _ref.onMouseEnter,
      onMouseMove = _ref.onMouseMove,
      onMouseLeave = _ref.onMouseLeave,
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur,
      onKeyDown = _ref.onKeyDown,
      onMouseDown = _ref.onMouseDown,
      ref = _ref.ref,
      DEBUG_STYLE = _ref.DEBUG_STYLE;

  var id = "tooltip:" + es_useId();

  var _useState = Object(external_react_["useState"])(DEBUG_STYLE ? true : es_context.id === id && es_state === VISIBLE),
      isVisible = _useState[0],
      setIsVisible = _useState[1]; // hopefully they always pass a ref if they ever pass one


  var triggerRef = ref || Object(external_react_["useRef"])();
  var triggerRect = useRect(triggerRef, isVisible);
  Object(external_react_["useEffect"])(function () {
    return es_subscribe(function () {
      if (es_context.id === id && (es_state === VISIBLE || es_state === LEAVING_VISIBLE)) {
        setIsVisible(true);
      } else {
        setIsVisible(false);
      }
    });
  }, [id]);
  Object(external_react_["useEffect"])(function () {
    return checkStyles("tooltip");
  });

  var handleMouseEnter = function handleMouseEnter() {
    switch (es_state) {
      case IDLE:
      case VISIBLE:
      case LEAVING_VISIBLE:
        {
          transition("mouseenter", {
            id: id
          });
        }
    }
  };

  var handleMouseMove = function handleMouseMove() {
    switch (es_state) {
      case FOCUSED:
        {
          transition("mousemove", {
            id: id
          });
        }
    }
  };

  var handleFocus = function handleFocus(event) {
    if (window.__REACH_DISABLE_TOOLTIPS) return;

    switch (es_state) {
      case IDLE:
      case VISIBLE:
      case LEAVING_VISIBLE:
        {
          transition("focus", {
            id: id
          });
        }
    }
  };

  var handleMouseLeave = function handleMouseLeave() {
    switch (es_state) {
      case FOCUSED:
      case VISIBLE:
      case DISMISSED:
        {
          transition("mouseleave");
        }
    }
  };

  var handleBlur = function handleBlur() {
    // Allow quick click from one tool to another
    if (es_context.id !== id) return;

    switch (es_state) {
      case FOCUSED:
      case VISIBLE:
      case DISMISSED:
        {
          transition("blur");
        }
    }
  };

  var handleMouseDown = function handleMouseDown() {
    // Allow quick click from one tool to another
    if (es_context.id !== id) return;

    switch (es_state) {
      case FOCUSED:
      case VISIBLE:
        {
          transition("mousedown");
        }
    }
  };

  var handleKeyDown = function handleKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      switch (es_state) {
        case VISIBLE:
          {
            transition("selectWithKeyboard");
          }
      }
    }
  };

  var trigger = {
    "aria-describedby": id,
    "data-reach-tooltip-trigger": "",
    ref: triggerRef,
    onMouseEnter: wrapEvent(onMouseEnter, handleMouseEnter),
    onMouseMove: wrapEvent(onMouseMove, handleMouseMove),
    onFocus: wrapEvent(onFocus, handleFocus),
    onBlur: wrapEvent(onFocus, handleBlur),
    onMouseLeave: wrapEvent(onMouseLeave, handleMouseLeave),
    onKeyDown: wrapEvent(onKeyDown, handleKeyDown),
    onMouseDown: wrapEvent(onMouseDown, handleMouseDown)
  };
  var tooltip = {
    id: id,
    triggerRect: triggerRect,
    isVisible: isVisible
  };
  return [trigger, tooltip, isVisible];
} ////////////////////////////////////////////////////////////////////////////////

function Tooltip(_ref2) {
  var children = _ref2.children,
      label = _ref2.label,
      ariaLabel = _ref2.ariaLabel,
      DEBUG_STYLE = _ref2.DEBUG_STYLE,
      rest = es_objectWithoutProperties(_ref2, ["children", "label", "ariaLabel", "DEBUG_STYLE"]);

  var _useTooltip = useTooltip({
    DEBUG_STYLE: DEBUG_STYLE
  }),
      trigger = _useTooltip[0],
      tooltip = _useTooltip[1];

  return /*#__PURE__*/external_react_default.a.createElement(external_react_["Fragment"], null, /*#__PURE__*/Object(external_react_["cloneElement"])(external_react_["Children"].only(children), trigger), /*#__PURE__*/external_react_default.a.createElement(es_TooltipPopup, tooltip_es_extends({
    label: label,
    ariaLabel: ariaLabel
  }, tooltip, rest)));
}
 false ? undefined : void 0; ////////////////////////////////////////////////////////////////////////////////

var es_TooltipPopup = /*#__PURE__*/Object(external_react_["forwardRef"])(function TooltipPopup(_ref3, forwardRef) {
  var label = _ref3.label,
      ariaLabel = _ref3.ariaLabel,
      position = _ref3.position,
      isVisible = _ref3.isVisible,
      id = _ref3.id,
      triggerRect = _ref3.triggerRect,
      rest = es_objectWithoutProperties(_ref3, ["label", "ariaLabel", "position", "isVisible", "id", "triggerRect"]);

  return isVisible ? /*#__PURE__*/external_react_default.a.createElement(portal_es, null, /*#__PURE__*/external_react_default.a.createElement(es_TooltipContent, tooltip_es_extends({
    label: label,
    ariaLabel: ariaLabel,
    position: position,
    isVisible: isVisible,
    id: id,
    triggerRect: triggerRect,
    ref: forwardRef
  }, rest))) : null;
});

 false ? undefined : void 0; // Need a separate component so that useRect works inside the portal

var es_TooltipContent = /*#__PURE__*/Object(external_react_["forwardRef"])(function TooltipContent(_ref4, forwardRef) {
  var label = _ref4.label,
      ariaLabel = _ref4.ariaLabel,
      _ref4$position = _ref4.position,
      position = _ref4$position === undefined ? positionDefault : _ref4$position,
      isVisible = _ref4.isVisible,
      id = _ref4.id,
      triggerRect = _ref4.triggerRect,
      style = _ref4.style,
      rest = es_objectWithoutProperties(_ref4, ["label", "ariaLabel", "position", "isVisible", "id", "triggerRect", "style"]);

  var useAriaLabel = ariaLabel != null;
  var tooltipRef = Object(external_react_["useRef"])();
  var tooltipRect = useRect(tooltipRef, isVisible);
  return /*#__PURE__*/external_react_default.a.createElement(external_react_["Fragment"], null, /*#__PURE__*/external_react_default.a.createElement("div", tooltip_es_extends({
    "data-reach-tooltip": true,
    role: useAriaLabel ? undefined : "tooltip",
    id: useAriaLabel ? undefined : id,
    children: label,
    style: tooltip_es_extends({}, style, getStyles(position, triggerRect, tooltipRect)),
    ref: function ref(node) {
      tooltipRef.current = node;
      if (forwardRef) forwardRef(node);
    }
  }, rest)), useAriaLabel && /*#__PURE__*/external_react_default.a.createElement(visually_hidden_es, {
    role: "tooltip",
    id: id
  }, ariaLabel));
}); // feels awkward when it's perfectly aligned w/ the trigger

var OFFSET = 8;

var getStyles = function getStyles(position, triggerRect, tooltipRect) {
  var haventMeasuredTooltipYet = !tooltipRect;

  if (haventMeasuredTooltipYet) {
    return {
      visibility: "hidden"
    };
  }

  return position(triggerRect, tooltipRect);
};

var positionDefault = function positionDefault(triggerRect, tooltipRect) {
  var styles = {
    left: triggerRect.left + window.pageXOffset + "px",
    top: triggerRect.top + triggerRect.height + window.pageYOffset + "px"
  };
  var collisions = {
    top: triggerRect.top - tooltipRect.height < 0,
    right: window.innerWidth < triggerRect.left + tooltipRect.width,
    bottom: window.innerHeight < triggerRect.bottom + tooltipRect.height + OFFSET,
    left: triggerRect.left - tooltipRect.width < 0
  };
  var directionRight = collisions.right && !collisions.left;
  var directionUp = collisions.bottom && !collisions.top;
  return tooltip_es_extends({}, styles, {
    left: directionRight ? triggerRect.right - tooltipRect.width + window.pageXOffset + "px" : triggerRect.left + window.pageXOffset + "px",
    top: directionUp ? triggerRect.top - OFFSET - tooltipRect.height + window.pageYOffset + "px" : triggerRect.top + OFFSET + triggerRect.height + window.pageYOffset + "px"
  });
};
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Toggle.css
var Toggle = __webpack_require__(51);
var Toggle_default = /*#__PURE__*/__webpack_require__.n(Toggle);

// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Tooltip.css
var views_Tooltip = __webpack_require__(41);
var Tooltip_default = /*#__PURE__*/__webpack_require__.n(views_Tooltip);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Toggle.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */





function Toggle_Toggle({
  children,
  className = '',
  isDisabled = false,
  isChecked,
  onChange,
  title
}) {
  let defaultClassName;

  if (isDisabled) {
    defaultClassName = Toggle_default.a.ToggleDisabled;
  } else if (isChecked) {
    defaultClassName = Toggle_default.a.ToggleOn;
  } else {
    defaultClassName = Toggle_default.a.ToggleOff;
  }

  const handleClick = Object(external_react_["useCallback"])(() => onChange(!isChecked), [isChecked, onChange]);
  let toggle = /*#__PURE__*/external_react_["createElement"]("button", {
    className: `${defaultClassName} ${className}`,
    disabled: isDisabled,
    onClick: handleClick
  }, /*#__PURE__*/external_react_["createElement"]("span", {
    className: Toggle_default.a.ToggleContent,
    tabIndex: -1
  }, children));

  if (title) {
    toggle = /*#__PURE__*/external_react_["createElement"](Tooltip, {
      className: Tooltip_default.a.Tooltip,
      label: title
    }, toggle);
  }

  return toggle;
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/InspectHostNodesToggle.js
function InspectHostNodesToggle_slicedToArray(arr, i) { return InspectHostNodesToggle_arrayWithHoles(arr) || InspectHostNodesToggle_iterableToArrayLimit(arr, i) || InspectHostNodesToggle_unsupportedIterableToArray(arr, i) || InspectHostNodesToggle_nonIterableRest(); }

function InspectHostNodesToggle_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function InspectHostNodesToggle_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return InspectHostNodesToggle_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return InspectHostNodesToggle_arrayLikeToArray(o, minLen); }

function InspectHostNodesToggle_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function InspectHostNodesToggle_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function InspectHostNodesToggle_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */





function InspectHostNodesToggle() {
  const _useState = Object(external_react_["useState"])(false),
        _useState2 = InspectHostNodesToggle_slicedToArray(_useState, 2),
        isInspecting = _useState2[0],
        setIsInspecting = _useState2[1];

  const bridge = Object(external_react_["useContext"])(BridgeContext);
  const handleChange = Object(external_react_["useCallback"])(isChecked => {
    setIsInspecting(isChecked);

    if (isChecked) {
      bridge.send('startInspectingNative');
    } else {
      bridge.send('stopInspectingNative', false);
    }
  }, [bridge]);
  Object(external_react_["useEffect"])(() => {
    const onStopInspectingNative = () => setIsInspecting(false);

    bridge.addListener('stopInspectingNative', onStopInspectingNative);
    return () => bridge.removeListener('stopInspectingNative', onStopInspectingNative);
  }, [bridge]);
  return /*#__PURE__*/external_react_["createElement"](Toggle_Toggle, {
    onChange: handleChange,
    isChecked: isInspecting,
    title: "Select an element in the page to inspect it"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "search"
  }));
}
// CONCATENATED MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/@reach/menu-button/node_modules/@reach/portal/es/index.js




var portal_es_Portal = function Portal(_ref) {
  var children = _ref.children,
      _ref$type = _ref.type,
      type = _ref$type === undefined ? "reach-portal" : _ref$type;
  return /*#__PURE__*/external_react_default.a.createElement(es, {
    getRefs: function getRefs() {
      return {
        mountNode: null,
        portalNode: null
      };
    },
    didMount: function didMount(_ref2) {
      var refs = _ref2.refs,
          forceUpdate = _ref2.forceUpdate; // It's possible that the content we are portal has, itself, been portaled.
      // In that case, it's important to append to the correct document element.

      var ownerDocument = refs.mountNode.ownerDocument;
      refs.portalNode = ownerDocument.createElement(type);
      ownerDocument.body.appendChild(refs.portalNode);
      forceUpdate();
    },
    willUnmount: function willUnmount(_ref3) {
      var portalNode = _ref3.refs.portalNode;
      portalNode.ownerDocument.body.removeChild(portalNode);
    },
    render: function render(_ref4) {
      var refs = _ref4.refs;
      var portalNode = refs.portalNode;

      if (!portalNode) {
        return /*#__PURE__*/external_react_default.a.createElement("div", {
          ref: function ref(div) {
            return refs.mountNode = div;
          }
        });
      } else {
        return /*#__PURE__*/Object(external_react_dom_["createPortal"])(children, portalNode);
      }
    }
  });
};

/* harmony default export */ var _reach_portal_es = (portal_es_Portal);
// CONCATENATED MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/@reach/menu-button/node_modules/@reach/observe-rect/dist/index.m.js
var index_m_t = ["width", "height", "top", "right", "bottom", "left"],
    index_m_n = function n(_n, e) {
  return void 0 === _n && (_n = {}), void 0 === e && (e = {}), index_m_t.some(function (t) {
    return _n[t] !== e[t];
  });
};

/* harmony default export */ var dist_index_m = (function (t, e) {
  var o,
      i,
      r = function r() {
    var u = t.getBoundingClientRect();
    index_m_n(u, o) && e(o = u), i = requestAnimationFrame(r);
  };

  return {
    observe: r,
    unobserve: function unobserve() {
      cancelAnimationFrame(i);
    }
  };
});
;
// CONCATENATED MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/@reach/menu-button/node_modules/@reach/rect/es/index.js
var _reach_rect_es_extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};






var rect_es_render = function render(_ref) {
  var refs = _ref.refs,
      children = _ref.props.children,
      rect = _ref.state.rect;
  return children({
    ref: function ref(node) {
      return refs.node = node;
    },
    rect: rect
  });
};

var rect_es_didMount = function didMount(_ref2) {
  var setState = _ref2.setState,
      refs = _ref2.refs,
      props = _ref2.props;

  if (!refs.node) {
    console.warn("You need to place the ref");
    return;
  }

  refs.observer = dist_index_m(refs.node, function (rect) {
    props.onChange && props.onChange(rect);
    setState({
      rect: rect
    });
  });

  if (props.observe) {
    refs.observer.observe();
  }
};

var es_didUpdate = function didUpdate(_ref3) {
  var refs = _ref3.refs,
      props = _ref3.props,
      prevProps = _ref3.prevProps;

  if (props.observe && !prevProps.observe) {
    refs.observer.observe();
  } else if (!props.observe && prevProps.observe) {
    refs.observer.unobserve();
  }
};

var es_willUnmount = function willUnmount(_ref4) {
  var refs = _ref4.refs;
  refs.observer.unobserve();
};

var rect_es_Rect = function Rect(props) {
  return /*#__PURE__*/external_react_default.a.createElement(es, _reach_rect_es_extends({}, props, {
    refs: {
      node: undefined,
      observer: undefined
    },
    initialState: {
      rect: undefined
    },
    didMount: rect_es_didMount,
    didUpdate: es_didUpdate,
    willUnmount: es_willUnmount,
    render: rect_es_render
  }));
};

 false ? undefined : void 0;
rect_es_Rect.defaultProps = {
  observe: true
};
function es_useRect(nodeRef) {
  var observe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  var _useState = Object(external_react_["useState"])(null),
      rect = _useState[0],
      setRect = _useState[1];

  var observerRef = Object(external_react_["useRef"])(null);
  Object(external_react_["useLayoutEffect"])(function () {
    if (!observerRef.current) {
      observerRef.current = dist_index_m(nodeRef.current, setRect);
    }

    if (observe) {
      observerRef.current.observe();
    }

    return function () {
      return observerRef.current.unobserve();
    };
  }, [observe]);
  return rect;
}
/* harmony default export */ var _reach_rect_es = (rect_es_Rect);
// CONCATENATED MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/@reach/window-size/es/index.js



var hasWindow = typeof window !== "undefined";

var window_size_es_didMount = function didMount(_ref) {
  var refs = _ref.refs,
      setState = _ref.setState;

  var resize = function resize() {
    return setState({
      width: window.innerWidth,
      height: window.innerHeight
    });
  };

  window.addEventListener("resize", resize);

  refs.removeEvent = function () {
    window.removeEventListener("resize", resize);
  };
};

var window_size_es_willUnmount = function willUnmount(_ref2) {
  var refs = _ref2.refs;
  refs.removeEvent();
};

var es_WindowSize = function WindowSize(_ref3) {
  var children = _ref3.children;
  return /*#__PURE__*/external_react_default.a.createElement(es, {
    refs: {
      removeEvent: null
    },
    initialState: {
      width: hasWindow && window.innerWidth,
      height: hasWindow && window.innerHeight
    },
    didMount: window_size_es_didMount,
    willUnmount: window_size_es_willUnmount,
    render: function render(_ref4) {
      var state = _ref4.state;
      return children(state);
    }
  });
};

 false ? undefined : void 0;
/* harmony default export */ var window_size_es = (es_WindowSize);
// CONCATENATED MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/@reach/menu-button/node_modules/@reach/utils/es/index.js
var es_checkedPkgs = {};

var es_checkStyles = function checkStyles() {};

if (false) {}


var es_wrapEvent = function wrapEvent(theirHandler, ourHandler) {
  return function (event) {
    theirHandler && theirHandler(event);

    if (!event.defaultPrevented) {
      return ourHandler(event);
    }
  };
};
var es_assignRef = function assignRef(ref, value) {
  if (ref == null) return;

  if (typeof ref === "function") {
    ref(value);
  } else {
    try {
      ref.current = value;
    } catch (error) {
      throw new Error("Cannot assign value \"" + value + "\" to ref \"" + ref + "\"");
    }
  }
};
// CONCATENATED MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/@reach/menu-button/es/index.js
var menu_button_es_extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

function menu_button_es_objectWithoutProperties(obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
}







 // TODO: add the mousedown/drag/mouseup to select of native menus, will
// also help w/ remove the menu button tooltip hide-flash.
// TODO: add type-to-highlight like native menus

var _createContext = /*#__PURE__*/Object(external_react_["createContext"])(),
    Provider = _createContext.Provider,
    Consumer = _createContext.Consumer;

var checkIfAppManagedFocus = function checkIfAppManagedFocus(_ref) {
  var refs = _ref.refs,
      state = _ref.state,
      prevState = _ref.prevState;

  if (!state.isOpen && prevState.isOpen) {
    return !refs.menu.contains(document.activeElement);
  }

  return false;
};

var manageFocusOnUpdate = function manageFocusOnUpdate(_ref2, appManagedFocus) {
  var refs = _ref2.refs,
      state = _ref2.state,
      prevState = _ref2.prevState;

  if (state.isOpen && !prevState.isOpen) {
    window.__REACH_DISABLE_TOOLTIPS = true;

    if (state.selectionIndex !== -1) {
      // haven't measured the popover yet, give it a frame otherwise
      // we'll scroll to the bottom of the page >.<
      requestAnimationFrame(function () {
        refs.items[state.selectionIndex].focus();
      });
    } else {
      refs.menu.focus();
    }
  } else if (!state.isOpen && prevState.isOpen) {
    if (!appManagedFocus) {
      refs.button.focus();
    } // we want to ignore the immediate focus of a tooltip so it doesn't pop
    // up again when the menu closes, only pops up when focus returns again
    // to the tooltip (like native OS tooltips)


    window.__REACH_DISABLE_TOOLTIPS = false;
  } else if (state.selectionIndex !== prevState.selectionIndex) {
    if (state.selectionIndex === -1) {
      // clear highlight when mousing over non-menu items, but focus the menu
      // so the the keyboard will work after a mouseover
      refs.menu.focus();
    } else {
      refs.items[state.selectionIndex].focus();
    }
  }
};

var openAtFirstItem = function openAtFirstItem(state) {
  return {
    isOpen: true,
    selectionIndex: 0
  };
};

var es_close = function close(state) {
  return {
    isOpen: false,
    selectionIndex: -1,
    closingWithClick: false
  };
};

var selectItemAtIndex = function selectItemAtIndex(index) {
  return function (state) {
    return {
      selectionIndex: index
    };
  };
};

var es_genId = function genId(prefix) {
  return prefix + "-" + Math.random().toString(32).substr(2, 8);
}; ////////////////////////////////////////////////////////////////////////


var getMenuRefs = function getMenuRefs() {
  return {
    button: null,
    menu: null,
    items: []
  };
};

var getInitialMenuState = function getInitialMenuState() {
  return {
    isOpen: false,
    buttonRect: undefined,
    selectionIndex: -1,
    closingWithClick: false,
    buttonId: es_genId("button")
  };
};

var es_checkIfStylesIncluded = function checkIfStylesIncluded() {
  return es_checkStyles("menu-button");
};

var es_Menu = function Menu(_ref3) {
  var children = _ref3.children;
  return /*#__PURE__*/external_react_default.a.createElement(es, {
    getRefs: getMenuRefs,
    getInitialState: getInitialMenuState,
    didMount: es_checkIfStylesIncluded,
    didUpdate: manageFocusOnUpdate,
    getSnapshotBeforeUpdate: checkIfAppManagedFocus
  }, function (context) {
    return /*#__PURE__*/external_react_default.a.createElement(Provider, {
      value: context
    }, typeof children === "function" ? children({
      isOpen: context.state.isOpen
    }) : children);
  });
};

 false ? undefined : void 0; ////////////////////////////////////////////////////////////////////////

var MenuButton = /*#__PURE__*/external_react_default.a.forwardRef(function (_ref4, _ref7) {
  var onClick = _ref4.onClick,
      onKeyDown = _ref4.onKeyDown,
      onMouseDown = _ref4.onMouseDown,
      props = menu_button_es_objectWithoutProperties(_ref4, ["onClick", "onKeyDown", "onMouseDown"]);

  return /*#__PURE__*/external_react_default.a.createElement(Consumer, null, function (_ref5) {
    var refs = _ref5.refs,
        state = _ref5.state,
        setState = _ref5.setState;
    return /*#__PURE__*/external_react_default.a.createElement(_reach_rect_es, {
      observe: state.isOpen,
      onChange: function onChange(buttonRect) {
        return setState({
          buttonRect: buttonRect
        });
      }
    }, function (_ref6) {
      var rectRef = _ref6.ref;
      return /*#__PURE__*/external_react_default.a.createElement("button", menu_button_es_extends({
        id: state.buttonId,
        "aria-haspopup": "menu",
        "aria-expanded": state.isOpen,
        "data-reach-menu-button": true,
        type: "button",
        ref: function ref(node) {
          rectRef(node);
          es_assignRef(_ref7, node);
          refs.button = node;
        },
        onMouseDown: es_wrapEvent(onMouseDown, function () {
          if (state.isOpen) {
            setState({
              closingWithClick: true
            });
          }
        }),
        onClick: es_wrapEvent(onClick, function () {
          if (state.isOpen) {
            setState(es_close);
          } else {
            setState(openAtFirstItem);
          }
        }),
        onKeyDown: es_wrapEvent(onKeyDown, function (event) {
          if (event.key === "ArrowDown") {
            event.preventDefault(); // prevent scroll

            setState(openAtFirstItem);
          } else if (event.key === "ArrowUp") {
            event.preventDefault(); // prevent scroll

            setState(openAtFirstItem);
          }
        })
      }, props));
    });
  });
});
MenuButton.propTypes = {
  onClick: prop_types["func"],
  onKeyDown: prop_types["func"],
  children: prop_types["node"]
};
var MenuItem = /*#__PURE__*/external_react_default.a.forwardRef(function (_ref8, _ref9) {
  var onSelect = _ref8.onSelect,
      onClick = _ref8.onClick,
      _ref8$role = _ref8.role,
      role = _ref8$role === undefined ? "menuitem" : _ref8$role,
      state = _ref8.state,
      setState = _ref8.setState,
      index = _ref8.index,
      onKeyDown = _ref8.onKeyDown,
      onMouseMove = _ref8.onMouseMove,
      onMouseLeave = _ref8.onMouseLeave,
      _ref = _ref8._ref,
      rest = menu_button_es_objectWithoutProperties(_ref8, ["onSelect", "onClick", "role", "state", "setState", "index", "onKeyDown", "onMouseMove", "onMouseLeave", "_ref"]);

  var isSelected = index === state.selectionIndex;

  var select = function select() {
    onSelect();
    setState(es_close);
  };

  return /*#__PURE__*/external_react_default.a.createElement("div", menu_button_es_extends({}, rest, {
    ref: function ref(node) {
      es_assignRef(_ref9, node);
      es_assignRef(_ref, node);
    },
    "data-reach-menu-item": role === "menuitem" ? true : undefined,
    role: role,
    tabIndex: "-1",
    "data-selected": role === "menuitem" && isSelected ? true : undefined,
    onClick: es_wrapEvent(onClick, function (event) {
      select();
    }),
    onKeyDown: es_wrapEvent(onKeyDown, function (event) {
      if (event.key === "Enter") {
        // prevent the button from being "clicked" by
        // this "Enter" keydown
        event.preventDefault();
        select();
      }
    }),
    onMouseMove: es_wrapEvent(onMouseMove, function (event) {
      if (!isSelected) {
        setState(selectItemAtIndex(index));
      }
    }),
    onMouseLeave: es_wrapEvent(onMouseLeave, function (event) {
      // clear out selection when mouse over a non-menu item child
      setState({
        selectionIndex: -1
      });
    })
  }));
});
 false ? undefined : void 0;

var k = function k() {}; ////////////////////////////////////////////////////////////////////////


var MenuLink = /*#__PURE__*/external_react_default.a.forwardRef(function (_ref10, _ref11) {
  var onKeyDown = _ref10.onKeyDown,
      onClick = _ref10.onClick,
      Comp = _ref10.component,
      _ref10$as = _ref10.as,
      AsComp = _ref10$as === undefined ? "a" : _ref10$as,
      style = _ref10.style,
      setState = _ref10.setState,
      state = _ref10.state,
      index = _ref10.index,
      _ref = _ref10._ref,
      props = menu_button_es_objectWithoutProperties(_ref10, ["onKeyDown", "onClick", "component", "as", "style", "setState", "state", "index", "_ref"]);

  var Link = Comp || AsComp;

  if (Comp) {
    console.warn("[@reach/menu-button]: Please use the `as` prop instead of `component`.");
  }

  return /*#__PURE__*/external_react_default.a.createElement(MenuItem, {
    role: "none",
    state: state,
    setState: setState,
    index: index,
    onSelect: k,
    _ref: k
  }, /*#__PURE__*/external_react_default.a.createElement(Link, menu_button_es_extends({
    role: "menuitem",
    "data-reach-menu-item": true,
    tabIndex: "-1",
    "data-selected": index === state.selectionIndex ? true : undefined,
    onClick: es_wrapEvent(onClick, function (event) {
      setState(es_close);
    }),
    onKeyDown: es_wrapEvent(onKeyDown, function (event) {
      if (event.key === "Enter") {
        // prevent MenuItem's preventDefault from firing,
        // allowing this link to work w/ the keyboard
        event.stopPropagation();
      }
    }),
    ref: function ref(node) {
      es_assignRef(_ref, node);
      es_assignRef(_ref11, node);
    },
    style: menu_button_es_extends({}, style)
  }, props)));
});
 false ? undefined : void 0; ///////////////////////////////////////////////////////////////////

var MenuList = /*#__PURE__*/external_react_default.a.forwardRef(function (props, ref) {
  return /*#__PURE__*/external_react_default.a.createElement(Consumer, null, function (_ref12) {
    var refs = _ref12.refs,
        state = _ref12.state,
        setState = _ref12.setState;
    return state.isOpen && /*#__PURE__*/external_react_default.a.createElement(_reach_portal_es, null, /*#__PURE__*/external_react_default.a.createElement(window_size_es, null, function () {
      return /*#__PURE__*/external_react_default.a.createElement(_reach_rect_es, null, function (_ref13) {
        var menuRect = _ref13.rect,
            menuRef = _ref13.ref;
        return /*#__PURE__*/external_react_default.a.createElement("div", {
          "data-reach-menu": true,
          ref: menuRef,
          style: es_getStyles(state.buttonRect, menuRect)
        }, /*#__PURE__*/external_react_default.a.createElement(MenuListImpl, menu_button_es_extends({}, props, {
          setState: setState,
          state: state,
          refs: refs,
          ref: ref
        })));
      });
    }));
  });
});
MenuList.propTypes = {
  children: prop_types["node"]
};
var focusableChildrenTypes = [MenuItem, MenuLink];

var isFocusableChildType = function isFocusableChildType(child) {
  return focusableChildrenTypes.includes(child.type);
};

var es_getFocusableMenuChildren = function getFocusableMenuChildren(children) {
  var focusable = [];
  external_react_["Children"].forEach(children, function (child) {
    if (isFocusableChildType(child)) focusable.push(child);
  });
  return focusable;
};

var MenuListImpl = /*#__PURE__*/external_react_default.a.forwardRef(function (_ref14, _ref15) {
  var refs = _ref14.refs,
      state = _ref14.state,
      setState = _ref14.setState,
      children = _ref14.children,
      onKeyDown = _ref14.onKeyDown,
      onBlur = _ref14.onBlur,
      rest = menu_button_es_objectWithoutProperties(_ref14, ["refs", "state", "setState", "children", "onKeyDown", "onBlur"]);

  var focusableChildren = es_getFocusableMenuChildren(children);
  return /*#__PURE__*/external_react_default.a.createElement("div", menu_button_es_extends({
    "data-reach-menu-list": true
  }, rest, {
    role: "menu",
    "aria-labelledby": state.buttonId,
    tabIndex: "-1",
    ref: function ref(node) {
      refs.menu = node;
      es_assignRef(_ref15, node);
    },
    onBlur: function onBlur(event) {
      if (!state.closingWithClick && !refs.menu.contains(event.relatedTarget)) {
        setState(es_close);
      }
    },
    onKeyDown: es_wrapEvent(onKeyDown, function (event) {
      if (event.key === "Escape") {
        setState(es_close);
      } else if (event.key === "ArrowDown") {
        event.preventDefault(); // prevent window scroll

        var nextIndex = state.selectionIndex + 1;

        if (nextIndex !== focusableChildren.length) {
          setState({
            selectionIndex: nextIndex
          });
        }
      } else if (event.key === "ArrowUp") {
        event.preventDefault(); // prevent window scroll

        var _nextIndex = state.selectionIndex - 1;

        if (_nextIndex !== -1) {
          setState({
            selectionIndex: _nextIndex
          });
        }
      } else if (event.key === "Tab") {
        event.preventDefault(); // prevent leaving
      }
    })
  }), external_react_["Children"].map(children, function (child, index) {
    if (isFocusableChildType(child)) {
      var focusIndex = focusableChildren.indexOf(child);
      return /*#__PURE__*/external_react_default.a.cloneElement(child, {
        setState: setState,
        state: state,
        index: focusIndex,
        _ref: function _ref(node) {
          return refs.items[focusIndex] = node;
        }
      });
    }

    return child;
  }));
});
 false ? undefined : void 0;

var es_getStyles = function getStyles(buttonRect, menuRect) {
  var haventMeasuredButtonYet = !buttonRect;

  if (haventMeasuredButtonYet) {
    return {
      opacity: 0
    };
  }

  var haventMeasuredMenuYet = !menuRect;
  var styles = {
    left: buttonRect.left + window.pageXOffset + "px",
    top: buttonRect.top + buttonRect.height + window.pageYOffset + "px"
  };

  if (haventMeasuredMenuYet) {
    return menu_button_es_extends({}, styles, {
      opacity: 0
    });
  }

  if (buttonRect.width < 500) {
    styles.minWidth = buttonRect.width;
  }

  var collisions = {
    top: buttonRect.top - menuRect.height < 0,
    right: window.innerWidth < buttonRect.left + menuRect.width,
    bottom: window.innerHeight < buttonRect.top + menuRect.height,
    left: buttonRect.left - menuRect.width < 0
  };
  var directionRight = collisions.right && !collisions.left;
  var directionUp = collisions.bottom && !collisions.top;
  return menu_button_es_extends({}, styles, {
    left: directionRight ? buttonRect.right - menuRect.width + window.pageXOffset + "px" : buttonRect.left + window.pageXOffset + "px",
    top: directionUp ? buttonRect.top - menuRect.height + window.pageYOffset + "px" : buttonRect.top + buttonRect.height + window.pageYOffset + "px"
  });
};


// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Button.css
var Button = __webpack_require__(70);
var Button_default = /*#__PURE__*/__webpack_require__.n(Button);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Button.js
function Button_extends() { Button_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Button_extends.apply(this, arguments); }

function Button_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Button_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Button_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */




function Button_Button(_ref) {
  let children = _ref.children,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$title = _ref.title,
      title = _ref$title === void 0 ? '' : _ref$title,
      rest = Button_objectWithoutProperties(_ref, ["children", "className", "title"]);

  let button = /*#__PURE__*/external_react_["createElement"]("button", Button_extends({
    className: `${Button_default.a.Button} ${className}`
  }, rest), /*#__PURE__*/external_react_["createElement"]("span", {
    className: `${Button_default.a.ButtonContent} ${className}`,
    tabIndex: -1
  }, children));

  if (title) {
    button = /*#__PURE__*/external_react_["createElement"](Tooltip, {
      className: Tooltip_default.a.Tooltip,
      label: title
    }, button);
  }

  return button;
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/cache.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

 // Cache implementation was forked from the React repo:
// https://github.com/facebook/react/blob/master/packages/react-cache/src/ReactCache.js
//
// This cache is simpler than react-cache in that:
// 1. Individual items don't need to be invalidated.
//    Profiling data is invalidated as a whole.
// 2. We didn't need the added overhead of an LRU cache.
//    The size of this cache is bounded by how many renders were profiled,
//    and it will be fully reset between profiling sessions.

const Pending = 0;
const Resolved = 1;
const Rejected = 2;
const ReactCurrentDispatcher = external_react_["__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED"].ReactCurrentDispatcher;

function readContext(Context, observedBits) {
  const dispatcher = ReactCurrentDispatcher.current;

  if (dispatcher === null) {
    throw new Error('react-cache: read and preload may only be called from within a ' + "component's render. They are not supported in event handlers or " + 'lifecycle methods.');
  }

  return dispatcher.readContext(Context, observedBits);
}

const CacheContext = /*#__PURE__*/Object(external_react_["createContext"])(null);
const cache_entries = new Map();
const resourceConfigs = new Map();

function getEntriesForResource(resource) {
  let entriesForResource = cache_entries.get(resource);

  if (entriesForResource === undefined) {
    const config = resourceConfigs.get(resource);
    entriesForResource = config !== undefined && config.useWeakMap ? new WeakMap() : new Map();
    cache_entries.set(resource, entriesForResource);
  }

  return entriesForResource;
}

function accessResult(resource, fetch, input, key) {
  const entriesForResource = getEntriesForResource(resource);
  const entry = entriesForResource.get(key);

  if (entry === undefined) {
    const thenable = fetch(input);
    thenable.then(value => {
      if (newResult.status === Pending) {
        const resolvedResult = newResult;
        resolvedResult.status = Resolved;
        resolvedResult.value = value;
      }
    }, error => {
      if (newResult.status === Pending) {
        const rejectedResult = newResult;
        rejectedResult.status = Rejected;
        rejectedResult.value = error;
      }
    });
    const newResult = {
      status: Pending,
      value: thenable
    };
    entriesForResource.set(key, newResult);
    return newResult;
  } else {
    return entry;
  }
}

function createResource(fetch, hashInput, config = {}) {
  const resource = {
    clear() {
      cache_entries.delete(resource);
    },

    invalidate(key) {
      const entriesForResource = getEntriesForResource(resource);
      entriesForResource.delete(key);
    },

    read(input) {
      // Prevent access outside of render.
      readContext(CacheContext);
      const key = hashInput(input);
      const result = accessResult(resource, fetch, input, key);

      switch (result.status) {
        case Pending:
          {
            const suspender = result.value;
            throw suspender;
          }

        case Resolved:
          {
            const value = result.value;
            return value;
          }

        case Rejected:
          {
            const error = result.value;
            throw error;
          }

        default:
          // Should be unreachable
          return undefined;
      }
    },

    preload(input) {
      // Prevent access outside of render.
      readContext(CacheContext);
      const key = hashInput(input);
      accessResult(resource, fetch, input, key);
    },

    write(key, value) {
      const entriesForResource = getEntriesForResource(resource);
      const resolvedResult = {
        status: Resolved,
        value
      };
      entriesForResource.set(key, resolvedResult);
    }

  };
  resourceConfigs.set(resource, config);
  return resource;
}
function invalidateResources() {
  cache_entries.clear();
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/OwnersListContext.js
function OwnersListContext_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function OwnersListContext_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { OwnersListContext_ownKeys(Object(source), true).forEach(function (key) { OwnersListContext_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { OwnersListContext_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function OwnersListContext_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function OwnersListContext_slicedToArray(arr, i) { return OwnersListContext_arrayWithHoles(arr) || OwnersListContext_iterableToArrayLimit(arr, i) || OwnersListContext_unsupportedIterableToArray(arr, i) || OwnersListContext_nonIterableRest(); }

function OwnersListContext_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function OwnersListContext_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return OwnersListContext_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return OwnersListContext_arrayLikeToArray(o, minLen); }

function OwnersListContext_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function OwnersListContext_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function OwnersListContext_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






const OwnersListContext = /*#__PURE__*/Object(external_react_["createContext"])(null);
OwnersListContext.displayName = 'OwnersListContext';
const inProgressRequests = new WeakMap();
const resource = createResource(element => {
  const request = inProgressRequests.get(element);

  if (request != null) {
    return request.promise;
  }

  let resolveFn = null;
  const promise = new Promise(resolve => {
    resolveFn = resolve;
  });
  inProgressRequests.set(element, {
    promise,
    resolveFn
  });
  return promise;
}, element => element, {
  useWeakMap: true
});

function OwnersListContextController({
  children
}) {
  const bridge = Object(external_react_["useContext"])(BridgeContext);
  const store = Object(external_react_["useContext"])(StoreContext);

  const _useContext = Object(external_react_["useContext"])(TreeStateContext),
        ownerID = _useContext.ownerID;

  const read = Object(external_react_["useCallback"])(id => {
    const element = store.getElementByID(id);

    if (element !== null) {
      return resource.read(element);
    } else {
      return null;
    }
  }, [store]);
  Object(external_react_["useEffect"])(() => {
    const onOwnersList = ownersList => {
      const id = ownersList.id;
      const element = store.getElementByID(id);

      if (element !== null) {
        const request = inProgressRequests.get(element);

        if (request != null) {
          inProgressRequests.delete(element);
          request.resolveFn(ownersList.owners === null ? null : ownersList.owners.map(owner => {
            const _separateDisplayNameA = Object(utils["p" /* separateDisplayNameAndHOCs */])(owner.displayName, owner.type),
                  _separateDisplayNameA2 = OwnersListContext_slicedToArray(_separateDisplayNameA, 2),
                  displayNameWithoutHOCs = _separateDisplayNameA2[0],
                  hocDisplayNames = _separateDisplayNameA2[1];

            return OwnersListContext_objectSpread(OwnersListContext_objectSpread({}, owner), {}, {
              displayName: displayNameWithoutHOCs,
              hocDisplayNames
            });
          }));
        }
      }
    };

    bridge.addListener('ownersList', onOwnersList);
    return () => bridge.removeListener('ownersList', onOwnersList);
  }, [bridge, store]); // This effect requests an updated owners list any time the selected owner changes

  Object(external_react_["useEffect"])(() => {
    if (ownerID !== null) {
      const rendererID = store.getRendererIDForElement(ownerID);

      if (rendererID !== null) {
        bridge.send('getOwnersList', {
          id: ownerID,
          rendererID
        });
      }
    }

    return () => {};
  }, [bridge, ownerID, store]);
  return /*#__PURE__*/external_react_["createElement"](OwnersListContext.Provider, {
    value: read
  }, children);
}


// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/OwnersStack.css
var OwnersStack = __webpack_require__(18);
var OwnersStack_default = /*#__PURE__*/__webpack_require__.n(OwnersStack);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/OwnersStack.js
function OwnersStack_slicedToArray(arr, i) { return OwnersStack_arrayWithHoles(arr) || OwnersStack_iterableToArrayLimit(arr, i) || OwnersStack_unsupportedIterableToArray(arr, i) || OwnersStack_nonIterableRest(); }

function OwnersStack_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function OwnersStack_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return OwnersStack_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return OwnersStack_arrayLikeToArray(o, minLen); }

function OwnersStack_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function OwnersStack_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function OwnersStack_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function OwnersStack_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function OwnersStack_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { OwnersStack_ownKeys(Object(source), true).forEach(function (key) { OwnersStack_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { OwnersStack_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function OwnersStack_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */














function dialogReducer(state, action) {
  switch (action.type) {
    case 'UPDATE_OWNER_ID':
      const selectedIndex = action.owners.findIndex(owner => owner.id === action.ownerID);
      return {
        ownerID: action.ownerID,
        owners: action.owners,
        selectedIndex
      };

    case 'UPDATE_SELECTED_INDEX':
      return OwnersStack_objectSpread(OwnersStack_objectSpread({}, state), {}, {
        selectedIndex: action.selectedIndex
      });

    default:
      throw new Error(`Invalid action "${action.type}"`);
  }
}

function OwnerStack() {
  const read = Object(external_react_["useContext"])(OwnersListContext);

  const _useContext = Object(external_react_["useContext"])(TreeStateContext),
        ownerID = _useContext.ownerID;

  const treeDispatch = Object(external_react_["useContext"])(TreeDispatcherContext);

  const _useReducer = Object(external_react_["useReducer"])(dialogReducer, {
    ownerID: null,
    owners: [],
    selectedIndex: 0
  }),
        _useReducer2 = OwnersStack_slicedToArray(_useReducer, 2),
        state = _useReducer2[0],
        dispatch = _useReducer2[1]; // When an owner is selected, we either need to update the selected index, or we need to fetch a new list of owners.
  // We use a reducer here so that we can avoid fetching a new list unless the owner ID has actually changed.


  if (ownerID === null) {
    dispatch({
      type: 'UPDATE_OWNER_ID',
      ownerID: null,
      owners: []
    });
  } else if (ownerID !== state.ownerID) {
    const isInStore = state.owners.findIndex(owner => owner.id === ownerID) >= 0;
    dispatch({
      type: 'UPDATE_OWNER_ID',
      ownerID,
      owners: isInStore ? state.owners : read(ownerID) || []
    });
  }

  const owners = state.owners,
        selectedIndex = state.selectedIndex;
  const selectOwner = Object(external_react_["useCallback"])(owner => {
    if (owner !== null) {
      const index = owners.indexOf(owner);
      dispatch({
        type: 'UPDATE_SELECTED_INDEX',
        selectedIndex: index >= 0 ? index : 0
      });
      treeDispatch({
        type: 'SELECT_OWNER',
        payload: owner.id
      });
    } else {
      dispatch({
        type: 'UPDATE_SELECTED_INDEX',
        selectedIndex: 0
      });
      treeDispatch({
        type: 'RESET_OWNER_STACK'
      });
    }
  }, [owners, treeDispatch]);

  const _useState = Object(external_react_["useState"])(0),
        _useState2 = OwnersStack_slicedToArray(_useState, 2),
        elementsTotalWidth = _useState2[0],
        setElementsTotalWidth = _useState2[1];

  const elementsBarRef = Object(external_react_["useRef"])(null);
  const isOverflowing = useIsOverflowing(elementsBarRef, elementsTotalWidth);
  const selectedOwner = owners[selectedIndex];
  Object(external_react_["useLayoutEffect"])(() => {
    // If we're already overflowing, then we don't need to re-measure items.
    // That's because once the owners stack is open, it can only get larger (by drilling in).
    // A totally new stack can only be reached by exiting this mode and re-entering it.
    if (elementsBarRef.current === null || isOverflowing) {
      return () => {};
    }

    let totalWidth = 0;

    for (let i = 0; i < owners.length; i++) {
      const element = elementsBarRef.current.children[i];
      const computedStyle = getComputedStyle(element);
      totalWidth += element.offsetWidth + parseInt(computedStyle.marginLeft, 10) + parseInt(computedStyle.marginRight, 10);
    }

    setElementsTotalWidth(totalWidth);
  }, [elementsBarRef, isOverflowing, owners.length]);
  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: OwnersStack_default.a.OwnerStack
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: OwnersStack_default.a.Bar,
    ref: elementsBarRef
  }, isOverflowing && /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"](ElementsDropdown, {
    owners: owners,
    selectedIndex: selectedIndex,
    selectOwner: selectOwner
  }), /*#__PURE__*/external_react_["createElement"](BackToOwnerButton, {
    owners: owners,
    selectedIndex: selectedIndex,
    selectOwner: selectOwner
  }), selectedOwner != null && /*#__PURE__*/external_react_["createElement"](OwnersStack_ElementView, {
    owner: selectedOwner,
    isSelected: true,
    selectOwner: selectOwner
  })), !isOverflowing && owners.map((owner, index) => /*#__PURE__*/external_react_["createElement"](OwnersStack_ElementView, {
    key: index,
    owner: owner,
    isSelected: index === selectedIndex,
    selectOwner: selectOwner
  }))), /*#__PURE__*/external_react_["createElement"]("div", {
    className: OwnersStack_default.a.VRule
  }), /*#__PURE__*/external_react_["createElement"](Button_Button, {
    className: OwnersStack_default.a.IconButton,
    onClick: () => selectOwner(null),
    title: "Back to tree view"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "close"
  })));
}

function ElementsDropdown({
  owners,
  selectedIndex,
  selectOwner
}) {
  const store = Object(external_react_["useContext"])(StoreContext);
  const menuItems = [];

  for (let index = owners.length - 1; index >= 0; index--) {
    const owner = owners[index];
    const isInStore = store.containsElement(owner.id);
    menuItems.push( /*#__PURE__*/external_react_["createElement"](MenuItem, {
      key: owner.id,
      className: `${OwnersStack_default.a.Component} ${isInStore ? '' : OwnersStack_default.a.NotInStore}`,
      onSelect: () => isInStore ? selectOwner(owner) : null
    }, owner.displayName, /*#__PURE__*/external_react_["createElement"](Badge_Badge, {
      className: OwnersStack_default.a.Badge,
      hocDisplayNames: owner.hocDisplayNames,
      type: owner.type
    })));
  }

  return /*#__PURE__*/external_react_["createElement"](es_Menu, null, /*#__PURE__*/external_react_["createElement"](MenuButton, {
    className: OwnersStack_default.a.MenuButton
  }, /*#__PURE__*/external_react_["createElement"](Tooltip, {
    label: "Open elements dropdown"
  }, /*#__PURE__*/external_react_["createElement"]("span", {
    className: OwnersStack_default.a.MenuButtonContent,
    tabIndex: -1
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "more"
  })))), /*#__PURE__*/external_react_["createElement"](MenuList, {
    className: OwnersStack_default.a.Modal
  }, menuItems));
}

function OwnersStack_ElementView({
  isSelected,
  owner,
  selectOwner
}) {
  const store = Object(external_react_["useContext"])(StoreContext);
  const displayName = owner.displayName,
        hocDisplayNames = owner.hocDisplayNames,
        type = owner.type;
  const isInStore = store.containsElement(owner.id);
  const handleChange = Object(external_react_["useCallback"])(() => {
    if (isInStore) {
      selectOwner(owner);
    }
  }, [isInStore, selectOwner, owner]);
  return /*#__PURE__*/external_react_["createElement"](Toggle_Toggle, {
    className: `${OwnersStack_default.a.Component} ${isInStore ? '' : OwnersStack_default.a.NotInStore}`,
    isChecked: isSelected,
    onChange: handleChange
  }, displayName, /*#__PURE__*/external_react_["createElement"](Badge_Badge, {
    className: OwnersStack_default.a.Badge,
    hocDisplayNames: hocDisplayNames,
    type: type
  }));
}

function BackToOwnerButton({
  owners,
  selectedIndex,
  selectOwner
}) {
  const store = Object(external_react_["useContext"])(StoreContext);

  if (selectedIndex <= 0) {
    return null;
  }

  const owner = owners[selectedIndex - 1];
  const isInStore = store.containsElement(owner.id);
  return /*#__PURE__*/external_react_["createElement"](Button_Button, {
    className: isInStore ? undefined : OwnersStack_default.a.NotInStore,
    onClick: () => isInStore ? selectOwner(owner) : null,
    title: `Up to ${owner.displayName || 'owner'}`
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "previous"
  }));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Icon.css
var Icon = __webpack_require__(80);
var Icon_default = /*#__PURE__*/__webpack_require__.n(Icon);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Icon.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


function Icon_Icon({
  className = '',
  type
}) {
  let pathData = null;

  switch (type) {
    case 'arrow':
      pathData = PATH_ARROW;
      break;

    case 'bug':
      pathData = PATH_BUG;
      break;

    case 'code':
      pathData = PATH_CODE;
      break;

    case 'components':
      pathData = PATH_COMPONENTS;
      break;

    case 'copy':
      pathData = Icon_PATH_COPY;
      break;

    case 'flame-chart':
      pathData = PATH_FLAME_CHART;
      break;

    case 'interactions':
      pathData = PATH_INTERACTIONS;
      break;

    case 'profiler':
      pathData = PATH_PROFILER;
      break;

    case 'ranked-chart':
      pathData = PATH_RANKED_CHART;
      break;

    case 'search':
      pathData = Icon_PATH_SEARCH;
      break;

    case 'settings':
      pathData = Icon_PATH_SETTINGS;
      break;

    case 'store-as-global-variable':
      pathData = PATH_STORE_AS_GLOBAL_VARIABLE;
      break;

    default:
      console.warn(`Unsupported type "${type}" specified for Icon`);
      break;
  }

  return /*#__PURE__*/external_react_["createElement"]("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    className: `${Icon_default.a.Icon} ${className}`,
    width: "24",
    height: "24",
    viewBox: "0 0 24 24"
  }, /*#__PURE__*/external_react_["createElement"]("path", {
    d: "M0 0h24v24H0z",
    fill: "none"
  }), /*#__PURE__*/external_react_["createElement"]("path", {
    fill: "currentColor",
    d: pathData
  }));
}
const PATH_ARROW = 'M8 5v14l11-7z';
const PATH_BUG = `
  M20 8h-2.81c-.45-.78-1.07-1.45-1.82-1.96L17 4.41 15.59 3l-2.17 2.17C12.96 5.06 12.49 5 12 5c-.49
  0-.96.06-1.41.17L8.41 3 7 4.41l1.62 1.63C7.88 6.55 7.26 7.22 6.81 8H4v2h2.09c-.05.33-.09.66-.09
  1v1H4v2h2v1c0 .34.04.67.09 1H4v2h2.81c1.04 1.79 2.97 3 5.19 3s4.15-1.21
  5.19-3H20v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20V8zm-6 8h-4v-2h4v2zm0-4h-4v-2h4v2z
`;
const PATH_CODE = `
  M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z
  `;
const PATH_COMPONENTS = 'M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z';
const Icon_PATH_COPY = `
  M3 13h2v-2H3v2zm0 4h2v-2H3v2zm2 4v-2H3a2 2 0 0 0 2 2zM3 9h2V7H3v2zm12 12h2v-2h-2v2zm4-18H9a2 2 0 0 0-2
  2v10a2 2 0 0 0 2 2h10c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 12H9V5h10v10zm-8 6h2v-2h-2v2zm-4 0h2v-2H7v2z
`;
const PATH_FLAME_CHART = `
  M10.0650893,21.5040462 C7.14020814,20.6850349 5,18.0558698 5,14.9390244 C5,14.017627
  5,9.81707317 7.83333333,7.37804878 C7.83333333,7.37804878 7.58333333,11.199187 10,
  10.6300813 C11.125,10.326087 13.0062497,7.63043487 8.91666667,2.5 C14.1666667,3.06910569
  19,9.32926829 19,14.9390244 C19,18.0558698 16.8597919,20.6850349 13.9349107,21.5040462
  C14.454014,21.0118505 14.7765152,20.3233394 14.7765152,19.5613412 C14.7765152,17.2826087
  12,15.0875871 12,15.0875871 C12,15.0875871 9.22348485,17.2826087 9.22348485,19.5613412
  C9.22348485,20.3233394 9.54598603,21.0118505 10.0650893,21.5040462 Z M12.0833333,20.6514763
  C11.3814715,20.6514763 10.8125,20.1226027 10.8125,19.4702042 C10.8125,18.6069669
  12.0833333,16.9347829 12.0833333,16.9347829 C12.0833333,16.9347829 13.3541667,18.6069669
  13.3541667,19.4702042 C13.3541667,20.1226027 12.7851952,20.6514763 12.0833333,20.6514763 Z
`;
const PATH_INTERACTIONS = `
  M23 8c0 1.1-.9 2-2 2-.18 0-.35-.02-.51-.07l-3.56 3.55c.05.16.07.34.07.52 0 1.1-.9 2-2
  2s-2-.9-2-2c0-.18.02-.36.07-.52l-2.55-2.55c-.16.05-.34.07-.52.07s-.36-.02-.52-.07l-4.55
  4.56c.05.16.07.33.07.51 0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2c.18 0 .35.02.51.07l4.56-4.55C8.02
  9.36 8 9.18 8 9c0-1.1.9-2 2-2s2 .9 2 2c0 .18-.02.36-.07.52l2.55
  2.55c.16-.05.34-.07.52-.07s.36.02.52.07l3.55-3.56C19.02 8.35 19 8.18 19 8c0-1.1.9-2 2-2s2 .9 2 2z
`;
const PATH_PROFILER = 'M5 9.2h3V19H5zM10.6 5h2.8v14h-2.8zm5.6 8H19v6h-2.8z';
const Icon_PATH_SEARCH = `
  M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91
  16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99
  5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z
`;
const PATH_RANKED_CHART = 'M3 5h18v3H3zM3 10.5h13v3H3zM3 16h8v3H3z';
const Icon_PATH_SETTINGS = `
  M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49
  1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38
  2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11
  1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4
  1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49
  1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5
  3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z
`;
const PATH_STORE_AS_GLOBAL_VARIABLE = `
  M20 8h-2.81c-.45-.78-1.07-1.45-1.82-1.96L17 4.41 15.59 3l-2.17 2.17C12.96 5.06 12.49 5 12 5c-.49 0-.96.06-1.41.17L8.41
  3 7 4.41l1.62 1.63C7.88 6.55 7.26 7.22 6.81 8H4v2h2.09c-.05.33-.09.66-.09 1v1H4v2h2v1c0 .34.04.67.09 1H4v2h2.81c1.04
  1.79 2.97 3 5.19 3s4.15-1.21 5.19-3H20v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20V8zm-6
  8h-4v-2h4v2zm0-4h-4v-2h4v2z
`;
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/SearchInput.css
var SearchInput = __webpack_require__(31);
var SearchInput_default = /*#__PURE__*/__webpack_require__.n(SearchInput);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/SearchInput.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */







function SearchInput_SearchInput(props) {
  const _useContext = Object(external_react_["useContext"])(TreeStateContext),
        searchIndex = _useContext.searchIndex,
        searchResults = _useContext.searchResults,
        searchText = _useContext.searchText;

  const dispatch = Object(external_react_["useContext"])(TreeDispatcherContext);
  const inputRef = Object(external_react_["useRef"])(null);
  const handleTextChange = Object(external_react_["useCallback"])(({
    currentTarget
  }) => dispatch({
    type: 'SET_SEARCH_TEXT',
    payload: currentTarget.value
  }), [dispatch]);
  const resetSearch = Object(external_react_["useCallback"])(() => dispatch({
    type: 'SET_SEARCH_TEXT',
    payload: ''
  }), [dispatch]);
  const handleKeyDown = Object(external_react_["useCallback"])(event => {
    // For convenience, let up/down arrow keys change Tree selection.
    switch (event.key) {
      case 'ArrowDown':
        dispatch({
          type: 'SELECT_NEXT_ELEMENT_IN_TREE'
        });
        event.preventDefault();
        break;

      case 'ArrowUp':
        dispatch({
          type: 'SELECT_PREVIOUS_ELEMENT_IN_TREE'
        });
        event.preventDefault();
        break;

      default:
        break;
    }
  }, [dispatch]);
  const handleInputKeyPress = Object(external_react_["useCallback"])(({
    key,
    shiftKey
  }) => {
    if (key === 'Enter') {
      if (shiftKey) {
        dispatch({
          type: 'GO_TO_PREVIOUS_SEARCH_RESULT'
        });
      } else {
        dispatch({
          type: 'GO_TO_NEXT_SEARCH_RESULT'
        });
      }
    }
  }, [dispatch]); // Auto-focus search input

  Object(external_react_["useEffect"])(() => {
    if (inputRef.current === null) {
      return () => {};
    }

    const handleWindowKey = event => {
      const key = event.key,
            metaKey = event.metaKey;

      if (key === 'f' && metaKey) {
        if (inputRef.current !== null) {
          inputRef.current.focus();
          event.preventDefault();
          event.stopPropagation();
        }
      }
    }; // It's important to listen to the ownerDocument to support the browser extension.
    // Here we use portals to render individual tabs (e.g. Profiler),
    // and the root document might belong to a different window.


    const ownerDocument = inputRef.current.ownerDocument;
    ownerDocument.addEventListener('keydown', handleWindowKey);
    return () => ownerDocument.removeEventListener('keydown', handleWindowKey);
  }, [inputRef]);
  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: SearchInput_default.a.SearchInput
  }, /*#__PURE__*/external_react_["createElement"](Icon_Icon, {
    className: SearchInput_default.a.InputIcon,
    type: "search"
  }), /*#__PURE__*/external_react_["createElement"]("input", {
    className: SearchInput_default.a.Input,
    onChange: handleTextChange,
    onKeyDown: handleKeyDown,
    onKeyPress: handleInputKeyPress,
    placeholder: "Search (text or /regex/)",
    ref: inputRef,
    value: searchText
  }), !!searchText && /*#__PURE__*/external_react_["createElement"]("span", {
    className: SearchInput_default.a.IndexLabel
  }, Math.min(searchIndex + 1, searchResults.length), " |", ' ', searchResults.length), /*#__PURE__*/external_react_["createElement"]("div", {
    className: SearchInput_default.a.LeftVRule
  }), /*#__PURE__*/external_react_["createElement"](Button_Button, {
    className: SearchInput_default.a.IconButton,
    disabled: !searchText,
    onClick: () => dispatch({
      type: 'GO_TO_PREVIOUS_SEARCH_RESULT'
    }),
    title: "Scroll to previous search result"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "up"
  })), /*#__PURE__*/external_react_["createElement"](Button_Button, {
    className: SearchInput_default.a.IconButton,
    disabled: !searchText,
    onClick: () => dispatch({
      type: 'GO_TO_NEXT_SEARCH_RESULT'
    }),
    title: "Scroll to next search result"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "down"
  })), /*#__PURE__*/external_react_["createElement"](Button_Button, {
    className: SearchInput_default.a.IconButton,
    disabled: !searchText,
    onClick: resetSearch,
    title: "Reset search"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "close"
  })));
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Settings/SettingsModalContext.js
function SettingsModalContext_slicedToArray(arr, i) { return SettingsModalContext_arrayWithHoles(arr) || SettingsModalContext_iterableToArrayLimit(arr, i) || SettingsModalContext_unsupportedIterableToArray(arr, i) || SettingsModalContext_nonIterableRest(); }

function SettingsModalContext_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function SettingsModalContext_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return SettingsModalContext_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return SettingsModalContext_arrayLikeToArray(o, minLen); }

function SettingsModalContext_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function SettingsModalContext_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function SettingsModalContext_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


const SettingsModalContext = /*#__PURE__*/Object(external_react_["createContext"])(null);
SettingsModalContext.displayName = 'SettingsModalContext';

function SettingsModalContextController({
  children
}) {
  const _useState = Object(external_react_["useState"])(false),
        _useState2 = SettingsModalContext_slicedToArray(_useState, 2),
        isModalShowing = _useState2[0],
        setIsModalShowing = _useState2[1];

  const value = Object(external_react_["useMemo"])(() => ({
    isModalShowing,
    setIsModalShowing
  }), [isModalShowing, setIsModalShowing]);
  return /*#__PURE__*/external_react_["createElement"](SettingsModalContext.Provider, {
    value: value
  }, children);
}


// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Settings/SettingsModalContextToggle.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */







function SettingsModalContextToggle() {
  const _useContext = Object(external_react_["useContext"])(SettingsModalContext),
        setIsModalShowing = _useContext.setIsModalShowing;

  const store = Object(external_react_["useContext"])(StoreContext);
  const profilerStore = store.profilerStore;
  const showFilterModal = Object(external_react_["useCallback"])(() => setIsModalShowing(true), [setIsModalShowing]); // Updating preferences while profiling is in progress could break things (e.g. filtering)
  // Explicitly disallow it for now.

  const isProfilingSubscription = Object(external_react_["useMemo"])(() => ({
    getCurrentValue: () => profilerStore.isProfiling,
    subscribe: callback => {
      profilerStore.addListener('isProfiling', callback);
      return () => profilerStore.removeListener('isProfiling', callback);
    }
  }), [profilerStore]);
  const isProfiling = useSubscription(isProfilingSubscription);
  return /*#__PURE__*/external_react_["createElement"](Button_Button, {
    disabled: isProfiling,
    onClick: showFilterModal,
    title: "View settings"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "settings"
  }));
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/TreeFocusedContext.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

const TreeFocusedContext = /*#__PURE__*/Object(external_react_["createContext"])(false);
/* harmony default export */ var Components_TreeFocusedContext = (TreeFocusedContext);
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/SelectedTreeHighlight.css
var SelectedTreeHighlight = __webpack_require__(71);
var SelectedTreeHighlight_default = /*#__PURE__*/__webpack_require__.n(SelectedTreeHighlight);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/SelectedTreeHighlight.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */








function SelectedTreeHighlight_SelectedTreeHighlight(_) {
  const _useContext = Object(external_react_["useContext"])(SettingsContext),
        lineHeight = _useContext.lineHeight;

  const store = Object(external_react_["useContext"])(StoreContext);
  const treeFocused = Object(external_react_["useContext"])(Components_TreeFocusedContext);

  const _useContext2 = Object(external_react_["useContext"])(TreeStateContext),
        ownerID = _useContext2.ownerID,
        selectedElementID = _useContext2.selectedElementID;

  const subscription = Object(external_react_["useMemo"])(() => ({
    getCurrentValue: () => {
      if (selectedElementID === null || store.isInsideCollapsedSubTree(selectedElementID)) {
        return null;
      }

      const element = store.getElementByID(selectedElementID);

      if (element === null || element.isCollapsed || element.children.length === 0) {
        return null;
      }

      const startIndex = store.getIndexOfElementID(element.children[0]);

      if (startIndex === null) {
        return null;
      }

      let stopIndex = null;
      let current = element;

      while (current !== null) {
        if (current.isCollapsed || current.children.length === 0) {
          // We've found the last/deepest descendant.
          stopIndex = store.getIndexOfElementID(current.id);
          current = null;
        } else {
          const lastChildID = current.children[current.children.length - 1];
          current = store.getElementByID(lastChildID);
        }
      }

      if (stopIndex === null) {
        return null;
      }

      return {
        startIndex,
        stopIndex
      };
    },
    subscribe: callback => {
      store.addListener('mutated', callback);
      return () => {
        store.removeListener('mutated', callback);
      };
    }
  }), [selectedElementID, store]);
  const data = useSubscription(subscription);

  if (ownerID !== null) {
    return null;
  }

  if (data === null) {
    return null;
  }

  const startIndex = data.startIndex,
        stopIndex = data.stopIndex;
  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: treeFocused ? SelectedTreeHighlight_default.a.Active : SelectedTreeHighlight_default.a.Inactive,
    style: {
      position: 'absolute',
      top: `${startIndex * lineHeight}px`,
      height: `${(stopIndex + 1 - startIndex) * lineHeight}px`
    }
  });
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/Tree.css
var Tree = __webpack_require__(32);
var Tree_default = /*#__PURE__*/__webpack_require__.n(Tree);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/Tree.js
function Tree_extends() { Tree_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Tree_extends.apply(this, arguments); }

function Tree_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Tree_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Tree_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function Tree_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = Tree_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function Tree_slicedToArray(arr, i) { return Tree_arrayWithHoles(arr) || Tree_iterableToArrayLimit(arr, i) || Tree_unsupportedIterableToArray(arr, i) || Tree_nonIterableRest(); }

function Tree_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function Tree_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Tree_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Tree_arrayLikeToArray(o, minLen); }

function Tree_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function Tree_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function Tree_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */















 // Never indent more than this number of pixels (even if we have the room).

const DEFAULT_INDENTATION_SIZE = 12;
function Tree_Tree(props) {
  const dispatch = Object(external_react_["useContext"])(TreeDispatcherContext);

  const _useContext = Object(external_react_["useContext"])(TreeStateContext),
        numElements = _useContext.numElements,
        ownerID = _useContext.ownerID,
        searchIndex = _useContext.searchIndex,
        searchResults = _useContext.searchResults,
        selectedElementID = _useContext.selectedElementID,
        selectedElementIndex = _useContext.selectedElementIndex;

  const bridge = Object(external_react_["useContext"])(BridgeContext);
  const store = Object(external_react_["useContext"])(StoreContext);

  const _useState = Object(external_react_["useState"])(false),
        _useState2 = Tree_slicedToArray(_useState, 2),
        isNavigatingWithKeyboard = _useState2[0],
        setIsNavigatingWithKeyboard = _useState2[1];

  const _useHighlightNativeEl = useHighlightNativeElement(),
        highlightNativeElement = _useHighlightNativeEl.highlightNativeElement,
        clearHighlightNativeElement = _useHighlightNativeEl.clearHighlightNativeElement;

  const treeRef = Object(external_react_["useRef"])(null);
  const focusTargetRef = Object(external_react_["useRef"])(null);

  const _useState3 = Object(external_react_["useState"])(false),
        _useState4 = Tree_slicedToArray(_useState3, 2),
        treeFocused = _useState4[0],
        setTreeFocused = _useState4[1];

  const _useContext2 = Object(external_react_["useContext"])(SettingsContext),
        lineHeight = _useContext2.lineHeight; // Make sure a newly selected element is visible in the list.
  // This is helpful for things like the owners list and search.
  //
  // TRICKY:
  // It's important to use a callback ref for this, rather than a ref object and an effect.
  // As an optimization, the AutoSizer component does not render children when their size would be 0.
  // This means that in some cases (if the browser panel size is initially really small),
  // the Tree component might render without rendering an inner List.
  // In this case, the list ref would be null on mount (when the scroll effect runs),
  // meaning the scroll action would be skipped (since ref updates don't re-run effects).
  // Using a callback ref accounts for this case...


  const listCallbackRef = Object(external_react_["useCallback"])(list => {
    if (list != null && selectedElementIndex !== null) {
      list.scrollToItem(selectedElementIndex, 'smart');
    }
  }, [selectedElementIndex]); // Picking an element in the inspector should put focus into the tree.
  // This ensures that keyboard navigation works right after picking a node.

  Object(external_react_["useEffect"])(() => {
    function handleStopInspectingNative(didSelectNode) {
      if (didSelectNode && focusTargetRef.current !== null) {
        focusTargetRef.current.focus();
      }
    }

    bridge.addListener('stopInspectingNative', handleStopInspectingNative);
    return () => bridge.removeListener('stopInspectingNative', handleStopInspectingNative);
  }, [bridge]); // This ref is passed down the context to elements.
  // It lets them avoid autoscrolling to the same item many times
  // when a selected virtual row goes in and out of the viewport.

  const lastScrolledIDRef = Object(external_react_["useRef"])(null); // Navigate the tree with up/down arrow keys.

  Object(external_react_["useEffect"])(() => {
    if (treeRef.current === null) {
      return () => {};
    }

    const handleKeyDown = event => {
      if (event.target.tagName === 'INPUT' || event.defaultPrevented) {
        return;
      } // TODO We should ignore arrow keys if the focus is outside of DevTools.
      // Otherwise the inline (embedded) DevTools might change selection unexpectedly,
      // e.g. when a text input or a select has focus.


      let element;

      switch (event.key) {
        case 'ArrowDown':
          event.preventDefault();

          if (event.altKey) {
            dispatch({
              type: 'SELECT_NEXT_SIBLING_IN_TREE'
            });
          } else {
            dispatch({
              type: 'SELECT_NEXT_ELEMENT_IN_TREE'
            });
          }

          break;

        case 'ArrowLeft':
          event.preventDefault();
          element = selectedElementID !== null ? store.getElementByID(selectedElementID) : null;

          if (element !== null) {
            if (event.altKey) {
              if (element.ownerID !== null) {
                dispatch({
                  type: 'SELECT_OWNER_LIST_PREVIOUS_ELEMENT_IN_TREE'
                });
              }
            } else {
              if (element.children.length > 0 && !element.isCollapsed) {
                store.toggleIsCollapsed(element.id, true);
              } else {
                dispatch({
                  type: 'SELECT_PARENT_ELEMENT_IN_TREE'
                });
              }
            }
          }

          break;

        case 'ArrowRight':
          event.preventDefault();
          element = selectedElementID !== null ? store.getElementByID(selectedElementID) : null;

          if (element !== null) {
            if (event.altKey) {
              dispatch({
                type: 'SELECT_OWNER_LIST_NEXT_ELEMENT_IN_TREE'
              });
            } else {
              if (element.children.length > 0 && element.isCollapsed) {
                store.toggleIsCollapsed(element.id, false);
              } else {
                dispatch({
                  type: 'SELECT_CHILD_ELEMENT_IN_TREE'
                });
              }
            }
          }

          break;

        case 'ArrowUp':
          event.preventDefault();

          if (event.altKey) {
            dispatch({
              type: 'SELECT_PREVIOUS_SIBLING_IN_TREE'
            });
          } else {
            dispatch({
              type: 'SELECT_PREVIOUS_ELEMENT_IN_TREE'
            });
          }

          break;

        default:
          return;
      }

      setIsNavigatingWithKeyboard(true);
    }; // It's important to listen to the ownerDocument to support the browser extension.
    // Here we use portals to render individual tabs (e.g. Profiler),
    // and the root document might belong to a different window.


    const ownerDocument = treeRef.current.ownerDocument;
    ownerDocument.addEventListener('keydown', handleKeyDown);
    return () => {
      ownerDocument.removeEventListener('keydown', handleKeyDown);
    };
  }, [dispatch, selectedElementID, store]); // Focus management.

  const handleBlur = Object(external_react_["useCallback"])(() => setTreeFocused(false), []);
  const handleFocus = Object(external_react_["useCallback"])(() => {
    setTreeFocused(true);

    if (selectedElementIndex === null && numElements > 0) {
      dispatch({
        type: 'SELECT_ELEMENT_AT_INDEX',
        payload: 0
      });
    }
  }, [dispatch, numElements, selectedElementIndex]);
  const handleKeyPress = Object(external_react_["useCallback"])(event => {
    switch (event.key) {
      case 'Enter':
      case ' ':
        if (selectedElementID !== null) {
          dispatch({
            type: 'SELECT_OWNER',
            payload: selectedElementID
          });
        }

        break;

      default:
        break;
    }
  }, [dispatch, selectedElementID]); // If we switch the selected element while using the keyboard,
  // start highlighting it in the DOM instead of the last hovered node.

  const searchRef = Object(external_react_["useRef"])({
    searchIndex,
    searchResults
  });
  Object(external_react_["useEffect"])(() => {
    let didSelectNewSearchResult = false;

    if (searchRef.current.searchIndex !== searchIndex || searchRef.current.searchResults !== searchResults) {
      searchRef.current.searchIndex = searchIndex;
      searchRef.current.searchResults = searchResults;
      didSelectNewSearchResult = true;
    }

    if (isNavigatingWithKeyboard || didSelectNewSearchResult) {
      if (selectedElementID !== null) {
        highlightNativeElement(selectedElementID);
      } else {
        clearHighlightNativeElement();
      }
    }
  }, [bridge, isNavigatingWithKeyboard, highlightNativeElement, searchIndex, searchResults, selectedElementID]); // Highlight last hovered element.

  const handleElementMouseEnter = Object(external_react_["useCallback"])(id => {
    // Ignore hover while we're navigating with keyboard.
    // This avoids flicker from the hovered nodes under the mouse.
    if (!isNavigatingWithKeyboard) {
      highlightNativeElement(id);
    }
  }, [isNavigatingWithKeyboard, highlightNativeElement]);
  const handleMouseMove = Object(external_react_["useCallback"])(() => {
    // We started using the mouse again.
    // This will enable hover styles in individual rows.
    setIsNavigatingWithKeyboard(false);
  }, []);
  const handleMouseLeave = clearHighlightNativeElement; // Let react-window know to re-render any time the underlying tree data changes.
  // This includes the owner context, since it controls a filtered view of the tree.

  const itemData = Object(external_react_["useMemo"])(() => ({
    numElements,
    isNavigatingWithKeyboard,
    onElementMouseEnter: handleElementMouseEnter,
    lastScrolledIDRef,
    treeFocused
  }), [numElements, isNavigatingWithKeyboard, handleElementMouseEnter, lastScrolledIDRef, treeFocused]);
  const itemKey = Object(external_react_["useCallback"])(index => store.getElementIDAtIndex(index), [store]);
  return /*#__PURE__*/external_react_["createElement"](Components_TreeFocusedContext.Provider, {
    value: treeFocused
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: Tree_default.a.Tree,
    ref: treeRef
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: Tree_default.a.SearchInput
  }, store.supportsNativeInspection && /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"](InspectHostNodesToggle, null), /*#__PURE__*/external_react_["createElement"]("div", {
    className: Tree_default.a.VRule
  })), /*#__PURE__*/external_react_["createElement"](external_react_["Suspense"], {
    fallback: /*#__PURE__*/external_react_["createElement"](Loading, null)
  }, ownerID !== null ? /*#__PURE__*/external_react_["createElement"](OwnerStack, null) : /*#__PURE__*/external_react_["createElement"](SearchInput_SearchInput, null)), /*#__PURE__*/external_react_["createElement"]("div", {
    className: Tree_default.a.VRule
  }), /*#__PURE__*/external_react_["createElement"](SettingsModalContextToggle, null)), /*#__PURE__*/external_react_["createElement"]("div", {
    className: Tree_default.a.AutoSizerWrapper,
    onBlur: handleBlur,
    onFocus: handleFocus,
    onKeyPress: handleKeyPress,
    onMouseMove: handleMouseMove,
    onMouseLeave: handleMouseLeave,
    ref: focusTargetRef,
    tabIndex: 0
  }, /*#__PURE__*/external_react_["createElement"](index_esm["a" /* default */], null, ({
    height,
    width
  }) =>
  /*#__PURE__*/
  // $FlowFixMe https://github.com/facebook/flow/issues/7341
  external_react_["createElement"](FixedSizeList, {
    className: Tree_default.a.List,
    height: height,
    innerElementType: InnerElementType,
    itemCount: numElements,
    itemData: itemData,
    itemKey: itemKey,
    itemSize: lineHeight,
    ref: listCallbackRef,
    width: width
  }, ElementView)))));
} // Indentation size can be adjusted but child width is fixed.
// We need to adjust indentations so the widest child can fit without overflowing.
// Sometimes the widest child is also the deepest in the tree:
//   â”----------------------â”“
//   â”† <Foo>                â”†
//   â”† â€¢â€¢â€¢â€¢<Foobar>         â”†
//   â”† â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢<Baz>        â”†
//   â”—----------------------â”›
//
// But this is not always the case.
// Even with the above example, a change in indentation may change the overall widest child:
//   â”----------------------â”“
//   â”† <Foo>                â”†
//   â”† â€¢â€¢<Foobar>           â”†
//   â”† â€¢â€¢â€¢â€¢<Baz>            â”†
//   â”—----------------------â”›
//
// In extreme cases this difference can be important:
//   â”----------------------â”“
//   â”† <ReallyLongName>     â”†
//   â”† â€¢â€¢<Foo>              â”†
//   â”† â€¢â€¢â€¢â€¢<Bar>            â”†
//   â”† â€¢â€¢â€¢â€¢â€¢â€¢<Baz>          â”†
//   â”† â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢<Qux>        â”†
//   â”—----------------------â”›
//
// In the above example, the current indentation is fine,
// but if we naively assumed that the widest element is also the deepest element,
// we would end up compressing the indentation unnecessarily:
//   â”----------------------â”“
//   â”† <ReallyLongName>     â”†
//   â”† â€¢<Foo>               â”†
//   â”† â€¢â€¢<Bar>              â”†
//   â”† â€¢â€¢â€¢<Baz>             â”†
//   â”† â€¢â€¢â€¢â€¢<Qux>            â”†
//   â”—----------------------â”›
//
// The way we deal with this is to compute the max indentation size that can fit each child,
// given the child's fixed width and depth within the tree.
// Then we take the smallest of these indentation sizes...

function updateIndentationSizeVar(innerDiv, cachedChildWidths, indentationSizeRef, prevListWidthRef) {
  const list = innerDiv.parentElement;
  const listWidth = list.clientWidth; // Skip measurements when the Components panel is hidden.

  if (listWidth === 0) {
    return;
  } // Reset the max indentation size if the width of the tree has increased.


  if (listWidth > prevListWidthRef.current) {
    indentationSizeRef.current = DEFAULT_INDENTATION_SIZE;
  }

  prevListWidthRef.current = listWidth;
  let maxIndentationSize = indentationSizeRef.current; // eslint-disable-next-line no-for-of-loops/no-for-of-loops

  var _iterator = Tree_createForOfIteratorHelper(innerDiv.children),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      const child = _step.value;
      const depth = parseInt(child.getAttribute('data-depth'), 10) || 0;
      let childWidth = 0;
      const cachedChildWidth = cachedChildWidths.get(child);

      if (cachedChildWidth != null) {
        childWidth = cachedChildWidth;
      } else {
        const firstElementChild = child.firstElementChild; // Skip over e.g. the guideline element

        if (firstElementChild != null) {
          childWidth = firstElementChild.clientWidth;
          cachedChildWidths.set(child, childWidth);
        }
      }

      const remainingWidth = Math.max(0, listWidth - childWidth);
      maxIndentationSize = Math.min(maxIndentationSize, remainingWidth / depth);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  indentationSizeRef.current = maxIndentationSize;
  list.style.setProperty('--indentation-size', `${maxIndentationSize}px`);
}

function InnerElementType(_ref) {
  let children = _ref.children,
      style = _ref.style,
      rest = Tree_objectWithoutProperties(_ref, ["children", "style"]);

  const _useContext3 = Object(external_react_["useContext"])(TreeStateContext),
        ownerID = _useContext3.ownerID;

  const cachedChildWidths = Object(external_react_["useMemo"])(() => new WeakMap(), []); // This ref tracks the current indentation size.
  // We decrease indentation to fit wider/deeper trees.
  // We intentionally do not increase it again afterward, to avoid the perception of content "jumping"
  // e.g. clicking to toggle/collapse a row might otherwise jump horizontally beneath your cursor,
  // e.g. scrolling a wide row off screen could cause narrower rows to jump to the right some.
  //
  // There are two exceptions for this:
  // 1. The first is when the width of the tree increases.
  // The user may have resized the window specifically to make more room for DevTools.
  // In either case, this should reset our max indentation size logic.
  // 2. The second is when the user enters or exits an owner tree.

  const indentationSizeRef = Object(external_react_["useRef"])(DEFAULT_INDENTATION_SIZE);
  const prevListWidthRef = Object(external_react_["useRef"])(0);
  const prevOwnerIDRef = Object(external_react_["useRef"])(ownerID);
  const divRef = Object(external_react_["useRef"])(null); // We shouldn't retain this width across different conceptual trees though,
  // so when the user opens the "owners tree" view, we should discard the previous width.

  if (ownerID !== prevOwnerIDRef.current) {
    prevOwnerIDRef.current = ownerID;
    indentationSizeRef.current = DEFAULT_INDENTATION_SIZE;
  } // When we render new content, measure to see if we need to shrink indentation to fit it.


  Object(external_react_["useEffect"])(() => {
    if (divRef.current !== null) {
      updateIndentationSizeVar(divRef.current, cachedChildWidths, indentationSizeRef, prevListWidthRef);
    }
  }); // This style override enables the background color to fill the full visible width,
  // when combined with the CSS tweaks in Element.
  // A lot of options were considered; this seemed the one that requires the least code.
  // See https://github.com/bvaughn/react-devtools-experimental/issues/9

  return /*#__PURE__*/external_react_["createElement"]("div", Tree_extends({
    className: Tree_default.a.InnerElementType,
    ref: divRef,
    style: style
  }, rest), /*#__PURE__*/external_react_["createElement"](SelectedTreeHighlight_SelectedTreeHighlight, null), children);
}

function Loading() {
  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: Tree_default.a.Loading
  }, "Loading...");
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/InspectedElementContext.js
function InspectedElementContext_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function InspectedElementContext_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { InspectedElementContext_ownKeys(Object(source), true).forEach(function (key) { InspectedElementContext_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { InspectedElementContext_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function InspectedElementContext_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function InspectedElementContext_slicedToArray(arr, i) { return InspectedElementContext_arrayWithHoles(arr) || InspectedElementContext_iterableToArrayLimit(arr, i) || InspectedElementContext_unsupportedIterableToArray(arr, i) || InspectedElementContext_nonIterableRest(); }

function InspectedElementContext_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function InspectedElementContext_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return InspectedElementContext_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return InspectedElementContext_arrayLikeToArray(o, minLen); }

function InspectedElementContext_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function InspectedElementContext_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function InspectedElementContext_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */








const InspectedElementContext = /*#__PURE__*/Object(external_react_["createContext"])(null);
InspectedElementContext.displayName = 'InspectedElementContext';
const InspectedElementContext_inProgressRequests = new WeakMap();
const InspectedElementContext_resource = createResource(element => {
  const request = InspectedElementContext_inProgressRequests.get(element);

  if (request != null) {
    return request.promise;
  }

  let resolveFn = null;
  const promise = new Promise(resolve => {
    resolveFn = resolve;
  });
  InspectedElementContext_inProgressRequests.set(element, {
    promise,
    resolveFn
  });
  return promise;
}, element => element, {
  useWeakMap: true
});

function InspectedElementContextController({
  children
}) {
  const bridge = Object(external_react_["useContext"])(BridgeContext);
  const store = Object(external_react_["useContext"])(StoreContext);
  const storeAsGlobalCount = Object(external_react_["useRef"])(1); // Ask the backend to store the value at the specified path as a global variable.

  const storeAsGlobal = Object(external_react_["useCallback"])((id, path) => {
    const rendererID = store.getRendererIDForElement(id);

    if (rendererID !== null) {
      bridge.send('storeAsGlobal', {
        count: storeAsGlobalCount.current++,
        id,
        path,
        rendererID
      });
    }
  }, [bridge, store]); // Ask the backend to copy the specified path to the clipboard.

  const copyInspectedElementPath = Object(external_react_["useCallback"])((id, path) => {
    const rendererID = store.getRendererIDForElement(id);

    if (rendererID !== null) {
      bridge.send('copyElementPath', {
        id,
        path,
        rendererID
      });
    }
  }, [bridge, store]); // Ask the backend to fill in a "dehydrated" path; this will result in a "inspectedElement".

  const getInspectedElementPath = Object(external_react_["useCallback"])((id, path) => {
    const rendererID = store.getRendererIDForElement(id);

    if (rendererID !== null) {
      bridge.send('inspectElement', {
        id,
        path,
        rendererID
      });
    }
  }, [bridge, store]);
  const getInspectedElement = Object(external_react_["useCallback"])(id => {
    const element = store.getElementByID(id);

    if (element !== null) {
      return InspectedElementContext_resource.read(element);
    } else {
      return null;
    }
  }, [store]); // It's very important that this context consumes selectedElementID and not inspectedElementID.
  // Otherwise the effect that sends the "inspect" message across the bridge-
  // would itself be blocked by the same render that suspends (waiting for the data).

  const _useContext = Object(external_react_["useContext"])(TreeStateContext),
        selectedElementID = _useContext.selectedElementID;

  const _useState = Object(external_react_["useState"])(null),
        _useState2 = InspectedElementContext_slicedToArray(_useState, 2),
        currentlyInspectedElement = _useState2[0],
        setCurrentlyInspectedElement = _useState2[1]; // This effect handler invalidates the suspense cache and schedules rendering updates with React.


  Object(external_react_["useEffect"])(() => {
    const onInspectedElement = data => {
      const id = data.id;
      let element;

      switch (data.type) {
        case 'no-change':
        case 'not-found':
          // No-op
          break;

        case 'hydrated-path':
          // Merge new data into previous object and invalidate cache
          element = store.getElementByID(id);

          if (element !== null) {
            if (currentlyInspectedElement != null) {
              const value = hydrateHelper(data.value, data.path);

              const inspectedElement = InspectedElementContext_objectSpread({}, currentlyInspectedElement);

              Object(hydration["b" /* fillInPath */])(inspectedElement, data.value, data.path, value);
              InspectedElementContext_resource.write(element, inspectedElement); // Schedule update with React if the currently-selected element has been invalidated.

              if (id === selectedElementID) {
                setCurrentlyInspectedElement(inspectedElement);
              }
            }
          }

          break;

        case 'full-data':
          const _ref = data.value,
                canEditFunctionProps = _ref.canEditFunctionProps,
                canEditFunctionPropsDeletePaths = _ref.canEditFunctionPropsDeletePaths,
                canEditFunctionPropsRenamePaths = _ref.canEditFunctionPropsRenamePaths,
                canEditHooks = _ref.canEditHooks,
                canEditHooksAndDeletePaths = _ref.canEditHooksAndDeletePaths,
                canEditHooksAndRenamePaths = _ref.canEditHooksAndRenamePaths,
                canToggleSuspense = _ref.canToggleSuspense,
                canViewSource = _ref.canViewSource,
                hasLegacyContext = _ref.hasLegacyContext,
                source = _ref.source,
                type = _ref.type,
                owners = _ref.owners,
                context = _ref.context,
                hooks = _ref.hooks,
                props = _ref.props,
                rendererPackageName = _ref.rendererPackageName,
                rendererVersion = _ref.rendererVersion,
                rootType = _ref.rootType,
                state = _ref.state,
                key = _ref.key;
          const inspectedElement = {
            canEditFunctionProps,
            canEditFunctionPropsDeletePaths,
            canEditFunctionPropsRenamePaths,
            canEditHooks,
            canEditHooksAndDeletePaths,
            canEditHooksAndRenamePaths,
            canToggleSuspense,
            canViewSource,
            hasLegacyContext,
            id,
            key,
            rendererPackageName,
            rendererVersion,
            rootType,
            source,
            type,
            owners: owners === null ? null : owners.map(owner => {
              const _separateDisplayNameA = Object(utils["p" /* separateDisplayNameAndHOCs */])(owner.displayName, owner.type),
                    _separateDisplayNameA2 = InspectedElementContext_slicedToArray(_separateDisplayNameA, 2),
                    displayName = _separateDisplayNameA2[0],
                    hocDisplayNames = _separateDisplayNameA2[1];

              return InspectedElementContext_objectSpread(InspectedElementContext_objectSpread({}, owner), {}, {
                displayName,
                hocDisplayNames
              });
            }),
            context: hydrateHelper(context),
            hooks: hydrateHelper(hooks),
            props: hydrateHelper(props),
            state: hydrateHelper(state)
          };
          element = store.getElementByID(id);

          if (element !== null) {
            const request = InspectedElementContext_inProgressRequests.get(element);

            if (request != null) {
              InspectedElementContext_inProgressRequests.delete(element);
              Object(external_react_dom_["unstable_batchedUpdates"])(() => {
                request.resolveFn(inspectedElement);
                setCurrentlyInspectedElement(inspectedElement);
              });
            } else {
              InspectedElementContext_resource.write(element, inspectedElement); // Schedule update with React if the currently-selected element has been invalidated.

              if (id === selectedElementID) {
                setCurrentlyInspectedElement(inspectedElement);
              }
            }
          }

          break;

        default:
          break;
      }
    };

    bridge.addListener('inspectedElement', onInspectedElement);
    return () => bridge.removeListener('inspectedElement', onInspectedElement);
  }, [bridge, currentlyInspectedElement, selectedElementID, store]); // This effect handler polls for updates on the currently selected element.

  Object(external_react_["useEffect"])(() => {
    if (selectedElementID === null) {
      return () => {};
    }

    const rendererID = store.getRendererIDForElement(selectedElementID);
    let timeoutID = null;

    const sendRequest = () => {
      timeoutID = null;

      if (rendererID !== null) {
        bridge.send('inspectElement', {
          id: selectedElementID,
          rendererID
        });
      }
    }; // Send the initial inspection request.
    // We'll poll for an update in the response handler below.


    sendRequest();

    const onInspectedElement = data => {
      // If this is the element we requested, wait a little bit and then ask for another update.
      if (data.id === selectedElementID) {
        switch (data.type) {
          case 'no-change':
          case 'full-data':
          case 'hydrated-path':
            if (timeoutID !== null) {
              clearTimeout(timeoutID);
            }

            timeoutID = setTimeout(sendRequest, 1000);
            break;

          default:
            break;
        }
      }
    };

    bridge.addListener('inspectedElement', onInspectedElement);
    return () => {
      bridge.removeListener('inspectedElement', onInspectedElement);

      if (timeoutID !== null) {
        clearTimeout(timeoutID);
      }
    };
  }, [bridge, selectedElementID, store]);
  const value = Object(external_react_["useMemo"])(() => ({
    copyInspectedElementPath,
    getInspectedElement,
    getInspectedElementPath,
    storeAsGlobal
  }), // InspectedElement is used to invalidate the cache and schedule an update with React.
  [copyInspectedElementPath, currentlyInspectedElement, getInspectedElement, getInspectedElementPath, storeAsGlobal]);
  return /*#__PURE__*/external_react_["createElement"](InspectedElementContext.Provider, {
    value: value
  }, children);
}

function hydrateHelper(dehydratedData, path) {
  if (dehydratedData !== null) {
    const cleaned = dehydratedData.cleaned,
          data = dehydratedData.data,
          unserializable = dehydratedData.unserializable;

    if (path) {
      const length = path.length;

      if (length > 0) {
        // Hydration helper requires full paths, but inspection dehydrates with relative paths.
        // In that event it's important that we adjust the "cleaned" paths to match.
        return Object(hydration["c" /* hydrate */])(data, cleaned.map(cleanedPath => cleanedPath.slice(length)), unserializable.map(unserializablePath => unserializablePath.slice(length)));
      }
    }

    return Object(hydration["c" /* hydrate */])(data, cleaned, unserializable);
  } else {
    return null;
  }
}


// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/ErrorBoundary.css
var views_ErrorBoundary = __webpack_require__(29);
var ErrorBoundary_default = /*#__PURE__*/__webpack_require__.n(views_ErrorBoundary);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/ErrorBoundary.js
function ErrorBoundary_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */







const InitialState = {
  callStack: null,
  componentStack: null,
  errorMessage: null,
  hasError: false
};
class ErrorBoundary_ErrorBoundary extends external_react_["Component"] {
  constructor(...args) {
    super(...args);

    ErrorBoundary_defineProperty(this, "state", InitialState);

    ErrorBoundary_defineProperty(this, "handleRetry", () => {
      const _this$props = this.props,
            onRetry = _this$props.onRetry,
            store = _this$props.store;

      if (typeof onRetry === 'function') {
        onRetry(store);
      }

      this.setState(InitialState);
    });
  }

  componentDidCatch(error, {
    componentStack
  }) {
    const errorMessage = typeof error === 'object' && error.hasOwnProperty('message') ? error.message : error;
    const callStack = typeof error === 'object' && error.hasOwnProperty('stack') ? error.stack.split('\n').slice(1).join('\n') : null;
    this.setState({
      callStack,
      componentStack,
      errorMessage,
      hasError: true
    });
  }

  render() {
    const children = this.props.children;
    const _this$state = this.state,
          callStack = _this$state.callStack,
          componentStack = _this$state.componentStack,
          errorMessage = _this$state.errorMessage,
          hasError = _this$state.hasError;
    let bugURL = "https://github.com/facebook/react";

    if (bugURL) {
      const title = `Error: "${errorMessage || ''}"`;
      const label = 'Component: Developer Tools';
      let body = 'Describe what you were doing when the bug occurred:';
      body += '\n1. ';
      body += '\n2. ';
      body += '\n3. ';
      body += '\n\n---------------------------------------------';
      body += '\nPlease do not remove the text below this line';
      body += '\n---------------------------------------------';
      body += `\n\nDevTools version: ${"4.10.1-3a8c04e3b2" || false}`;

      if (callStack) {
        body += `\n\nCall stack: ${callStack.trim()}`;
      }

      if (componentStack) {
        body += `\n\nComponent stack: ${componentStack.trim()}`;
      }

      bugURL += `/issues/new?labels=${encodeURI(label)}&title=${encodeURI(title)}&body=${encodeURI(body)}`;
    }

    if (hasError) {
      return /*#__PURE__*/external_react_["createElement"]("div", {
        className: ErrorBoundary_default.a.ErrorBoundary
      }, /*#__PURE__*/external_react_["createElement"]("div", {
        className: ErrorBoundary_default.a.Header
      }, "Uncaught Error: ", errorMessage || ''), /*#__PURE__*/external_react_["createElement"]("div", {
        className: ErrorBoundary_default.a.IconAndLinkRow
      }, /*#__PURE__*/external_react_["createElement"](Button_Button, {
        className: ErrorBoundary_default.a.RetryButton,
        title: "Retry",
        onClick: this.handleRetry
      }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
        className: ErrorBoundary_default.a.RetryIcon,
        type: "reload"
      }), "Retry"), bugURL && /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"](Icon_Icon, {
        className: ErrorBoundary_default.a.ReportIcon,
        type: "bug"
      }), /*#__PURE__*/external_react_["createElement"]("a", {
        className: ErrorBoundary_default.a.ReportLink,
        href: bugURL,
        rel: "noopener noreferrer",
        target: "_blank",
        title: "Report bug"
      }, "Report this issue"))), !!callStack && /*#__PURE__*/external_react_["createElement"]("div", {
        className: ErrorBoundary_default.a.Stack
      }, "The error was thrown ", callStack.trim()), !!componentStack && /*#__PURE__*/external_react_["createElement"]("div", {
        className: ErrorBoundary_default.a.Stack
      }, "The error occurred ", componentStack.trim()));
    }

    return children;
  }

}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/portaledContent.js
function portaledContent_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = portaledContent_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function portaledContent_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






function portaledContent(Component, onErrorRetry) {
  return function PortaledContent(_ref) {
    let portalContainer = _ref.portalContainer,
        rest = portaledContent_objectWithoutProperties(_ref, ["portalContainer"]);

    const store = Object(external_react_["useContext"])(StoreContext);
    const children = /*#__PURE__*/external_react_["createElement"](ErrorBoundary_ErrorBoundary, {
      store: store,
      onRetry: onErrorRetry
    }, /*#__PURE__*/external_react_["createElement"](Component, rest));
    return portalContainer != null ? /*#__PURE__*/Object(external_react_dom_["createPortal"])(children, portalContainer) : children;
  };
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/ModalDialog.css
var ModalDialog = __webpack_require__(42);
var ModalDialog_default = /*#__PURE__*/__webpack_require__.n(ModalDialog);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/ModalDialog.js
function ModalDialog_slicedToArray(arr, i) { return ModalDialog_arrayWithHoles(arr) || ModalDialog_iterableToArrayLimit(arr, i) || ModalDialog_unsupportedIterableToArray(arr, i) || ModalDialog_nonIterableRest(); }

function ModalDialog_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function ModalDialog_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ModalDialog_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ModalDialog_arrayLikeToArray(o, minLen); }

function ModalDialog_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function ModalDialog_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function ModalDialog_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */





const ModalDialogContext = /*#__PURE__*/Object(external_react_["createContext"])(null);
ModalDialogContext.displayName = 'ModalDialogContext';

function ModalDialog_dialogReducer(state, action) {
  switch (action.type) {
    case 'HIDE':
      return {
        canBeDismissed: true,
        content: null,
        isVisible: false,
        title: null
      };

    case 'SHOW':
      return {
        canBeDismissed: action.canBeDismissed !== false,
        content: action.content,
        isVisible: true,
        title: action.title || null
      };

    default:
      throw new Error(`Invalid action "${action.type}"`);
  }
}

function ModalDialogContextController({
  children
}) {
  const _useReducer = Object(external_react_["useReducer"])(ModalDialog_dialogReducer, {
    canBeDismissed: true,
    content: null,
    isVisible: false,
    title: null
  }),
        _useReducer2 = ModalDialog_slicedToArray(_useReducer, 2),
        state = _useReducer2[0],
        dispatch = _useReducer2[1];

  const value = Object(external_react_["useMemo"])(() => ({
    canBeDismissed: state.canBeDismissed,
    content: state.content,
    isVisible: state.isVisible,
    title: state.title,
    dispatch
  }), [state, dispatch]);
  return /*#__PURE__*/external_react_["createElement"](ModalDialogContext.Provider, {
    value: value
  }, children);
}

function ModalDialog_ModalDialog(_) {
  const _useContext = Object(external_react_["useContext"])(ModalDialogContext),
        isVisible = _useContext.isVisible;

  return isVisible ? /*#__PURE__*/external_react_["createElement"](ModalDialogImpl, null) : null;
}

function ModalDialogImpl(_) {
  const _useContext2 = Object(external_react_["useContext"])(ModalDialogContext),
        canBeDismissed = _useContext2.canBeDismissed,
        content = _useContext2.content,
        dispatch = _useContext2.dispatch,
        title = _useContext2.title;

  const dismissModal = Object(external_react_["useCallback"])(() => {
    if (canBeDismissed) {
      dispatch({
        type: 'HIDE'
      });
    }
  }, [canBeDismissed, dispatch]);
  const dialogRef = Object(external_react_["useRef"])(null); // It's important to trap click events within the dialog,
  // so the dismiss hook will use it for click hit detection.
  // Because multiple tabs may be showing this ModalDialog,
  // the normal `dialog.contains(target)` check would fail on a background tab.

  useModalDismissSignal(dialogRef, dismissModal, false); // Clicks on the dialog should not bubble.
  // This way we can dismiss by listening to clicks on the background.

  const handleDialogClick = event => {
    event.stopPropagation(); // It is important that we don't also prevent default,
    // or clicks within the dialog (e.g. on links) won't work.
  };

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: ModalDialog_default.a.Background,
    onClick: dismissModal
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    ref: dialogRef,
    className: ModalDialog_default.a.Dialog,
    onClick: handleDialogClick
  }, title !== null && /*#__PURE__*/external_react_["createElement"]("div", {
    className: ModalDialog_default.a.Title
  }, title), content, canBeDismissed && /*#__PURE__*/external_react_["createElement"]("div", {
    className: ModalDialog_default.a.Buttons
  }, /*#__PURE__*/external_react_["createElement"](Button_Button, {
    autoFocus: true,
    className: ModalDialog_default.a.Button,
    onClick: dismissModal
  }, "Okay"))));
}


// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/ViewElementSourceContext.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

const ViewElementSourceContext = /*#__PURE__*/Object(external_react_["createContext"])(null);
ViewElementSourceContext.displayName = 'ViewElementSourceContext';
/* harmony default export */ var Components_ViewElementSourceContext = (ViewElementSourceContext);
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/CannotSuspendWarningMessage.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */




function CannotSuspendWarningMessage() {
  const store = Object(external_react_["useContext"])(StoreContext);
  const areSuspenseElementsHidden = !!store.componentFilters.find(filter => filter.type === types["b" /* ComponentFilterElementType */] && filter.value === types["n" /* ElementTypeSuspense */] && filter.isEnabled); // Has the user filtered out Suspense nodes from the tree?
  // If so, the selected element might actually be in a Suspense tree after all.

  if (areSuspenseElementsHidden) {
    return /*#__PURE__*/external_react_["createElement"]("div", null, "Suspended state cannot be toggled while Suspense components are hidden. Disable the filter and try again.");
  } else {
    return /*#__PURE__*/external_react_["createElement"]("div", null, "The selected element is not within a Suspense container. Suspending it would cause an error.");
  }
}
// EXTERNAL MODULE: /Users/bvaughn/Documents/git/react.alt2/node_modules/clipboard-js/clipboard.js
var clipboard = __webpack_require__(17);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/ContextMenu/Contexts.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

const idToShowFnMap = new Map();
const idToHideFnMap = new Map();
let currentHideFn = null;

function Contexts_hideMenu() {
  if (typeof currentHideFn === 'function') {
    currentHideFn();
  }
}

function Contexts_showMenu({
  data,
  id,
  pageX,
  pageY
}) {
  const showFn = idToShowFnMap.get(id);

  if (typeof showFn === 'function') {
    currentHideFn = idToHideFnMap.get(id);
    showFn({
      data,
      pageX,
      pageY
    });
  }
}

function Contexts_registerMenu(id, showFn, hideFn) {
  if (idToShowFnMap.has(id)) {
    throw Error(`Context menu with id "${id}" already registered.`);
  }

  idToShowFnMap.set(id, showFn);
  idToHideFnMap.set(id, hideFn);
  return function unregisterMenu() {
    idToShowFnMap.delete(id);
    idToHideFnMap.delete(id);
  };
}

const RegistryContext = /*#__PURE__*/Object(external_react_["createContext"])({
  hideMenu: Contexts_hideMenu,
  showMenu: Contexts_showMenu,
  registerMenu: Contexts_registerMenu
});
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/ContextMenu/ContextMenu.css
var ContextMenu = __webpack_require__(81);
var ContextMenu_default = /*#__PURE__*/__webpack_require__.n(ContextMenu);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/ContextMenu/ContextMenu.js
function ContextMenu_slicedToArray(arr, i) { return ContextMenu_arrayWithHoles(arr) || ContextMenu_iterableToArrayLimit(arr, i) || ContextMenu_unsupportedIterableToArray(arr, i) || ContextMenu_nonIterableRest(); }

function ContextMenu_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function ContextMenu_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ContextMenu_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ContextMenu_arrayLikeToArray(o, minLen); }

function ContextMenu_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function ContextMenu_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function ContextMenu_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






function repositionToFit(element, pageX, pageY) {
  const ownerWindow = element.ownerDocument.defaultView;

  if (element !== null) {
    if (pageY + element.offsetHeight >= ownerWindow.innerHeight) {
      if (pageY - element.offsetHeight > 0) {
        element.style.top = `${pageY - element.offsetHeight}px`;
      } else {
        element.style.top = '0px';
      }
    } else {
      element.style.top = `${pageY}px`;
    }

    if (pageX + element.offsetWidth >= ownerWindow.innerWidth) {
      if (pageX - element.offsetWidth > 0) {
        element.style.left = `${pageX - element.offsetWidth}px`;
      } else {
        element.style.left = '0px';
      }
    } else {
      element.style.left = `${pageX}px`;
    }
  }
}

const HIDDEN_STATE = {
  data: null,
  isVisible: false,
  pageX: 0,
  pageY: 0
};
function ContextMenu_ContextMenu({
  children,
  id
}) {
  const _useContext = Object(external_react_["useContext"])(RegistryContext),
        registerMenu = _useContext.registerMenu;

  const _useState = Object(external_react_["useState"])(HIDDEN_STATE),
        _useState2 = ContextMenu_slicedToArray(_useState, 2),
        state = _useState2[0],
        setState = _useState2[1];

  const bodyAccessorRef = Object(external_react_["useRef"])(null);
  const containerRef = Object(external_react_["useRef"])(null);
  const menuRef = Object(external_react_["useRef"])(null);
  Object(external_react_["useEffect"])(() => {
    const element = bodyAccessorRef.current;

    if (element !== null) {
      const ownerDocument = element.ownerDocument;
      containerRef.current = ownerDocument.createElement('div');
      ownerDocument.body.appendChild(containerRef.current);
      return () => {
        ownerDocument.body.removeChild(containerRef.current);
      };
    }
  }, []);
  Object(external_react_["useEffect"])(() => {
    const showMenu = ({
      data,
      pageX,
      pageY
    }) => {
      setState({
        data,
        isVisible: true,
        pageX,
        pageY
      });
    };

    const hideMenu = () => setState(HIDDEN_STATE);

    return registerMenu(id, showMenu, hideMenu);
  }, [id]);
  Object(external_react_["useLayoutEffect"])(() => {
    if (!state.isVisible) {
      return;
    }

    const menu = menuRef.current;
    const container = containerRef.current;

    if (container !== null) {
      const hideUnlessContains = event => {
        if (!menu.contains(event.target)) {
          setState(HIDDEN_STATE);
        }
      };

      const hide = event => {
        setState(HIDDEN_STATE);
      };

      const ownerDocument = container.ownerDocument;
      ownerDocument.addEventListener('mousedown', hideUnlessContains);
      ownerDocument.addEventListener('touchstart', hideUnlessContains);
      ownerDocument.addEventListener('keydown', hideUnlessContains);
      const ownerWindow = ownerDocument.defaultView;
      ownerWindow.addEventListener('resize', hide);
      repositionToFit(menu, state.pageX, state.pageY);
      return () => {
        ownerDocument.removeEventListener('mousedown', hideUnlessContains);
        ownerDocument.removeEventListener('touchstart', hideUnlessContains);
        ownerDocument.removeEventListener('keydown', hideUnlessContains);
        ownerWindow.removeEventListener('resize', hide);
      };
    }
  }, [state]);

  if (!state.isVisible) {
    return /*#__PURE__*/external_react_["createElement"]("div", {
      ref: bodyAccessorRef
    });
  } else {
    const container = containerRef.current;

    if (container !== null) {
      return /*#__PURE__*/Object(external_react_dom_["createPortal"])( /*#__PURE__*/external_react_["createElement"]("div", {
        ref: menuRef,
        className: ContextMenu_default.a.ContextMenu
      }, children(state.data)), container);
    } else {
      return null;
    }
  }
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/ContextMenu/ContextMenuItem.css
var ContextMenuItem = __webpack_require__(82);
var ContextMenuItem_default = /*#__PURE__*/__webpack_require__.n(ContextMenuItem);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/ContextMenu/ContextMenuItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */




function ContextMenuItem_ContextMenuItem({
  children,
  onClick,
  title
}) {
  const _useContext = Object(external_react_["useContext"])(RegistryContext),
        hideMenu = _useContext.hideMenu;

  const handleClick = event => {
    onClick();
    hideMenu();
  };

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: ContextMenuItem_default.a.ContextMenuItem,
    onClick: handleClick,
    onTouchEnd: handleClick
  }, children);
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/HocBadges.css
var HocBadges = __webpack_require__(72);
var HocBadges_default = /*#__PURE__*/__webpack_require__.n(HocBadges);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/HocBadges.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


function HocBadges_HocBadges({
  element
}) {
  const _ref = element,
        hocDisplayNames = _ref.hocDisplayNames;

  if (hocDisplayNames === null) {
    return null;
  }

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: HocBadges_default.a.HocBadges
  }, hocDisplayNames !== null && hocDisplayNames.map(hocDisplayName => /*#__PURE__*/external_react_["createElement"]("div", {
    key: hocDisplayName,
    className: HocBadges_default.a.Badge
  }, hocDisplayName)));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/NativeStyleEditor/AutoSizeInput.css
var AutoSizeInput = __webpack_require__(83);
var AutoSizeInput_default = /*#__PURE__*/__webpack_require__.n(AutoSizeInput);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/NativeStyleEditor/AutoSizeInput.js
function AutoSizeInput_extends() { AutoSizeInput_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return AutoSizeInput_extends.apply(this, arguments); }

function AutoSizeInput_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = AutoSizeInput_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function AutoSizeInput_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


function AutoSizeInput_AutoSizeInput(_ref) {
  let className = _ref.className,
      onFocus = _ref.onFocus,
      _ref$placeholder = _ref.placeholder,
      placeholder = _ref$placeholder === void 0 ? '' : _ref$placeholder,
      value = _ref.value,
      rest = AutoSizeInput_objectWithoutProperties(_ref, ["className", "onFocus", "placeholder", "value"]);

  const onFocusWrapper = event => {
    const input = event.target;

    if (input !== null) {
      input.selectionStart = 0;
      input.selectionEnd = value.length;
    }

    if (typeof onFocus === 'function') {
      onFocus(event);
    }
  };

  const isEmpty = value === '' || value === '""';
  return /*#__PURE__*/external_react_["createElement"]("input", AutoSizeInput_extends({
    className: [AutoSizeInput_default.a.Input, className].join(' '),
    onFocus: onFocusWrapper,
    placeholder: placeholder,
    style: {
      width: `calc(${isEmpty ? placeholder.length : value.length}ch + 1px)`
    },
    value: isEmpty ? '' : value
  }, rest));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/EditableName.css
var EditableName = __webpack_require__(84);
var EditableName_default = /*#__PURE__*/__webpack_require__.n(EditableName);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/EditableName.js
function EditableName_slicedToArray(arr, i) { return EditableName_arrayWithHoles(arr) || EditableName_iterableToArrayLimit(arr, i) || EditableName_unsupportedIterableToArray(arr, i) || EditableName_nonIterableRest(); }

function EditableName_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function EditableName_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return EditableName_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return EditableName_arrayLikeToArray(o, minLen); }

function EditableName_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function EditableName_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function EditableName_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */




function EditableName_EditableName({
  allowEmpty = false,
  allowWhiteSpace = false,
  autoFocus = false,
  className = '',
  initialValue = '',
  overrideName,
  path,
  type
}) {
  const _useState = Object(external_react_["useState"])(initialValue),
        _useState2 = EditableName_slicedToArray(_useState, 2),
        editableName = _useState2[0],
        setEditableName = _useState2[1];

  const _useState3 = Object(external_react_["useState"])(false),
        _useState4 = EditableName_slicedToArray(_useState3, 2),
        isValid = _useState4[0],
        setIsValid = _useState4[1];

  const handleChange = Object(external_react_["useCallback"])(({
    target
  }) => {
    let value = target.value;

    if (!allowWhiteSpace) {
      value = value.trim();
    }

    if (allowEmpty || value !== '') {
      setIsValid(true);
    } else {
      setIsValid(false);
    }

    setEditableName(value);
  }, [overrideName]);
  const handleKeyDown = Object(external_react_["useCallback"])(event => {
    // Prevent keydown events from e.g. change selected element in the tree
    event.stopPropagation();

    switch (event.key) {
      case 'Enter':
      case 'Tab':
        if (isValid) {
          const basePath = path.slice(0, path.length - 1);
          overrideName([...basePath, initialValue], [...basePath, editableName]);
        }

        break;

      case 'Escape':
        setEditableName(initialValue);
        break;

      default:
        break;
    }
  }, [editableName, setEditableName, isValid, initialValue, overrideName]);
  return /*#__PURE__*/external_react_["createElement"](AutoSizeInput_AutoSizeInput, {
    autoFocus: autoFocus,
    className: [EditableName_default.a.Input, className].join(' '),
    onChange: handleChange,
    onKeyDown: handleKeyDown,
    placeholder: "new entry",
    type: "text",
    value: editableName
  });
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/EditableValue.css
var EditableValue = __webpack_require__(56);
var EditableValue_default = /*#__PURE__*/__webpack_require__.n(EditableValue);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/EditableValue.js
function EditableValue_slicedToArray(arr, i) { return EditableValue_arrayWithHoles(arr) || EditableValue_iterableToArrayLimit(arr, i) || EditableValue_unsupportedIterableToArray(arr, i) || EditableValue_nonIterableRest(); }

function EditableValue_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function EditableValue_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return EditableValue_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return EditableValue_arrayLikeToArray(o, minLen); }

function EditableValue_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function EditableValue_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function EditableValue_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */




function EditableValue_EditableValue({
  className = '',
  overrideValue,
  path,
  value
}) {
  const _useEditableValue = useEditableValue(value),
        _useEditableValue2 = EditableValue_slicedToArray(_useEditableValue, 2),
        state = _useEditableValue2[0],
        dispatch = _useEditableValue2[1];

  const editableValue = state.editableValue,
        hasPendingChanges = state.hasPendingChanges,
        isValid = state.isValid,
        parsedValue = state.parsedValue;

  const reset = () => dispatch({
    type: 'RESET',
    externalValue: value
  });

  const handleChange = ({
    target
  }) => dispatch({
    type: 'UPDATE',
    editableValue: target.value,
    externalValue: value
  });

  const handleCheckBoxToggle = ({
    target
  }) => {
    dispatch({
      type: 'UPDATE',
      editableValue: target.checked,
      externalValue: value
    }); // Unlike <input type="text"> which has both an onChange and an onBlur,
    // <input type="checkbox"> updates state *and* applies changes in a single event.
    // So we read from target.checked rather than parsedValue (which has not yet updated).
    // We also don't check isValid (because that hasn't changed yet either);
    // we don't need to check it anyway, since target.checked is always a boolean.

    overrideValue(path, target.checked);
  };

  const handleKeyDown = event => {
    // Prevent keydown events from e.g. change selected element in the tree
    event.stopPropagation();

    switch (event.key) {
      case 'Enter':
        applyChanges();
        break;

      case 'Escape':
        reset();
        break;

      default:
        break;
    }
  };

  const applyChanges = () => {
    if (isValid && hasPendingChanges) {
      overrideValue(path, parsedValue);
    }
  };

  let placeholder = '';

  if (editableValue === undefined) {
    placeholder = '(undefined)';
  } else {
    placeholder = 'Enter valid JSON';
  }

  const isBool = parsedValue === true || parsedValue === false;
  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("input", {
    autoComplete: "new-password",
    className: `${isValid ? EditableValue_default.a.Input : EditableValue_default.a.Invalid} ${className}`,
    onBlur: applyChanges,
    onChange: handleChange,
    onKeyDown: handleKeyDown,
    placeholder: placeholder,
    type: "text",
    value: editableValue
  }), isBool && /*#__PURE__*/external_react_["createElement"]("input", {
    className: EditableValue_default.a.Checkbox,
    checked: parsedValue,
    type: "checkbox",
    onChange: handleCheckBoxToggle
  }));
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/utils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * Converts nested hooks paths to the format expected by the backend.
 * e.g. [''] => ['']
 * e.g. [1, 'value', ...] => [...]
 * e.g. [2, 'subhooks', 1, 'value', ...] => [...]
 * e.g. [1, 'subhooks', 3, 'subhooks', 2, 'value', ...] => [...]
 */
function parseHookPathForEdit(path) {
  let index = 0;

  for (let i = 0; i < path.length; i++) {
    if (path[i] === 'value') {
      index = i + 1;
      break;
    }
  }

  return path.slice(index);
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/NewArrayValue.css
var NewArrayValue = __webpack_require__(57);
var NewArrayValue_default = /*#__PURE__*/__webpack_require__.n(NewArrayValue);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/NewArrayValue.js
function NewArrayValue_slicedToArray(arr, i) { return NewArrayValue_arrayWithHoles(arr) || NewArrayValue_iterableToArrayLimit(arr, i) || NewArrayValue_unsupportedIterableToArray(arr, i) || NewArrayValue_nonIterableRest(); }

function NewArrayValue_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function NewArrayValue_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return NewArrayValue_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return NewArrayValue_arrayLikeToArray(o, minLen); }

function NewArrayValue_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function NewArrayValue_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function NewArrayValue_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */







function NewArrayValue_NewArrayValue({
  bridge,
  depth,
  hidden,
  hookID,
  index,
  inspectedElement,
  path,
  store,
  type
}) {
  const _useState = Object(external_react_["useState"])(0),
        _useState2 = NewArrayValue_slicedToArray(_useState, 2),
        key = _useState2[0],
        setKey = _useState2[1];

  const _useState3 = Object(external_react_["useState"])(false),
        _useState4 = NewArrayValue_slicedToArray(_useState3, 2),
        isInvalid = _useState4[0],
        setIsInvalid = _useState4[1]; // This is a bit of an unusual usage of the EditableName component,
  // but otherwise it acts the way we want for a new Array entry.


  const overrideName = (oldPath, newPath) => {
    const value = newPath[newPath.length - 1];
    let parsedValue;
    let newIsInvalid = true;

    try {
      parsedValue = smartParse(value);
      newIsInvalid = false;
    } catch (error) {}

    if (isInvalid !== newIsInvalid) {
      setIsInvalid(newIsInvalid);
    }

    if (!newIsInvalid) {
      setKey(key + 1);
      const id = inspectedElement.id;
      const rendererID = store.getRendererIDForElement(id);

      if (rendererID !== null) {
        let basePath = path;

        if (hookID != null) {
          basePath = parseHookPathForEdit(basePath);
        }

        bridge.send('overrideValueAtPath', {
          type,
          hookID,
          id,
          path: [...basePath, index],
          rendererID,
          value: parsedValue
        });
      }
    }
  };

  return /*#__PURE__*/external_react_["createElement"]("div", {
    key: key,
    hidden: hidden,
    style: {
      paddingLeft: `${(depth - 1) * 0.75}rem`
    }
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: NewArrayValue_default.a.NewArrayValue
  }, /*#__PURE__*/external_react_["createElement"](EditableName_EditableName, {
    allowWhiteSpace: true,
    autoFocus: key > 0,
    className: [NewArrayValue_default.a.EditableName, isInvalid && NewArrayValue_default.a.Invalid].join(' '),
    initialValue: "",
    overrideName: overrideName,
    path: path
  })));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/NewKeyValue.css
var NewKeyValue = __webpack_require__(58);
var NewKeyValue_default = /*#__PURE__*/__webpack_require__.n(NewKeyValue);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/NewKeyValue.js
function NewKeyValue_slicedToArray(arr, i) { return NewKeyValue_arrayWithHoles(arr) || NewKeyValue_iterableToArrayLimit(arr, i) || NewKeyValue_unsupportedIterableToArray(arr, i) || NewKeyValue_nonIterableRest(); }

function NewKeyValue_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function NewKeyValue_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return NewKeyValue_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return NewKeyValue_arrayLikeToArray(o, minLen); }

function NewKeyValue_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function NewKeyValue_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function NewKeyValue_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */







function NewKeyValue_NewKeyValue({
  bridge,
  depth,
  hidden,
  hookID,
  inspectedElement,
  path,
  store,
  type
}) {
  const _useState = Object(external_react_["useState"])(0),
        _useState2 = NewKeyValue_slicedToArray(_useState, 2),
        newPropKey = _useState2[0],
        setNewPropKey = _useState2[1];

  const _useState3 = Object(external_react_["useState"])(''),
        _useState4 = NewKeyValue_slicedToArray(_useState3, 2),
        newPropName = _useState4[0],
        setNewPropName = _useState4[1];

  const overrideNewEntryName = (oldPath, newPath) => {
    setNewPropName(newPath[newPath.length - 1]);
  };

  const overrideNewEntryValue = (newPath, value) => {
    if (!newPropName) {
      return;
    }

    setNewPropName('');
    setNewPropKey(newPropKey + 1);
    const id = inspectedElement.id;
    const rendererID = store.getRendererIDForElement(id);

    if (rendererID !== null) {
      let basePath = newPath;

      if (hookID != null) {
        basePath = parseHookPathForEdit(basePath);
      }

      bridge.send('overrideValueAtPath', {
        type,
        hookID,
        id,
        path: basePath,
        rendererID,
        value
      });
    }
  };

  return /*#__PURE__*/external_react_["createElement"]("div", {
    key: newPropKey,
    hidden: hidden,
    style: {
      paddingLeft: `${(depth - 1) * 0.75}rem`
    }
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: NewKeyValue_default.a.NewKeyValue
  }, /*#__PURE__*/external_react_["createElement"](EditableName_EditableName, {
    autoFocus: newPropKey > 0,
    className: NewKeyValue_default.a.EditableName,
    overrideName: overrideNewEntryName,
    path: []
  }), ":\xA0", /*#__PURE__*/external_react_["createElement"](EditableValue_EditableValue, {
    className: NewKeyValue_default.a.EditableValue,
    overrideValue: overrideNewEntryValue,
    path: [...path, newPropName],
    value: ''
  })));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/ExpandCollapseToggle.css
var Components_ExpandCollapseToggle = __webpack_require__(85);
var ExpandCollapseToggle_default = /*#__PURE__*/__webpack_require__.n(Components_ExpandCollapseToggle);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/ExpandCollapseToggle.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */




function ExpandCollapseToggle_ExpandCollapseToggle({
  isOpen,
  setIsOpen
}) {
  return /*#__PURE__*/external_react_["createElement"](Button_Button, {
    className: ExpandCollapseToggle_default.a.ExpandCollapseToggle,
    onClick: () => setIsOpen(prevIsOpen => !prevIsOpen),
    title: `${isOpen ? 'Collapse' : 'Expand'} prop value`
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: isOpen ? 'expanded' : 'collapsed'
  }));
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/ContextMenu/useContextMenu.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


function useContextMenu({
  data,
  id,
  ref
}) {
  const _useContext = Object(external_react_["useContext"])(RegistryContext),
        showMenu = _useContext.showMenu;

  Object(external_react_["useEffect"])(() => {
    if (ref.current !== null) {
      const handleContextMenu = event => {
        event.preventDefault();
        event.stopPropagation();
        const pageX = event.pageX || event.touches && event.touches[0].pageX;
        const pageY = event.pageY || event.touches && event.touches[0].pageY;
        showMenu({
          data,
          id,
          pageX,
          pageY
        });
      };

      const trigger = ref.current;
      trigger.addEventListener('contextmenu', handleContextMenu);
      return () => {
        trigger.removeEventListener('contextmenu', handleContextMenu);
      };
    }
  }, [data, id, showMenu]);
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/KeyValue.css
var KeyValue = __webpack_require__(12);
var KeyValue_default = /*#__PURE__*/__webpack_require__.n(KeyValue);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/KeyValue.js
function KeyValue_slicedToArray(arr, i) { return KeyValue_arrayWithHoles(arr) || KeyValue_iterableToArrayLimit(arr, i) || KeyValue_unsupportedIterableToArray(arr, i) || KeyValue_nonIterableRest(); }

function KeyValue_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function KeyValue_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return KeyValue_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return KeyValue_arrayLikeToArray(o, minLen); }

function KeyValue_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function KeyValue_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function KeyValue_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */















function KeyValue_KeyValue({
  alphaSort,
  bridge,
  canDeletePaths,
  canEditValues,
  canRenamePaths,
  canRenamePathsAtDepth,
  depth,
  getInspectedElementPath,
  inspectedElement,
  isDirectChildOfAnArray,
  hidden,
  hookID,
  name,
  path,
  pathRoot,
  store,
  value
}) {
  const id = inspectedElement.id;

  const _useState = Object(external_react_["useState"])(false),
        _useState2 = KeyValue_slicedToArray(_useState, 2),
        isOpen = _useState2[0],
        setIsOpen = _useState2[1];

  const prevIsOpenRef = Object(external_react_["useRef"])(isOpen);
  const contextMenuTriggerRef = Object(external_react_["useRef"])(null);
  let isInspectable = false;
  let isReadOnly = false;

  if (value !== null && typeof value === 'object') {
    isInspectable = value[hydration["d" /* meta */].inspectable] && value[hydration["d" /* meta */].size] !== 0;
    isReadOnly = value[hydration["d" /* meta */].readonly];
  }

  Object(external_react_["useEffect"])(() => {
    if (isInspectable && isOpen && !prevIsOpenRef.current) {
      getInspectedElementPath(id, [pathRoot, ...path]);
    }

    prevIsOpenRef.current = isOpen;
  }, [getInspectedElementPath, isInspectable, isOpen, path, pathRoot]);

  const toggleIsOpen = () => setIsOpen(prevIsOpen => !prevIsOpen);

  useContextMenu({
    data: {
      path: [pathRoot, ...path],
      type: value !== null && typeof value === 'object' && hasOwnProperty.call(value, hydration["d" /* meta */].type) ? value[hydration["d" /* meta */].type] : typeof value
    },
    id: 'InspectedElement',
    ref: contextMenuTriggerRef
  });
  const dataType = typeof value;
  const isSimpleType = dataType === 'number' || dataType === 'string' || dataType === 'boolean' || value == null;
  const style = {
    paddingLeft: `${(depth - 1) * 0.75}rem`
  };

  const overrideValue = (newPath, newValue) => {
    if (hookID != null) {
      newPath = parseHookPathForEdit(newPath);
    }

    const rendererID = store.getRendererIDForElement(id);

    if (rendererID !== null) {
      bridge.send('overrideValueAtPath', {
        hookID,
        id,
        path: newPath,
        rendererID,
        type: pathRoot,
        value: newValue
      });
    }
  };

  const deletePath = pathToDelete => {
    if (hookID != null) {
      pathToDelete = parseHookPathForEdit(pathToDelete);
    }

    const rendererID = store.getRendererIDForElement(id);

    if (rendererID !== null) {
      bridge.send('deletePath', {
        hookID,
        id,
        path: pathToDelete,
        rendererID,
        type: pathRoot
      });
    }
  };

  const renamePath = (oldPath, newPath) => {
    if (newPath[newPath.length - 1] === '') {
      // Deleting the key suggests an intent to delete the whole path.
      if (canDeletePaths) {
        deletePath(oldPath);
      }
    } else {
      if (hookID != null) {
        oldPath = parseHookPathForEdit(oldPath);
        newPath = parseHookPathForEdit(newPath);
      }

      const rendererID = store.getRendererIDForElement(id);

      if (rendererID !== null) {
        bridge.send('renamePath', {
          hookID,
          id,
          newPath,
          oldPath,
          rendererID,
          type: pathRoot
        });
      }
    }
  }; // TRICKY This is a bit of a hack to account for context and hooks.
  // In these cases, paths can be renamed but only at certain depths.
  // The special "value" wrapper for context shouldn't be editable.
  // Only certain types of hooks should be editable.


  let canRenameTheCurrentPath = canRenamePaths;

  if (canRenameTheCurrentPath && typeof canRenamePathsAtDepth === 'function') {
    canRenameTheCurrentPath = canRenamePathsAtDepth(depth);
  }

  let renderedName;

  if (isDirectChildOfAnArray) {
    if (canDeletePaths) {
      renderedName = /*#__PURE__*/external_react_["createElement"](DeleteToggle, {
        name: name,
        deletePath: deletePath,
        path: path
      });
    } else {
      renderedName = /*#__PURE__*/external_react_["createElement"]("span", {
        className: KeyValue_default.a.Name
      }, name);
    }
  } else if (canRenameTheCurrentPath) {
    renderedName = /*#__PURE__*/external_react_["createElement"](EditableName_EditableName, {
      allowEmpty: canDeletePaths,
      className: KeyValue_default.a.EditableName,
      initialValue: name,
      overrideName: renamePath,
      path: path
    });
  } else {
    renderedName = /*#__PURE__*/external_react_["createElement"]("span", {
      className: KeyValue_default.a.Name
    }, name);
  }

  let children = null;

  if (isSimpleType) {
    let displayValue = value;

    if (dataType === 'string') {
      displayValue = `"${value}"`;
    } else if (dataType === 'boolean') {
      displayValue = value ? 'true' : 'false';
    } else if (value === null) {
      displayValue = 'null';
    } else if (value === undefined) {
      displayValue = 'undefined';
    }

    children = /*#__PURE__*/external_react_["createElement"]("div", {
      key: "root",
      className: KeyValue_default.a.Item,
      hidden: hidden,
      ref: contextMenuTriggerRef,
      style: style
    }, /*#__PURE__*/external_react_["createElement"]("div", {
      className: KeyValue_default.a.ExpandCollapseToggleSpacer
    }), renderedName, /*#__PURE__*/external_react_["createElement"]("div", {
      className: KeyValue_default.a.AfterName
    }, ":"), canEditValues ? /*#__PURE__*/external_react_["createElement"](EditableValue_EditableValue, {
      overrideValue: overrideValue,
      path: path,
      value: value
    }) : /*#__PURE__*/external_react_["createElement"]("span", {
      className: KeyValue_default.a.Value
    }, displayValue));
  } else if (hasOwnProperty.call(value, hydration["d" /* meta */].type) && !hasOwnProperty.call(value, hydration["d" /* meta */].unserializable)) {
    children = /*#__PURE__*/external_react_["createElement"]("div", {
      key: "root",
      className: KeyValue_default.a.Item,
      hidden: hidden,
      ref: contextMenuTriggerRef,
      style: style
    }, isInspectable ? /*#__PURE__*/external_react_["createElement"](ExpandCollapseToggle_ExpandCollapseToggle, {
      isOpen: isOpen,
      setIsOpen: setIsOpen
    }) : /*#__PURE__*/external_react_["createElement"]("div", {
      className: KeyValue_default.a.ExpandCollapseToggleSpacer
    }), renderedName, /*#__PURE__*/external_react_["createElement"]("div", {
      className: KeyValue_default.a.AfterName
    }, ":"), /*#__PURE__*/external_react_["createElement"]("span", {
      className: KeyValue_default.a.Value,
      onClick: isInspectable ? toggleIsOpen : undefined
    }, getMetaValueLabel(value)));
  } else {
    if (Array.isArray(value)) {
      const hasChildren = value.length > 0 || canEditValues;
      const displayName = getMetaValueLabel(value);
      children = value.map((innerValue, index) => /*#__PURE__*/external_react_["createElement"](KeyValue_KeyValue, {
        key: index,
        alphaSort: alphaSort,
        bridge: bridge,
        canDeletePaths: canDeletePaths && !isReadOnly,
        canEditValues: canEditValues && !isReadOnly,
        canRenamePaths: canRenamePaths && !isReadOnly,
        canRenamePathsAtDepth: canRenamePathsAtDepth,
        depth: depth + 1,
        getInspectedElementPath: getInspectedElementPath,
        hookID: hookID,
        inspectedElement: inspectedElement,
        isDirectChildOfAnArray: true,
        hidden: hidden || !isOpen,
        name: index,
        path: path.concat(index),
        pathRoot: pathRoot,
        store: store,
        value: value[index]
      }));

      if (canEditValues && !isReadOnly) {
        children.push( /*#__PURE__*/external_react_["createElement"](NewArrayValue_NewArrayValue, {
          key: "NewKeyValue",
          bridge: bridge,
          depth: depth + 1,
          hidden: hidden || !isOpen,
          hookID: hookID,
          index: value.length,
          getInspectedElementPath: getInspectedElementPath,
          inspectedElement: inspectedElement,
          path: path,
          store: store,
          type: pathRoot
        }));
      }

      children.unshift( /*#__PURE__*/external_react_["createElement"]("div", {
        key: `${depth}-root`,
        className: KeyValue_default.a.Item,
        hidden: hidden,
        ref: contextMenuTriggerRef,
        style: style
      }, hasChildren ? /*#__PURE__*/external_react_["createElement"](ExpandCollapseToggle_ExpandCollapseToggle, {
        isOpen: isOpen,
        setIsOpen: setIsOpen
      }) : /*#__PURE__*/external_react_["createElement"]("div", {
        className: KeyValue_default.a.ExpandCollapseToggleSpacer
      }), renderedName, /*#__PURE__*/external_react_["createElement"]("div", {
        className: KeyValue_default.a.AfterName
      }, ":"), /*#__PURE__*/external_react_["createElement"]("span", {
        className: KeyValue_default.a.Value,
        onClick: hasChildren ? toggleIsOpen : undefined
      }, displayName)));
    } else {
      // TRICKY
      // It's important to use Object.entries() rather than Object.keys()
      // because of the hidden meta Symbols used for hydration and unserializable values.
      const entries = Object.entries(value);

      if (alphaSort) {
        entries.sort(alphaSortEntries);
      }

      const hasChildren = entries.length > 0 || canEditValues;
      const displayName = getMetaValueLabel(value);
      children = entries.map(([key, keyValue]) => /*#__PURE__*/external_react_["createElement"](KeyValue_KeyValue, {
        key: key,
        alphaSort: alphaSort,
        bridge: bridge,
        canDeletePaths: canDeletePaths && !isReadOnly,
        canEditValues: canEditValues && !isReadOnly,
        canRenamePaths: canRenamePaths && !isReadOnly,
        canRenamePathsAtDepth: canRenamePathsAtDepth,
        depth: depth + 1,
        getInspectedElementPath: getInspectedElementPath,
        hookID: hookID,
        inspectedElement: inspectedElement,
        hidden: hidden || !isOpen,
        name: key,
        path: path.concat(key),
        pathRoot: pathRoot,
        store: store,
        value: keyValue
      }));

      if (canEditValues && !isReadOnly) {
        children.push( /*#__PURE__*/external_react_["createElement"](NewKeyValue_NewKeyValue, {
          key: "NewKeyValue",
          bridge: bridge,
          depth: depth + 1,
          getInspectedElementPath: getInspectedElementPath,
          hidden: hidden || !isOpen,
          hookID: hookID,
          inspectedElement: inspectedElement,
          path: path,
          store: store,
          type: pathRoot
        }));
      }

      children.unshift( /*#__PURE__*/external_react_["createElement"]("div", {
        key: `${depth}-root`,
        className: KeyValue_default.a.Item,
        hidden: hidden,
        ref: contextMenuTriggerRef,
        style: style
      }, hasChildren ? /*#__PURE__*/external_react_["createElement"](ExpandCollapseToggle_ExpandCollapseToggle, {
        isOpen: isOpen,
        setIsOpen: setIsOpen
      }) : /*#__PURE__*/external_react_["createElement"]("div", {
        className: KeyValue_default.a.ExpandCollapseToggleSpacer
      }), renderedName, /*#__PURE__*/external_react_["createElement"]("div", {
        className: KeyValue_default.a.AfterName
      }, ":"), /*#__PURE__*/external_react_["createElement"]("span", {
        className: KeyValue_default.a.Value,
        onClick: hasChildren ? toggleIsOpen : undefined
      }, displayName)));
    }
  }

  return children;
}

function DeleteToggle({
  deletePath,
  name,
  path
}) {
  const handleClick = event => {
    event.stopPropagation();
    deletePath(path);
  };

  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"](Button_Button, {
    className: KeyValue_default.a.DeleteArrayItemButton,
    onClick: handleClick,
    title: "Delete entry"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "delete"
  })), /*#__PURE__*/external_react_["createElement"]("span", {
    className: KeyValue_default.a.Name
  }, name));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/InspectedElementSharedStyles.css
var InspectedElementSharedStyles = __webpack_require__(13);
var InspectedElementSharedStyles_default = /*#__PURE__*/__webpack_require__.n(InspectedElementSharedStyles);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/InspectedElementContextTree.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */









function InspectedElementContextTree({
  bridge,
  getInspectedElementPath,
  inspectedElement,
  store
}) {
  const hasLegacyContext = inspectedElement.hasLegacyContext,
        context = inspectedElement.context,
        type = inspectedElement.type;
  const isReadOnly = type !== types["e" /* ElementTypeClass */] && type !== types["h" /* ElementTypeFunction */];
  const entries = context != null ? Object.entries(context) : null;

  if (entries !== null) {
    entries.sort(alphaSortEntries);
  }

  const isEmpty = entries === null || entries.length === 0;

  const handleCopy = () => Object(clipboard["copy"])(serializeDataForCopy(context)); // We add an object with a "value" key as a wrapper around Context data
  // so that we can use the shared <KeyValue> component to display it.
  // This wrapper object can't be renamed.


  const canRenamePathsAtDepth = depth => depth > 1;

  if (isEmpty) {
    return null;
  } else {
    return /*#__PURE__*/external_react_["createElement"]("div", {
      className: InspectedElementSharedStyles_default.a.InspectedElementTree
    }, /*#__PURE__*/external_react_["createElement"]("div", {
      className: InspectedElementSharedStyles_default.a.HeaderRow
    }, /*#__PURE__*/external_react_["createElement"]("div", {
      className: InspectedElementSharedStyles_default.a.Header
    }, hasLegacyContext ? 'legacy context' : 'context'), !isEmpty && /*#__PURE__*/external_react_["createElement"](Button_Button, {
      onClick: handleCopy,
      title: "Copy to clipboard"
    }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
      type: "copy"
    }))), isEmpty && /*#__PURE__*/external_react_["createElement"]("div", {
      className: InspectedElementSharedStyles_default.a.Empty
    }, "None"), !isEmpty && entries.map(([name, value]) => /*#__PURE__*/external_react_["createElement"](KeyValue_KeyValue, {
      key: name,
      alphaSort: true,
      bridge: bridge,
      canDeletePaths: !isReadOnly,
      canEditValues: !isReadOnly,
      canRenamePaths: !isReadOnly,
      canRenamePathsAtDepth: canRenamePathsAtDepth,
      type: "context",
      depth: 1,
      getInspectedElementPath: getInspectedElementPath,
      hidden: false,
      inspectedElement: inspectedElement,
      name: name,
      path: [name],
      pathRoot: "context",
      store: store,
      value: value
    })));
  }
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/InspectedElementHooksTree.css
var InspectedElementHooksTree = __webpack_require__(14);
var InspectedElementHooksTree_default = /*#__PURE__*/__webpack_require__.n(InspectedElementHooksTree);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/InspectedElementHooksTree.js
function InspectedElementHooksTree_slicedToArray(arr, i) { return InspectedElementHooksTree_arrayWithHoles(arr) || InspectedElementHooksTree_iterableToArrayLimit(arr, i) || InspectedElementHooksTree_unsupportedIterableToArray(arr, i) || InspectedElementHooksTree_nonIterableRest(); }

function InspectedElementHooksTree_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function InspectedElementHooksTree_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return InspectedElementHooksTree_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return InspectedElementHooksTree_arrayLikeToArray(o, minLen); }

function InspectedElementHooksTree_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function InspectedElementHooksTree_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function InspectedElementHooksTree_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */













function InspectedElementHooksTree_InspectedElementHooksTree({
  bridge,
  getInspectedElementPath,
  inspectedElement,
  store
}) {
  const hooks = inspectedElement.hooks,
        id = inspectedElement.id;

  const handleCopy = () => Object(clipboard["copy"])(serializeHooksForCopy(hooks));

  if (hooks === null) {
    return null;
  } else {
    return /*#__PURE__*/external_react_["createElement"]("div", {
      className: InspectedElementHooksTree_default.a.HooksTreeView
    }, /*#__PURE__*/external_react_["createElement"]("div", {
      className: InspectedElementHooksTree_default.a.HeaderRow
    }, /*#__PURE__*/external_react_["createElement"]("div", {
      className: InspectedElementHooksTree_default.a.Header
    }, "hooks"), /*#__PURE__*/external_react_["createElement"](Button_Button, {
      onClick: handleCopy,
      title: "Copy to clipboard"
    }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
      type: "copy"
    }))), /*#__PURE__*/external_react_["createElement"](InnerHooksTreeView, {
      hooks: hooks,
      id: id,
      getInspectedElementPath: getInspectedElementPath,
      inspectedElement: inspectedElement,
      path: []
    }));
  }
}
function InnerHooksTreeView({
  getInspectedElementPath,
  hooks,
  id,
  inspectedElement,
  path
}) {
  // $FlowFixMe "Missing type annotation for U" whatever that means
  return hooks.map((hook, index) => /*#__PURE__*/external_react_["createElement"](HookView, {
    key: index,
    getInspectedElementPath: getInspectedElementPath,
    hook: hooks[index],
    id: id,
    inspectedElement: inspectedElement,
    path: path.concat([index])
  }));
}

function HookView({
  getInspectedElementPath,
  hook,
  id,
  inspectedElement,
  path
}) {
  const canEditHooks = inspectedElement.canEditHooks,
        canEditHooksAndDeletePaths = inspectedElement.canEditHooksAndDeletePaths,
        canEditHooksAndRenamePaths = inspectedElement.canEditHooksAndRenamePaths;
  const name = hook.name,
        hookID = hook.id,
        isStateEditable = hook.isStateEditable,
        subHooks = hook.subHooks,
        value = hook.value;
  const isReadOnly = hookID == null || !isStateEditable;
  const canDeletePaths = !isReadOnly && canEditHooksAndDeletePaths;
  const canEditValues = !isReadOnly && canEditHooks;
  const canRenamePaths = !isReadOnly && canEditHooksAndRenamePaths;
  const bridge = Object(external_react_["useContext"])(BridgeContext);
  const store = Object(external_react_["useContext"])(StoreContext);

  const _useState = Object(external_react_["useState"])(false),
        _useState2 = InspectedElementHooksTree_slicedToArray(_useState, 2),
        isOpen = _useState2[0],
        setIsOpen = _useState2[1];

  const toggleIsOpen = Object(external_react_["useCallback"])(() => setIsOpen(prevIsOpen => !prevIsOpen), []);
  const contextMenuTriggerRef = Object(external_react_["useRef"])(null);
  useContextMenu({
    data: {
      path: ['hooks', ...path],
      type: hook !== null && typeof hook === 'object' && hook.hasOwnProperty(hydration["d" /* meta */].type) ? hook[hydration["d" /* meta */].type] : typeof value
    },
    id: 'InspectedElement',
    ref: contextMenuTriggerRef
  });

  if (hook.hasOwnProperty(hydration["d" /* meta */].inspected)) {
    // This Hook is too deep and hasn't been hydrated.
    if (false) {}

    return /*#__PURE__*/external_react_["createElement"]("div", {
      className: InspectedElementHooksTree_default.a.Hook
    }, /*#__PURE__*/external_react_["createElement"]("div", {
      className: InspectedElementHooksTree_default.a.NameValueRow
    }, /*#__PURE__*/external_react_["createElement"]("span", {
      className: InspectedElementHooksTree_default.a.TruncationIndicator
    }, "...")));
  } // Certain hooks are not editable at all (as identified by react-debug-tools).
  // Primative hook names (e.g. the "State" name for useState) are also never editable.


  const canRenamePathsAtDepth = depth => isStateEditable && depth > 1;

  const isCustomHook = subHooks.length > 0;
  const type = typeof value;
  let displayValue;
  let isComplexDisplayValue = false; // Format data for display to mimic the props/state/context for now.

  if (type === 'string') {
    displayValue = `"${value}"`;
  } else if (type === 'boolean') {
    displayValue = value ? 'true' : 'false';
  } else if (type === 'number') {
    displayValue = value;
  } else if (value === null) {
    displayValue = 'null';
  } else if (value === undefined) {
    displayValue = null;
  } else if (Array.isArray(value)) {
    isComplexDisplayValue = true;
    displayValue = 'Array';
  } else if (type === 'object') {
    isComplexDisplayValue = true;
    displayValue = 'Object';
  }

  if (isCustomHook) {
    const subHooksView = Array.isArray(subHooks) ? /*#__PURE__*/external_react_["createElement"](InnerHooksTreeView, {
      getInspectedElementPath: getInspectedElementPath,
      hooks: subHooks,
      id: id,
      inspectedElement: inspectedElement,
      path: path.concat(['subHooks'])
    }) : /*#__PURE__*/external_react_["createElement"](KeyValue_KeyValue, {
      alphaSort: false,
      bridge: bridge,
      canDeletePaths: canDeletePaths,
      canEditValues: canEditValues,
      canRenamePaths: canRenamePaths,
      canRenamePathsAtDepth: canRenamePathsAtDepth,
      depth: 1,
      getInspectedElementPath: getInspectedElementPath,
      hookID: hookID,
      inspectedElement: inspectedElement,
      name: "subHooks",
      path: path.concat(['subHooks']),
      store: store,
      type: "hooks",
      value: subHooks
    });

    if (isComplexDisplayValue) {
      return /*#__PURE__*/external_react_["createElement"]("div", {
        className: InspectedElementHooksTree_default.a.Hook
      }, /*#__PURE__*/external_react_["createElement"]("div", {
        ref: contextMenuTriggerRef,
        className: InspectedElementHooksTree_default.a.NameValueRow
      }, /*#__PURE__*/external_react_["createElement"](ExpandCollapseToggle_ExpandCollapseToggle, {
        isOpen: isOpen,
        setIsOpen: setIsOpen
      }), /*#__PURE__*/external_react_["createElement"]("span", {
        onClick: toggleIsOpen,
        className: name !== '' ? InspectedElementHooksTree_default.a.Name : InspectedElementHooksTree_default.a.NameAnonymous
      }, name || 'Anonymous'), /*#__PURE__*/external_react_["createElement"]("span", {
        className: InspectedElementHooksTree_default.a.Value,
        onClick: toggleIsOpen
      }, isOpen || getMetaValueLabel(value))), /*#__PURE__*/external_react_["createElement"]("div", {
        className: InspectedElementHooksTree_default.a.Children,
        hidden: !isOpen
      }, /*#__PURE__*/external_react_["createElement"](KeyValue_KeyValue, {
        alphaSort: false,
        bridge: bridge,
        canDeletePaths: canDeletePaths,
        canEditValues: canEditValues,
        canRenamePaths: canRenamePaths,
        canRenamePathsAtDepth: canRenamePathsAtDepth,
        depth: 1,
        getInspectedElementPath: getInspectedElementPath,
        hookID: hookID,
        inspectedElement: inspectedElement,
        name: "DebugValue",
        path: path.concat(['value']),
        pathRoot: "hooks",
        store: store,
        value: value
      }), subHooksView));
    } else {
      return /*#__PURE__*/external_react_["createElement"]("div", {
        className: InspectedElementHooksTree_default.a.Hook
      }, /*#__PURE__*/external_react_["createElement"]("div", {
        ref: contextMenuTriggerRef,
        className: InspectedElementHooksTree_default.a.NameValueRow
      }, /*#__PURE__*/external_react_["createElement"](ExpandCollapseToggle_ExpandCollapseToggle, {
        isOpen: isOpen,
        setIsOpen: setIsOpen
      }), /*#__PURE__*/external_react_["createElement"]("span", {
        onClick: toggleIsOpen,
        className: name !== '' ? InspectedElementHooksTree_default.a.Name : InspectedElementHooksTree_default.a.NameAnonymous
      }, name || 'Anonymous'), ' ', /*#__PURE__*/external_react_["createElement"]("span", {
        className: InspectedElementHooksTree_default.a.Value,
        onClick: toggleIsOpen
      }, displayValue)), /*#__PURE__*/external_react_["createElement"]("div", {
        className: InspectedElementHooksTree_default.a.Children,
        hidden: !isOpen
      }, subHooksView));
    }
  } else {
    if (isComplexDisplayValue) {
      return /*#__PURE__*/external_react_["createElement"]("div", {
        className: InspectedElementHooksTree_default.a.Hook
      }, /*#__PURE__*/external_react_["createElement"](KeyValue_KeyValue, {
        alphaSort: false,
        bridge: bridge,
        canDeletePaths: canDeletePaths,
        canEditValues: canEditValues,
        canRenamePaths: canRenamePaths,
        canRenamePathsAtDepth: canRenamePathsAtDepth,
        depth: 1,
        getInspectedElementPath: getInspectedElementPath,
        hookID: hookID,
        inspectedElement: inspectedElement,
        name: name,
        path: path.concat(['value']),
        pathRoot: "hooks",
        store: store,
        value: value
      }));
    } else {
      return /*#__PURE__*/external_react_["createElement"]("div", {
        className: InspectedElementHooksTree_default.a.Hook
      }, /*#__PURE__*/external_react_["createElement"](KeyValue_KeyValue, {
        alphaSort: false,
        bridge: bridge,
        canDeletePaths: false,
        canEditValues: canEditValues,
        canRenamePaths: false,
        depth: 1,
        getInspectedElementPath: getInspectedElementPath,
        hookID: hookID,
        inspectedElement: inspectedElement,
        name: name,
        path: [],
        pathRoot: "hooks",
        store: store,
        value: value
      }));
    }
  }
} // $FlowFixMe


/* harmony default export */ var Components_InspectedElementHooksTree = (/*#__PURE__*/external_react_["memo"](InspectedElementHooksTree_InspectedElementHooksTree));
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/InspectedElementPropsTree.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */










function InspectedElementPropsTree({
  bridge,
  getInspectedElementPath,
  inspectedElement,
  store
}) {
  const canEditFunctionProps = inspectedElement.canEditFunctionProps,
        canEditFunctionPropsDeletePaths = inspectedElement.canEditFunctionPropsDeletePaths,
        canEditFunctionPropsRenamePaths = inspectedElement.canEditFunctionPropsRenamePaths,
        props = inspectedElement.props,
        type = inspectedElement.type;
  const canDeletePaths = type === types["e" /* ElementTypeClass */] || canEditFunctionPropsDeletePaths;
  const canEditValues = type === types["e" /* ElementTypeClass */] || canEditFunctionProps;
  const canRenamePaths = type === types["e" /* ElementTypeClass */] || canEditFunctionPropsRenamePaths;
  const entries = props != null ? Object.entries(props) : null;

  if (entries !== null) {
    entries.sort(alphaSortEntries);
  }

  const isEmpty = entries === null || entries.length === 0;

  const handleCopy = () => Object(clipboard["copy"])(serializeDataForCopy(props));

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementSharedStyles_default.a.InspectedElementTree
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementSharedStyles_default.a.HeaderRow
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementSharedStyles_default.a.Header
  }, "props"), !isEmpty && /*#__PURE__*/external_react_["createElement"](Button_Button, {
    onClick: handleCopy,
    title: "Copy to clipboard"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "copy"
  }))), !isEmpty && entries.map(([name, value]) => /*#__PURE__*/external_react_["createElement"](KeyValue_KeyValue, {
    key: name,
    alphaSort: true,
    bridge: bridge,
    canDeletePaths: canDeletePaths,
    canEditValues: canEditValues,
    canRenamePaths: canRenamePaths,
    depth: 1,
    getInspectedElementPath: getInspectedElementPath,
    hidden: false,
    inspectedElement: inspectedElement,
    name: name,
    path: [name],
    pathRoot: "props",
    store: store,
    value: value
  })), canEditValues && /*#__PURE__*/external_react_["createElement"](NewKeyValue_NewKeyValue, {
    bridge: bridge,
    depth: 0,
    hidden: false,
    inspectedElement: inspectedElement,
    path: [],
    store: store,
    type: "props"
  }));
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/InspectedElementStateTree.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */








function InspectedElementStateTree({
  bridge,
  getInspectedElementPath,
  inspectedElement,
  store
}) {
  const state = inspectedElement.state;
  const entries = state != null ? Object.entries(state) : null;

  if (entries !== null) {
    entries.sort(alphaSortEntries);
  }

  const isEmpty = entries === null || entries.length === 0;

  const handleCopy = () => Object(clipboard["copy"])(serializeDataForCopy(state));

  if (isEmpty) {
    return null;
  } else {
    return /*#__PURE__*/external_react_["createElement"]("div", {
      className: InspectedElementSharedStyles_default.a.InspectedElementTree
    }, /*#__PURE__*/external_react_["createElement"]("div", {
      className: InspectedElementSharedStyles_default.a.HeaderRow
    }, /*#__PURE__*/external_react_["createElement"]("div", {
      className: InspectedElementSharedStyles_default.a.Header
    }, "state"), !isEmpty && /*#__PURE__*/external_react_["createElement"](Button_Button, {
      onClick: handleCopy,
      title: "Copy to clipboard"
    }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
      type: "copy"
    }))), isEmpty && /*#__PURE__*/external_react_["createElement"]("div", {
      className: InspectedElementSharedStyles_default.a.Empty
    }, "None"), !isEmpty && entries.map(([name, value]) => /*#__PURE__*/external_react_["createElement"](KeyValue_KeyValue, {
      key: name,
      alphaSort: true,
      bridge: bridge,
      canDeletePaths: true,
      canEditValues: true,
      canRenamePaths: true,
      depth: 1,
      getInspectedElementPath: getInspectedElementPath,
      hidden: false,
      inspectedElement: inspectedElement,
      name: name,
      path: [name],
      pathRoot: "state",
      store: store,
      value: value
    })));
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/InspectedElementSuspenseToggle.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */





function InspectedElementSuspenseToggle({
  bridge,
  inspectedElement,
  store
}) {
  const canToggleSuspense = inspectedElement.canToggleSuspense,
        id = inspectedElement.id,
        state = inspectedElement.state,
        type = inspectedElement.type;

  if (type !== types["n" /* ElementTypeSuspense */]) {
    return null;
  }

  const isSuspended = state !== null;

  const toggleSuspense = (path, value) => {
    const rendererID = store.getRendererIDForElement(id);

    if (rendererID !== null) {
      bridge.send('overrideSuspense', {
        id,
        rendererID,
        forceFallback: value
      });
    }
  };

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementSharedStyles_default.a.InspectedElementTree
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementSharedStyles_default.a.HeaderRow
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementSharedStyles_default.a.Header
  }, "suspense")), /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementSharedStyles_default.a.ToggleSuspenseRow
  }, /*#__PURE__*/external_react_["createElement"]("span", {
    className: InspectedElementSharedStyles_default.a.Name
  }, "Suspended"), canToggleSuspense ?
  /*#__PURE__*/
  // key is required to keep <EditableValue> and header row toggle button in sync
  external_react_["createElement"](EditableValue_EditableValue, {
    key: isSuspended,
    overrideValue: toggleSuspense,
    path: ['suspense', 'Suspended'],
    value: isSuspended
  }) : /*#__PURE__*/external_react_["createElement"]("span", {
    className: InspectedElementSharedStyles_default.a.Value
  }, isSuspended ? 'true' : 'false')));
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/NativeStyleEditor/context.js
function context_slicedToArray(arr, i) { return context_arrayWithHoles(arr) || context_iterableToArrayLimit(arr, i) || context_unsupportedIterableToArray(arr, i) || context_nonIterableRest(); }

function context_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function context_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return context_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return context_arrayLikeToArray(o, minLen); }

function context_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function context_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function context_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






const NativeStyleContext = /*#__PURE__*/Object(external_react_["createContext"])(null);
NativeStyleContext.displayName = 'NativeStyleContext';
const context_inProgressRequests = new WeakMap();
const context_resource = createResource(element => {
  const request = context_inProgressRequests.get(element);

  if (request != null) {
    return request.promise;
  }

  let resolveFn = null;
  const promise = new Promise(resolve => {
    resolveFn = resolve;
  });
  context_inProgressRequests.set(element, {
    promise,
    resolveFn
  });
  return promise;
}, element => element, {
  useWeakMap: true
});

function NativeStyleContextController({
  children
}) {
  const bridge = Object(external_react_["useContext"])(BridgeContext);
  const store = Object(external_react_["useContext"])(StoreContext);
  const getStyleAndLayout = Object(external_react_["useCallback"])(id => {
    const element = store.getElementByID(id);

    if (element !== null) {
      return context_resource.read(element);
    } else {
      return null;
    }
  }, [store]); // It's very important that this context consumes selectedElementID and not NativeStyleID.
  // Otherwise the effect that sends the "inspect" message across the bridge-
  // would itself be blocked by the same render that suspends (waiting for the data).

  const _useContext = Object(external_react_["useContext"])(TreeStateContext),
        selectedElementID = _useContext.selectedElementID;

  const _useState = Object(external_react_["useState"])(null),
        _useState2 = context_slicedToArray(_useState, 2),
        currentStyleAndLayout = _useState2[0],
        setCurrentStyleAndLayout = _useState2[1]; // This effect handler invalidates the suspense cache and schedules rendering updates with React.


  Object(external_react_["useEffect"])(() => {
    const onStyleAndLayout = ({
      id,
      layout,
      style
    }) => {
      const element = store.getElementByID(id);

      if (element !== null) {
        const styleAndLayout = {
          layout,
          style
        };
        const request = context_inProgressRequests.get(element);

        if (request != null) {
          context_inProgressRequests.delete(element);
          Object(external_react_dom_["unstable_batchedUpdates"])(() => {
            request.resolveFn(styleAndLayout);
            setCurrentStyleAndLayout(styleAndLayout);
          });
        } else {
          context_resource.write(element, styleAndLayout); // Schedule update with React if the currently-selected element has been invalidated.

          if (id === selectedElementID) {
            setCurrentStyleAndLayout(styleAndLayout);
          }
        }
      }
    };

    bridge.addListener('NativeStyleEditor_styleAndLayout', onStyleAndLayout);
    return () => bridge.removeListener('NativeStyleEditor_styleAndLayout', onStyleAndLayout);
  }, [bridge, currentStyleAndLayout, selectedElementID, store]); // This effect handler polls for updates on the currently selected element.

  Object(external_react_["useEffect"])(() => {
    if (selectedElementID === null) {
      return () => {};
    }

    const rendererID = store.getRendererIDForElement(selectedElementID);
    let timeoutID = null;

    const sendRequest = () => {
      timeoutID = null;

      if (rendererID !== null) {
        bridge.send('NativeStyleEditor_measure', {
          id: selectedElementID,
          rendererID
        });
      }
    }; // Send the initial measurement request.
    // We'll poll for an update in the response handler below.


    sendRequest();

    const onStyleAndLayout = ({
      id
    }) => {
      // If this is the element we requested, wait a little bit and then ask for another update.
      if (id === selectedElementID) {
        if (timeoutID !== null) {
          clearTimeout(timeoutID);
        }

        timeoutID = setTimeout(sendRequest, 1000);
      }
    };

    bridge.addListener('NativeStyleEditor_styleAndLayout', onStyleAndLayout);
    return () => {
      bridge.removeListener('NativeStyleEditor_styleAndLayout', onStyleAndLayout);

      if (timeoutID !== null) {
        clearTimeout(timeoutID);
      }
    };
  }, [bridge, selectedElementID, store]);
  const value = Object(external_react_["useMemo"])(() => ({
    getStyleAndLayout
  }), // NativeStyle is used to invalidate the cache and schedule an update with React.
  [currentStyleAndLayout, getStyleAndLayout]);
  return /*#__PURE__*/external_react_["createElement"](NativeStyleContext.Provider, {
    value: value
  }, children);
}


// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/NativeStyleEditor/LayoutViewer.css
var LayoutViewer = __webpack_require__(23);
var LayoutViewer_default = /*#__PURE__*/__webpack_require__.n(LayoutViewer);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/NativeStyleEditor/LayoutViewer.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


function LayoutViewer_LayoutViewer({
  id,
  layout
}) {
  const height = layout.height,
        margin = layout.margin,
        padding = layout.padding,
        y = layout.y,
        width = layout.width,
        x = layout.x;
  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: LayoutViewer_default.a.LayoutViewer
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: LayoutViewer_default.a.Header
  }, "layout"), /*#__PURE__*/external_react_["createElement"]("div", {
    className: LayoutViewer_default.a.DashedBox
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: LayoutViewer_default.a.LabelRow
  }, /*#__PURE__*/external_react_["createElement"]("label", {
    className: LayoutViewer_default.a.Label
  }, "margin"), /*#__PURE__*/external_react_["createElement"]("label", null, margin.top || '-')), /*#__PURE__*/external_react_["createElement"]("div", {
    className: LayoutViewer_default.a.BoxRow
  }, /*#__PURE__*/external_react_["createElement"]("label", null, margin.left || '-'), /*#__PURE__*/external_react_["createElement"]("div", {
    className: LayoutViewer_default.a.SolidBox
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: LayoutViewer_default.a.LabelRow
  }, /*#__PURE__*/external_react_["createElement"]("label", {
    className: LayoutViewer_default.a.Label
  }, "padding"), /*#__PURE__*/external_react_["createElement"]("label", null, padding.top || '-')), /*#__PURE__*/external_react_["createElement"]("div", {
    className: LayoutViewer_default.a.BoxRow
  }, /*#__PURE__*/external_react_["createElement"]("label", null, padding.left || '-'), /*#__PURE__*/external_react_["createElement"]("div", {
    className: LayoutViewer_default.a.DashedBox
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: LayoutViewer_default.a.LabelRow
  }, format(width), " x ", format(height), " (", format(x), ", ", format(y), ")")), /*#__PURE__*/external_react_["createElement"]("label", null, padding.right || '-')), /*#__PURE__*/external_react_["createElement"]("label", null, padding.bottom || '-')), /*#__PURE__*/external_react_["createElement"]("label", null, margin.right || '-')), /*#__PURE__*/external_react_["createElement"]("label", null, margin.bottom || '-')));
}

function format(number) {
  if (Math.round(number) === number) {
    return number;
  } else {
    return number.toFixed(1);
  }
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/NativeStyleEditor/StyleEditor.css
var StyleEditor = __webpack_require__(24);
var StyleEditor_default = /*#__PURE__*/__webpack_require__.n(StyleEditor);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/NativeStyleEditor/StyleEditor.js
function StyleEditor_slicedToArray(arr, i) { return StyleEditor_arrayWithHoles(arr) || StyleEditor_iterableToArrayLimit(arr, i) || StyleEditor_unsupportedIterableToArray(arr, i) || StyleEditor_nonIterableRest(); }

function StyleEditor_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function StyleEditor_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return StyleEditor_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return StyleEditor_arrayLikeToArray(o, minLen); }

function StyleEditor_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function StyleEditor_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function StyleEditor_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */











function StyleEditor_StyleEditor({
  id,
  style
}) {
  const bridge = Object(external_react_["useContext"])(BridgeContext);
  const store = Object(external_react_["useContext"])(StoreContext);

  const changeAttribute = (oldName, newName, value) => {
    const rendererID = store.getRendererIDForElement(id);

    if (rendererID !== null) {
      bridge.send('NativeStyleEditor_renameAttribute', {
        id,
        rendererID,
        oldName,
        newName,
        value
      });
    }
  };

  const changeValue = (name, value) => {
    const rendererID = store.getRendererIDForElement(id);

    if (rendererID !== null) {
      bridge.send('NativeStyleEditor_setValue', {
        id,
        rendererID,
        name,
        value
      });
    }
  };

  const keys = Object(external_react_["useMemo"])(() => Array.from(Object.keys(style)), [style]);

  const handleCopy = () => Object(clipboard["copy"])(serializeDataForCopy(style));

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: StyleEditor_default.a.StyleEditor
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: StyleEditor_default.a.HeaderRow
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: StyleEditor_default.a.Header
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: StyleEditor_default.a.Brackets
  }, 'style {')), /*#__PURE__*/external_react_["createElement"](Button_Button, {
    onClick: handleCopy,
    title: "Copy to clipboard"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "copy"
  }))), keys.length > 0 && keys.map(attribute => /*#__PURE__*/external_react_["createElement"](Row, {
    key: attribute,
    attribute: attribute,
    changeAttribute: changeAttribute,
    changeValue: changeValue,
    validAttributes: store.nativeStyleEditorValidAttributes,
    value: style[attribute]
  })), /*#__PURE__*/external_react_["createElement"](NewRow, {
    changeAttribute: changeAttribute,
    changeValue: changeValue,
    validAttributes: store.nativeStyleEditorValidAttributes
  }), /*#__PURE__*/external_react_["createElement"]("div", {
    className: StyleEditor_default.a.Brackets
  }, '}'));
}

function NewRow({
  changeAttribute,
  changeValue,
  validAttributes
}) {
  const _useState = Object(external_react_["useState"])(0),
        _useState2 = StyleEditor_slicedToArray(_useState, 2),
        key = _useState2[0],
        setKey = _useState2[1];

  const reset = () => setKey(key + 1);

  const newAttributeRef = Object(external_react_["useRef"])('');

  const changeAttributeWrapper = (oldAttribute, newAttribute, value) => {
    // Ignore attribute changes until a value has been specified
    newAttributeRef.current = newAttribute;
  };

  const changeValueWrapper = (attribute, value) => {
    // Blur events should reset/cancel if there's no value or no attribute
    if (newAttributeRef.current !== '') {
      if (value !== '') {
        changeValue(newAttributeRef.current, value);
      }

      reset();
    }
  };

  return /*#__PURE__*/external_react_["createElement"](Row, {
    key: key,
    attribute: '',
    attributePlaceholder: "attribute",
    changeAttribute: changeAttributeWrapper,
    changeValue: changeValueWrapper,
    validAttributes: validAttributes,
    value: '',
    valuePlaceholder: "value"
  });
}

function Row({
  attribute,
  attributePlaceholder,
  changeAttribute,
  changeValue,
  validAttributes,
  value,
  valuePlaceholder
}) {
  // TODO (RN style editor) Use @reach/combobox to auto-complete attributes.
  // The list of valid attributes would need to be injected by RN backend,
  // which would need to require them from ReactNativeViewViewConfig "validAttributes.style" keys.
  // This would need to degrade gracefully for react-native-web,
  // although we could let it also inject a custom set of allowed attributes.
  const _useState3 = Object(external_react_["useState"])(attribute),
        _useState4 = StyleEditor_slicedToArray(_useState3, 2),
        localAttribute = _useState4[0],
        setLocalAttribute = _useState4[1];

  const _useState5 = Object(external_react_["useState"])(JSON.stringify(value)),
        _useState6 = StyleEditor_slicedToArray(_useState5, 2),
        localValue = _useState6[0],
        setLocalValue = _useState6[1];

  const _useState7 = Object(external_react_["useState"])(true),
        _useState8 = StyleEditor_slicedToArray(_useState7, 2),
        isAttributeValid = _useState8[0],
        setIsAttributeValid = _useState8[1];

  const _useState9 = Object(external_react_["useState"])(true),
        _useState10 = StyleEditor_slicedToArray(_useState9, 2),
        isValueValid = _useState10[0],
        setIsValueValid = _useState10[1];

  const validateAndSetLocalAttribute = newAttribute => {
    const isValid = newAttribute === '' || validAttributes === null || validAttributes.indexOf(newAttribute) >= 0;
    Object(external_react_dom_["unstable_batchedUpdates"])(() => {
      setLocalAttribute(newAttribute);
      setIsAttributeValid(isValid);
    });
  };

  const validateAndSetLocalValue = newValue => {
    let isValid = false;

    try {
      JSON.parse(sanitizeForParse(newValue));
      isValid = true;
    } catch (error) {}

    Object(external_react_dom_["unstable_batchedUpdates"])(() => {
      setLocalValue(newValue);
      setIsValueValid(isValid);
    });
  };

  const resetAttribute = () => {
    setLocalAttribute(attribute);
  };

  const resetValue = () => {
    setLocalValue(value);
  };

  const submitValueChange = () => {
    if (isAttributeValid && isValueValid) {
      const parsedLocalValue = JSON.parse(sanitizeForParse(localValue));

      if (value !== parsedLocalValue) {
        changeValue(attribute, parsedLocalValue);
      }
    }
  };

  const submitAttributeChange = () => {
    if (isAttributeValid && isValueValid) {
      if (attribute !== localAttribute) {
        changeAttribute(attribute, localAttribute, value);
      }
    }
  };

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: StyleEditor_default.a.Row
  }, /*#__PURE__*/external_react_["createElement"](Field, {
    className: isAttributeValid ? StyleEditor_default.a.Attribute : StyleEditor_default.a.Invalid,
    onChange: validateAndSetLocalAttribute,
    onReset: resetAttribute,
    onSubmit: submitAttributeChange,
    placeholder: attributePlaceholder,
    value: localAttribute
  }), ":\xA0", /*#__PURE__*/external_react_["createElement"](Field, {
    className: isValueValid ? StyleEditor_default.a.Value : StyleEditor_default.a.Invalid,
    onChange: validateAndSetLocalValue,
    onReset: resetValue,
    onSubmit: submitValueChange,
    placeholder: valuePlaceholder,
    value: localValue
  }), ";");
}

function Field({
  className,
  onChange: _onChange,
  onReset,
  onSubmit,
  placeholder,
  value
}) {
  const onKeyDown = event => {
    switch (event.key) {
      case 'Enter':
        onSubmit();
        break;

      case 'Escape':
        onReset();
        break;

      case 'ArrowDown':
      case 'ArrowLeft':
      case 'ArrowRight':
      case 'ArrowUp':
        event.stopPropagation();
        break;

      default:
        break;
    }
  };

  return /*#__PURE__*/external_react_["createElement"](AutoSizeInput_AutoSizeInput, {
    className: `${className} ${StyleEditor_default.a.Input}`,
    onBlur: onSubmit,
    onChange: event => _onChange(event.target.value),
    onKeyDown: onKeyDown,
    placeholder: placeholder,
    value: value
  });
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/NativeStyleEditor/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */








function NativeStyleEditorWrapper(_) {
  const store = Object(external_react_["useContext"])(StoreContext);
  const subscription = Object(external_react_["useMemo"])(() => ({
    getCurrentValue: () => store.supportsNativeStyleEditor,
    subscribe: callback => {
      store.addListener('supportsNativeStyleEditor', callback);
      return () => {
        store.removeListener('supportsNativeStyleEditor', callback);
      };
    }
  }), [store]);
  const supportsNativeStyleEditor = useSubscription(subscription);

  if (!supportsNativeStyleEditor) {
    return null;
  }

  return /*#__PURE__*/external_react_["createElement"](NativeStyleEditor, null);
}

function NativeStyleEditor(_) {
  const _useContext = Object(external_react_["useContext"])(NativeStyleContext),
        getStyleAndLayout = _useContext.getStyleAndLayout;

  const _useContext2 = Object(external_react_["useContext"])(TreeStateContext),
        inspectedElementID = _useContext2.inspectedElementID;

  if (inspectedElementID === null) {
    return null;
  }

  const maybeStyleAndLayout = getStyleAndLayout(inspectedElementID);

  if (maybeStyleAndLayout === null) {
    return null;
  }

  const layout = maybeStyleAndLayout.layout,
        style = maybeStyleAndLayout.style;
  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, layout !== null && /*#__PURE__*/external_react_["createElement"](LayoutViewer_LayoutViewer, {
    id: inspectedElementID,
    layout: layout
  }), style !== null && /*#__PURE__*/external_react_["createElement"](StyleEditor_StyleEditor, {
    id: inspectedElementID,
    style: style !== null ? style : {}
  }));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/InspectedElementView.css
var InspectedElementView = __webpack_require__(16);
var InspectedElementView_default = /*#__PURE__*/__webpack_require__.n(InspectedElementView);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/InspectedElementView.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */




















function InspectedElementView_InspectedElementView({
  copyInspectedElementPath,
  element,
  getInspectedElementPath,
  inspectedElement,
  storeAsGlobal
}) {
  const id = element.id;
  const owners = inspectedElement.owners,
        rendererPackageName = inspectedElement.rendererPackageName,
        rendererVersion = inspectedElement.rendererVersion,
        rootType = inspectedElement.rootType,
        source = inspectedElement.source;
  const bridge = Object(external_react_["useContext"])(BridgeContext);
  const store = Object(external_react_["useContext"])(StoreContext);

  const _useContext = Object(external_react_["useContext"])(ContextMenuContext),
        isContextMenuEnabledForInspectedElement = _useContext.isEnabledForInspectedElement,
        viewAttributeSourceFunction = _useContext.viewAttributeSourceFunction;

  const rendererLabel = rendererPackageName !== null && rendererVersion !== null ? `${rendererPackageName}@${rendererVersion}` : null;
  const showOwnersList = owners !== null && owners.length > 0;
  const showRenderedBy = showOwnersList || rendererLabel !== null || rootType !== null;
  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementView_default.a.InspectedElement
  }, /*#__PURE__*/external_react_["createElement"](HocBadges_HocBadges, {
    element: element
  }), /*#__PURE__*/external_react_["createElement"](InspectedElementPropsTree, {
    bridge: bridge,
    getInspectedElementPath: getInspectedElementPath,
    inspectedElement: inspectedElement,
    store: store
  }), /*#__PURE__*/external_react_["createElement"](InspectedElementSuspenseToggle, {
    bridge: bridge,
    inspectedElement: inspectedElement,
    store: store
  }), /*#__PURE__*/external_react_["createElement"](InspectedElementStateTree, {
    bridge: bridge,
    getInspectedElementPath: getInspectedElementPath,
    inspectedElement: inspectedElement,
    store: store
  }), /*#__PURE__*/external_react_["createElement"](Components_InspectedElementHooksTree, {
    bridge: bridge,
    getInspectedElementPath: getInspectedElementPath,
    inspectedElement: inspectedElement,
    store: store
  }), /*#__PURE__*/external_react_["createElement"](InspectedElementContextTree, {
    bridge: bridge,
    getInspectedElementPath: getInspectedElementPath,
    inspectedElement: inspectedElement,
    store: store
  }), /*#__PURE__*/external_react_["createElement"](NativeStyleEditorWrapper, null), showRenderedBy && /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementView_default.a.Owners
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementView_default.a.OwnersHeader
  }, "rendered by"), showOwnersList && owners.map(owner => /*#__PURE__*/external_react_["createElement"](OwnerView, {
    key: owner.id,
    displayName: owner.displayName || 'Anonymous',
    hocDisplayNames: owner.hocDisplayNames,
    id: owner.id,
    isInStore: store.containsElement(owner.id),
    type: owner.type
  })), rootType !== null && /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementView_default.a.OwnersMetaField
  }, rootType), rendererLabel !== null && /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementView_default.a.OwnersMetaField
  }, rendererLabel)), source !== null && /*#__PURE__*/external_react_["createElement"](Source, {
    fileName: source.fileName,
    lineNumber: source.lineNumber
  })), isContextMenuEnabledForInspectedElement && /*#__PURE__*/external_react_["createElement"](ContextMenu_ContextMenu, {
    id: "InspectedElement"
  }, data => /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"](ContextMenuItem_ContextMenuItem, {
    onClick: () => copyInspectedElementPath(id, data.path),
    title: "Copy value to clipboard"
  }, /*#__PURE__*/external_react_["createElement"](Icon_Icon, {
    className: InspectedElementView_default.a.ContextMenuIcon,
    type: "copy"
  }), " Copy value to clipboard"), /*#__PURE__*/external_react_["createElement"](ContextMenuItem_ContextMenuItem, {
    onClick: () => storeAsGlobal(id, data.path),
    title: "Store as global variable"
  }, /*#__PURE__*/external_react_["createElement"](Icon_Icon, {
    className: InspectedElementView_default.a.ContextMenuIcon,
    type: "store-as-global-variable"
  }), ' ', "Store as global variable"), viewAttributeSourceFunction !== null && data.type === 'function' && /*#__PURE__*/external_react_["createElement"](ContextMenuItem_ContextMenuItem, {
    onClick: () => viewAttributeSourceFunction(id, data.path),
    title: "Go to definition"
  }, /*#__PURE__*/external_react_["createElement"](Icon_Icon, {
    className: InspectedElementView_default.a.ContextMenuIcon,
    type: "code"
  }), " Go to definition"))));
} // This function is based on describeComponentFrame() in packages/shared/ReactComponentStackFrame

function formatSourceForDisplay(fileName, lineNumber) {
  const BEFORE_SLASH_RE = /^(.*)[\\\/]/;
  let nameOnly = fileName.replace(BEFORE_SLASH_RE, ''); // In DEV, include code for a common special case:
  // prefer "folder/index.js" instead of just "index.js".

  if (/^index\./.test(nameOnly)) {
    const match = fileName.match(BEFORE_SLASH_RE);

    if (match) {
      const pathBeforeSlash = match[1];

      if (pathBeforeSlash) {
        const folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
        nameOnly = folderName + '/' + nameOnly;
      }
    }
  }

  return `${nameOnly}:${lineNumber}`;
}

function Source({
  fileName,
  lineNumber
}) {
  const handleCopy = () => Object(clipboard["copy"])(`${fileName}:${lineNumber}`);

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementView_default.a.Source
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementView_default.a.SourceHeaderRow
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementView_default.a.SourceHeader
  }, "source"), /*#__PURE__*/external_react_["createElement"](Button_Button, {
    onClick: handleCopy,
    title: "Copy to clipboard"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "copy"
  }))), /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElementView_default.a.SourceOneLiner
  }, formatSourceForDisplay(fileName, lineNumber)));
}

function OwnerView({
  displayName,
  hocDisplayNames,
  id,
  isInStore,
  type
}) {
  const dispatch = Object(external_react_["useContext"])(TreeDispatcherContext);

  const _useHighlightNativeEl = useHighlightNativeElement(),
        highlightNativeElement = _useHighlightNativeEl.highlightNativeElement,
        clearHighlightNativeElement = _useHighlightNativeEl.clearHighlightNativeElement;

  const handleClick = Object(external_react_["useCallback"])(() => dispatch({
    type: 'SELECT_ELEMENT_BY_ID',
    payload: id
  }), [dispatch, id]);

  const onMouseEnter = () => highlightNativeElement(id);

  const onMouseLeave = clearHighlightNativeElement;
  return /*#__PURE__*/external_react_["createElement"](Button_Button, {
    key: id,
    className: InspectedElementView_default.a.OwnerButton,
    disabled: !isInStore,
    onClick: handleClick,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave
  }, /*#__PURE__*/external_react_["createElement"]("span", {
    className: InspectedElementView_default.a.OwnerContent
  }, /*#__PURE__*/external_react_["createElement"]("span", {
    className: `${InspectedElementView_default.a.Owner} ${isInStore ? '' : InspectedElementView_default.a.NotInStore}`,
    title: displayName
  }, displayName), /*#__PURE__*/external_react_["createElement"](Badge_Badge, {
    hocDisplayNames: hocDisplayNames,
    type: type
  })));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/InspectedElement.css
var InspectedElement = __webpack_require__(21);
var InspectedElement_default = /*#__PURE__*/__webpack_require__.n(InspectedElement);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/InspectedElement.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */














function InspectedElementWrapper(_) {
  const _useContext = Object(external_react_["useContext"])(TreeStateContext),
        inspectedElementID = _useContext.inspectedElementID;

  const dispatch = Object(external_react_["useContext"])(TreeDispatcherContext);

  const _useContext2 = Object(external_react_["useContext"])(Components_ViewElementSourceContext),
        canViewElementSourceFunction = _useContext2.canViewElementSourceFunction,
        viewElementSourceFunction = _useContext2.viewElementSourceFunction;

  const bridge = Object(external_react_["useContext"])(BridgeContext);
  const store = Object(external_react_["useContext"])(StoreContext);

  const _useContext3 = Object(external_react_["useContext"])(ModalDialogContext),
        modalDialogDispatch = _useContext3.dispatch;

  const _useContext4 = Object(external_react_["useContext"])(InspectedElementContext),
        copyInspectedElementPath = _useContext4.copyInspectedElementPath,
        getInspectedElementPath = _useContext4.getInspectedElementPath,
        getInspectedElement = _useContext4.getInspectedElement,
        storeAsGlobal = _useContext4.storeAsGlobal;

  const element = inspectedElementID !== null ? store.getElementByID(inspectedElementID) : null;
  const inspectedElement = inspectedElementID != null ? getInspectedElement(inspectedElementID) : null;
  const highlightElement = Object(external_react_["useCallback"])(() => {
    if (element !== null && inspectedElementID !== null) {
      const rendererID = store.getRendererIDForElement(inspectedElementID);

      if (rendererID !== null) {
        bridge.send('highlightNativeElement', {
          displayName: element.displayName,
          hideAfterTimeout: true,
          id: inspectedElementID,
          openNativeElementsPanel: true,
          rendererID,
          scrollIntoView: true
        });
      }
    }
  }, [bridge, element, inspectedElementID, store]);
  const logElement = Object(external_react_["useCallback"])(() => {
    if (inspectedElementID !== null) {
      const rendererID = store.getRendererIDForElement(inspectedElementID);

      if (rendererID !== null) {
        bridge.send('logElementToConsole', {
          id: inspectedElementID,
          rendererID
        });
      }
    }
  }, [bridge, inspectedElementID, store]);
  const viewSource = Object(external_react_["useCallback"])(() => {
    if (viewElementSourceFunction != null && inspectedElement !== null) {
      viewElementSourceFunction(inspectedElement.id, inspectedElement);
    }
  }, [inspectedElement, viewElementSourceFunction]); // In some cases (e.g. FB internal usage) the standalone shell might not be able to view the source.
  // To detect this case, we defer to an injected helper function (if present).

  const canViewSource = inspectedElement !== null && inspectedElement.canViewSource && viewElementSourceFunction !== null && (canViewElementSourceFunction === null || canViewElementSourceFunction(inspectedElement));
  const isSuspended = element !== null && element.type === types["n" /* ElementTypeSuspense */] && inspectedElement != null && inspectedElement.state != null;
  const canToggleSuspense = inspectedElement != null && inspectedElement.canToggleSuspense; // TODO (suspense toggle) Would be nice to eventually use a two setState pattern here as well.

  const toggleSuspended = Object(external_react_["useCallback"])(() => {
    let nearestSuspenseElement = null;
    let currentElement = element;

    while (currentElement !== null) {
      if (currentElement.type === types["n" /* ElementTypeSuspense */]) {
        nearestSuspenseElement = currentElement;
        break;
      } else if (currentElement.parentID > 0) {
        currentElement = store.getElementByID(currentElement.parentID);
      } else {
        currentElement = null;
      }
    } // If we didn't find a Suspense ancestor, we can't suspend.
    // Instead we can show a warning to the user.


    if (nearestSuspenseElement === null) {
      modalDialogDispatch({
        type: 'SHOW',
        content: /*#__PURE__*/external_react_["createElement"](CannotSuspendWarningMessage, null)
      });
    } else {
      const nearestSuspenseElementID = nearestSuspenseElement.id; // If we're suspending from an arbitrary (non-Suspense) component, select the nearest Suspense element in the Tree.
      // This way when the fallback UI is shown and the current element is hidden, something meaningful is selected.

      if (nearestSuspenseElement !== element) {
        dispatch({
          type: 'SELECT_ELEMENT_BY_ID',
          payload: nearestSuspenseElementID
        });
      }

      const rendererID = store.getRendererIDForElement(nearestSuspenseElementID); // Toggle suspended

      if (rendererID !== null) {
        bridge.send('overrideSuspense', {
          id: nearestSuspenseElementID,
          rendererID,
          forceFallback: !isSuspended
        });
      }
    }
  }, [bridge, dispatch, element, isSuspended, modalDialogDispatch, store]);

  if (element === null) {
    return /*#__PURE__*/external_react_["createElement"]("div", {
      className: InspectedElement_default.a.InspectedElement
    }, /*#__PURE__*/external_react_["createElement"]("div", {
      className: InspectedElement_default.a.TitleRow
    }));
  }

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElement_default.a.InspectedElement
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElement_default.a.TitleRow
  }, element.key && /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElement_default.a.Key,
    title: `key "${element.key}"`
  }, element.key), /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElement_default.a.KeyArrow
  })), /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElement_default.a.SelectedComponentName
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElement_default.a.Component,
    title: element.displayName
  }, element.displayName)), canToggleSuspense && /*#__PURE__*/external_react_["createElement"](Toggle_Toggle, {
    className: InspectedElement_default.a.IconButton,
    isChecked: isSuspended,
    onChange: toggleSuspended,
    title: isSuspended ? 'Unsuspend the selected component' : 'Suspend the selected component'
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "suspend"
  })), store.supportsNativeInspection && /*#__PURE__*/external_react_["createElement"](Button_Button, {
    className: InspectedElement_default.a.IconButton,
    onClick: highlightElement,
    title: "Inspect the matching DOM element"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "view-dom"
  })), /*#__PURE__*/external_react_["createElement"](Button_Button, {
    className: InspectedElement_default.a.IconButton,
    onClick: logElement,
    title: "Log this component data to the console"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "log-data"
  })), /*#__PURE__*/external_react_["createElement"](Button_Button, {
    className: InspectedElement_default.a.IconButton,
    disabled: !canViewSource,
    onClick: viewSource,
    title: "View source for this element"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "view-source"
  }))), inspectedElement === null && /*#__PURE__*/external_react_["createElement"]("div", {
    className: InspectedElement_default.a.Loading
  }, "Loading..."), inspectedElement !== null && /*#__PURE__*/external_react_["createElement"](InspectedElementView_InspectedElementView, {
    key: inspectedElementID
    /* Force reset when selected Element changes */
    ,
    copyInspectedElementPath: copyInspectedElementPath,
    element: element,
    getInspectedElementPath: getInspectedElementPath,
    inspectedElement: inspectedElement,
    storeAsGlobal: storeAsGlobal
  }));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/TabBar.css
var TabBar = __webpack_require__(19);
var TabBar_default = /*#__PURE__*/__webpack_require__.n(TabBar);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/TabBar.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






function TabBar_TabBar({
  currentTab,
  disabled = false,
  id: groupName,
  selectTab,
  tabs,
  type
}) {
  if (!tabs.some(tab => tab.id === currentTab)) {
    selectTab(tabs[0].id);
  }

  const onChange = Object(external_react_["useCallback"])(({
    currentTarget
  }) => selectTab(currentTarget.value), [selectTab]);
  const handleKeyDown = Object(external_react_["useCallback"])(event => {
    switch (event.key) {
      case 'ArrowDown':
      case 'ArrowLeft':
      case 'ArrowRight':
      case 'ArrowUp':
        event.stopPropagation();
        break;

      default:
        break;
    }
  }, []);
  let iconSizeClassName;
  let tabLabelClassName;
  let tabSizeClassName;

  switch (type) {
    case 'navigation':
      iconSizeClassName = TabBar_default.a.IconSizeNavigation;
      tabLabelClassName = TabBar_default.a.TabLabelNavigation;
      tabSizeClassName = TabBar_default.a.TabSizeNavigation;
      break;

    case 'profiler':
      iconSizeClassName = TabBar_default.a.IconSizeProfiler;
      tabLabelClassName = TabBar_default.a.TabLabelProfiler;
      tabSizeClassName = TabBar_default.a.TabSizeProfiler;
      break;

    case 'settings':
      iconSizeClassName = TabBar_default.a.IconSizeSettings;
      tabLabelClassName = TabBar_default.a.TabLabelSettings;
      tabSizeClassName = TabBar_default.a.TabSizeSettings;
      break;

    default:
      throw Error(`Unsupported type "${type}"`);
  }

  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, tabs.map(({
    icon,
    id,
    label,
    title
  }) => {
    let button = /*#__PURE__*/external_react_["createElement"]("label", {
      className: [tabSizeClassName, disabled ? TabBar_default.a.TabDisabled : TabBar_default.a.Tab, !disabled && currentTab === id ? TabBar_default.a.TabCurrent : ''].join(' '),
      key: id,
      onKeyDown: handleKeyDown,
      onMouseDown: () => selectTab(id)
    }, /*#__PURE__*/external_react_["createElement"]("input", {
      type: "radio",
      className: TabBar_default.a.Input,
      checked: currentTab === id,
      disabled: disabled,
      name: groupName,
      value: id,
      onChange: onChange
    }), /*#__PURE__*/external_react_["createElement"](Icon_Icon, {
      className: `${disabled ? TabBar_default.a.IconDisabled : ''} ${iconSizeClassName}`,
      type: icon
    }), /*#__PURE__*/external_react_["createElement"]("span", {
      className: tabLabelClassName
    }, label));

    if (title) {
      button = /*#__PURE__*/external_react_["createElement"](Tooltip, {
        key: id,
        className: Tooltip_default.a.Tooltip,
        label: title
      }, button);
    }

    return button;
  }));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Settings/SettingsShared.css
var SettingsShared = __webpack_require__(6);
var SettingsShared_default = /*#__PURE__*/__webpack_require__.n(SettingsShared);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Settings/ComponentsSettings.js
function ComponentsSettings_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function ComponentsSettings_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ComponentsSettings_ownKeys(Object(source), true).forEach(function (key) { ComponentsSettings_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ComponentsSettings_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ComponentsSettings_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function ComponentsSettings_slicedToArray(arr, i) { return ComponentsSettings_arrayWithHoles(arr) || ComponentsSettings_iterableToArrayLimit(arr, i) || ComponentsSettings_unsupportedIterableToArray(arr, i) || ComponentsSettings_nonIterableRest(); }

function ComponentsSettings_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function ComponentsSettings_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ComponentsSettings_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ComponentsSettings_arrayLikeToArray(o, minLen); }

function ComponentsSettings_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function ComponentsSettings_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function ComponentsSettings_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */









function ComponentsSettings(_) {
  const store = Object(external_react_["useContext"])(StoreContext);
  const collapseNodesByDefaultSubscription = Object(external_react_["useMemo"])(() => ({
    getCurrentValue: () => store.collapseNodesByDefault,
    subscribe: callback => {
      store.addListener('collapseNodesByDefault', callback);
      return () => store.removeListener('collapseNodesByDefault', callback);
    }
  }), [store]);
  const collapseNodesByDefault = useSubscription(collapseNodesByDefaultSubscription);
  const updateCollapseNodesByDefault = Object(external_react_["useCallback"])(({
    currentTarget
  }) => {
    store.collapseNodesByDefault = !currentTarget.checked;
  }, [store]);

  const _useState = Object(external_react_["useState"])(() => [...store.componentFilters]),
        _useState2 = ComponentsSettings_slicedToArray(_useState, 2),
        componentFilters = _useState2[0],
        setComponentFilters = _useState2[1];

  const addFilter = Object(external_react_["useCallback"])(() => {
    setComponentFilters(prevComponentFilters => {
      return [...prevComponentFilters, {
        type: types["b" /* ComponentFilterElementType */],
        value: types["i" /* ElementTypeHostComponent */],
        isEnabled: true
      }];
    });
  }, []);
  const changeFilterType = Object(external_react_["useCallback"])((componentFilter, type) => {
    setComponentFilters(prevComponentFilters => {
      const cloned = [...prevComponentFilters];
      const index = prevComponentFilters.indexOf(componentFilter);

      if (index >= 0) {
        if (type === types["b" /* ComponentFilterElementType */]) {
          cloned[index] = {
            type: types["b" /* ComponentFilterElementType */],
            isEnabled: componentFilter.isEnabled,
            value: types["i" /* ElementTypeHostComponent */]
          };
        } else if (type === types["a" /* ComponentFilterDisplayName */]) {
          cloned[index] = {
            type: types["a" /* ComponentFilterDisplayName */],
            isEnabled: componentFilter.isEnabled,
            isValid: true,
            value: ''
          };
        } else if (type === types["d" /* ComponentFilterLocation */]) {
          cloned[index] = {
            type: types["d" /* ComponentFilterLocation */],
            isEnabled: componentFilter.isEnabled,
            isValid: true,
            value: ''
          };
        } else if (type === types["c" /* ComponentFilterHOC */]) {
          cloned[index] = {
            type: types["c" /* ComponentFilterHOC */],
            isEnabled: componentFilter.isEnabled,
            isValid: true
          };
        }
      }

      return cloned;
    });
  }, []);
  const updateFilterValueElementType = Object(external_react_["useCallback"])((componentFilter, value) => {
    if (componentFilter.type !== types["b" /* ComponentFilterElementType */]) {
      throw Error('Invalid value for element type filter');
    }

    setComponentFilters(prevComponentFilters => {
      const cloned = [...prevComponentFilters];

      if (componentFilter.type === types["b" /* ComponentFilterElementType */]) {
        const index = prevComponentFilters.indexOf(componentFilter);

        if (index >= 0) {
          cloned[index] = ComponentsSettings_objectSpread(ComponentsSettings_objectSpread({}, componentFilter), {}, {
            value
          });
        }
      }

      return cloned;
    });
  }, []);
  const updateFilterValueRegExp = Object(external_react_["useCallback"])((componentFilter, value) => {
    if (componentFilter.type === types["b" /* ComponentFilterElementType */]) {
      throw Error('Invalid value for element type filter');
    }

    setComponentFilters(prevComponentFilters => {
      const cloned = [...prevComponentFilters];

      if (componentFilter.type === types["a" /* ComponentFilterDisplayName */] || componentFilter.type === types["d" /* ComponentFilterLocation */]) {
        const index = prevComponentFilters.indexOf(componentFilter);

        if (index >= 0) {
          let isValid = true;

          try {
            new RegExp(value); // eslint-disable-line no-new
          } catch (error) {
            isValid = false;
          }

          cloned[index] = ComponentsSettings_objectSpread(ComponentsSettings_objectSpread({}, componentFilter), {}, {
            isValid,
            value
          });
        }
      }

      return cloned;
    });
  }, []);
  const removeFilter = Object(external_react_["useCallback"])(index => {
    setComponentFilters(prevComponentFilters => {
      const cloned = [...prevComponentFilters];
      cloned.splice(index, 1);
      return cloned;
    });
  }, []);
  const toggleFilterIsEnabled = Object(external_react_["useCallback"])((componentFilter, isEnabled) => {
    setComponentFilters(prevComponentFilters => {
      const cloned = [...prevComponentFilters];
      const index = prevComponentFilters.indexOf(componentFilter);

      if (index >= 0) {
        if (componentFilter.type === types["b" /* ComponentFilterElementType */]) {
          cloned[index] = ComponentsSettings_objectSpread(ComponentsSettings_objectSpread({}, cloned[index]), {}, {
            isEnabled
          });
        } else if (componentFilter.type === types["a" /* ComponentFilterDisplayName */] || componentFilter.type === types["d" /* ComponentFilterLocation */]) {
          cloned[index] = ComponentsSettings_objectSpread(ComponentsSettings_objectSpread({}, cloned[index]), {}, {
            isEnabled
          });
        } else if (componentFilter.type === types["c" /* ComponentFilterHOC */]) {
          cloned[index] = ComponentsSettings_objectSpread(ComponentsSettings_objectSpread({}, cloned[index]), {}, {
            isEnabled
          });
        }
      }

      return cloned;
    });
  }, []); // Filter updates are expensive to apply (since they impact the entire tree).
  // Only apply them on unmount.
  // The Store will avoid doing any expensive work unless they've changed.
  // We just want to batch the work in the event that they do change.

  const componentFiltersRef = Object(external_react_["useRef"])(componentFilters);
  Object(external_react_["useEffect"])(() => {
    componentFiltersRef.current = componentFilters;
    return () => {};
  }, [componentFilters]);
  Object(external_react_["useEffect"])(() => () => {
    store.componentFilters = [...componentFiltersRef.current];
  }, [store]);
  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsShared_default.a.Settings
  }, /*#__PURE__*/external_react_["createElement"]("label", {
    className: SettingsShared_default.a.Setting
  }, /*#__PURE__*/external_react_["createElement"]("input", {
    type: "checkbox",
    checked: !collapseNodesByDefault,
    onChange: updateCollapseNodesByDefault
  }), ' ', "Expand component tree by default"), /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsShared_default.a.Header
  }, "Hide components where..."), /*#__PURE__*/external_react_["createElement"]("table", {
    className: SettingsShared_default.a.Table
  }, /*#__PURE__*/external_react_["createElement"]("tbody", null, componentFilters.length === 0 && /*#__PURE__*/external_react_["createElement"]("tr", {
    className: SettingsShared_default.a.TableRow
  }, /*#__PURE__*/external_react_["createElement"]("td", {
    className: SettingsShared_default.a.NoFiltersCell
  }, "No filters have been added.")), componentFilters.map((componentFilter, index) => /*#__PURE__*/external_react_["createElement"]("tr", {
    className: SettingsShared_default.a.TableRow,
    key: index
  }, /*#__PURE__*/external_react_["createElement"]("td", {
    className: SettingsShared_default.a.TableCell
  }, /*#__PURE__*/external_react_["createElement"](Toggle_Toggle, {
    className: componentFilter.isValid !== false ? '' : SettingsShared_default.a.InvalidRegExp,
    isChecked: componentFilter.isEnabled,
    onChange: isEnabled => toggleFilterIsEnabled(componentFilter, isEnabled),
    title: componentFilter.isValid === false ? 'Filter invalid' : componentFilter.isEnabled ? 'Filter enabled' : 'Filter disabled'
  }, /*#__PURE__*/external_react_["createElement"](ToggleIcon, {
    isEnabled: componentFilter.isEnabled,
    isValid: componentFilter.isValid == null || componentFilter.isValid === true
  }))), /*#__PURE__*/external_react_["createElement"]("td", {
    className: SettingsShared_default.a.TableCell
  }, /*#__PURE__*/external_react_["createElement"]("select", {
    className: SettingsShared_default.a.Select,
    value: componentFilter.type,
    onChange: ({
      currentTarget
    }) => changeFilterType(componentFilter, parseInt(currentTarget.value, 10))
  }, /*#__PURE__*/external_react_["createElement"]("option", {
    value: types["d" /* ComponentFilterLocation */]
  }, "location"), /*#__PURE__*/external_react_["createElement"]("option", {
    value: types["a" /* ComponentFilterDisplayName */]
  }, "name"), /*#__PURE__*/external_react_["createElement"]("option", {
    value: types["b" /* ComponentFilterElementType */]
  }, "type"), /*#__PURE__*/external_react_["createElement"]("option", {
    value: types["c" /* ComponentFilterHOC */]
  }, "hoc"))), /*#__PURE__*/external_react_["createElement"]("td", {
    className: SettingsShared_default.a.TableCell
  }, componentFilter.type === types["b" /* ComponentFilterElementType */] && 'equals', (componentFilter.type === types["d" /* ComponentFilterLocation */] || componentFilter.type === types["a" /* ComponentFilterDisplayName */]) && 'matches'), /*#__PURE__*/external_react_["createElement"]("td", {
    className: SettingsShared_default.a.TableCell
  }, componentFilter.type === types["b" /* ComponentFilterElementType */] && /*#__PURE__*/external_react_["createElement"]("select", {
    className: SettingsShared_default.a.Select,
    value: componentFilter.value,
    onChange: ({
      currentTarget
    }) => updateFilterValueElementType(componentFilter, parseInt(currentTarget.value, 10))
  }, /*#__PURE__*/external_react_["createElement"]("option", {
    value: types["e" /* ElementTypeClass */]
  }, "class"), /*#__PURE__*/external_react_["createElement"]("option", {
    value: types["f" /* ElementTypeContext */]
  }, "context"), /*#__PURE__*/external_react_["createElement"]("option", {
    value: types["h" /* ElementTypeFunction */]
  }, "function"), /*#__PURE__*/external_react_["createElement"]("option", {
    value: types["g" /* ElementTypeForwardRef */]
  }, "forward ref"), /*#__PURE__*/external_react_["createElement"]("option", {
    value: types["i" /* ElementTypeHostComponent */]
  }, "host (e.g. <div>)"), /*#__PURE__*/external_react_["createElement"]("option", {
    value: types["j" /* ElementTypeMemo */]
  }, "memo"), /*#__PURE__*/external_react_["createElement"]("option", {
    value: types["k" /* ElementTypeOtherOrUnknown */]
  }, "other"), /*#__PURE__*/external_react_["createElement"]("option", {
    value: types["l" /* ElementTypeProfiler */]
  }, "profiler"), /*#__PURE__*/external_react_["createElement"]("option", {
    value: types["n" /* ElementTypeSuspense */]
  }, "suspense")), (componentFilter.type === types["d" /* ComponentFilterLocation */] || componentFilter.type === types["a" /* ComponentFilterDisplayName */]) && /*#__PURE__*/external_react_["createElement"]("input", {
    className: SettingsShared_default.a.Input,
    type: "text",
    placeholder: "Regular expression",
    onChange: ({
      currentTarget
    }) => updateFilterValueRegExp(componentFilter, currentTarget.value),
    value: componentFilter.value
  })), /*#__PURE__*/external_react_["createElement"]("td", {
    className: SettingsShared_default.a.TableCell
  }, /*#__PURE__*/external_react_["createElement"](Button_Button, {
    onClick: () => removeFilter(index),
    title: "Delete filter"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "delete"
  }))))))), /*#__PURE__*/external_react_["createElement"](Button_Button, {
    onClick: addFilter
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    className: SettingsShared_default.a.ButtonIcon,
    type: "add"
  }), "Add filter"));
}

function ToggleIcon({
  isEnabled,
  isValid
}) {
  let className;

  if (isValid) {
    className = isEnabled ? SettingsShared_default.a.ToggleOn : SettingsShared_default.a.ToggleOff;
  } else {
    className = isEnabled ? SettingsShared_default.a.ToggleOnInvalid : SettingsShared_default.a.ToggleOffInvalid;
  }

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: className
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: isEnabled ? SettingsShared_default.a.ToggleInsideOn : SettingsShared_default.a.ToggleInsideOff
  }));
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Settings/DebuggingSettings.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */




function DebuggingSettings(_) {
  const _useContext = Object(external_react_["useContext"])(SettingsContext),
        appendComponentStack = _useContext.appendComponentStack,
        breakOnConsoleErrors = _useContext.breakOnConsoleErrors,
        setAppendComponentStack = _useContext.setAppendComponentStack,
        setBreakOnConsoleErrors = _useContext.setBreakOnConsoleErrors;

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsShared_default.a.Settings
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsShared_default.a.Setting
  }, /*#__PURE__*/external_react_["createElement"]("label", null, /*#__PURE__*/external_react_["createElement"]("input", {
    type: "checkbox",
    checked: appendComponentStack,
    onChange: ({
      currentTarget
    }) => setAppendComponentStack(currentTarget.checked)
  }), ' ', "Append component stacks to console warnings and errors.")), /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsShared_default.a.Setting
  }, /*#__PURE__*/external_react_["createElement"]("label", null, /*#__PURE__*/external_react_["createElement"]("input", {
    type: "checkbox",
    checked: breakOnConsoleErrors,
    onChange: ({
      currentTarget
    }) => setBreakOnConsoleErrors(currentTarget.checked)
  }), ' ', "Break on warnings")));
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Settings/GeneralSettings.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






function GeneralSettings(_) {
  const _useContext = Object(external_react_["useContext"])(SettingsContext),
        displayDensity = _useContext.displayDensity,
        setDisplayDensity = _useContext.setDisplayDensity,
        setTheme = _useContext.setTheme,
        setTraceUpdatesEnabled = _useContext.setTraceUpdatesEnabled,
        theme = _useContext.theme,
        traceUpdatesEnabled = _useContext.traceUpdatesEnabled;

  const _useContext2 = Object(external_react_["useContext"])(StoreContext),
        supportsTraceUpdates = _useContext2.supportsTraceUpdates;

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsShared_default.a.Settings
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsShared_default.a.Setting
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsShared_default.a.RadioLabel
  }, "Theme"), /*#__PURE__*/external_react_["createElement"]("select", {
    className: SettingsShared_default.a.Select,
    value: theme,
    onChange: ({
      currentTarget
    }) => setTheme(currentTarget.value)
  }, /*#__PURE__*/external_react_["createElement"]("option", {
    value: "auto"
  }, "Auto"), /*#__PURE__*/external_react_["createElement"]("option", {
    value: "light"
  }, "Light"), /*#__PURE__*/external_react_["createElement"]("option", {
    value: "dark"
  }, "Dark"))), /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsShared_default.a.Setting
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsShared_default.a.RadioLabel
  }, "Display density"), /*#__PURE__*/external_react_["createElement"]("select", {
    className: SettingsShared_default.a.Select,
    value: displayDensity,
    onChange: ({
      currentTarget
    }) => setDisplayDensity(currentTarget.value)
  }, /*#__PURE__*/external_react_["createElement"]("option", {
    value: "compact"
  }, "Compact"), /*#__PURE__*/external_react_["createElement"]("option", {
    value: "comfortable"
  }, "Comfortable"))), supportsTraceUpdates && /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsShared_default.a.Setting
  }, /*#__PURE__*/external_react_["createElement"]("label", null, /*#__PURE__*/external_react_["createElement"]("input", {
    type: "checkbox",
    checked: traceUpdatesEnabled,
    onChange: ({
      currentTarget
    }) => setTraceUpdatesEnabled(currentTarget.checked)
  }), ' ', "Highlight updates when components render.")), /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsShared_default.a.ReleaseNotes
  }, /*#__PURE__*/external_react_["createElement"]("a", {
    className: SettingsShared_default.a.ReleaseNotesLink,
    target: "_blank",
    rel: "noopener noreferrer",
    href: constants["a" /* CHANGE_LOG_URL */]
  }, "View release notes"), ' ', "for DevTools version ", "4.10.1-3a8c04e3b2"));
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/ProfilerContext.js
function ProfilerContext_slicedToArray(arr, i) { return ProfilerContext_arrayWithHoles(arr) || ProfilerContext_iterableToArrayLimit(arr, i) || ProfilerContext_unsupportedIterableToArray(arr, i) || ProfilerContext_nonIterableRest(); }

function ProfilerContext_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function ProfilerContext_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ProfilerContext_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ProfilerContext_arrayLikeToArray(o, minLen); }

function ProfilerContext_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function ProfilerContext_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function ProfilerContext_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






const ProfilerContext = /*#__PURE__*/Object(external_react_["createContext"])(null);
ProfilerContext.displayName = 'ProfilerContext';

function ProfilerContextController({
  children
}) {
  const store = Object(external_react_["useContext"])(StoreContext);

  const _useContext = Object(external_react_["useContext"])(TreeStateContext),
        selectedElementID = _useContext.selectedElementID;

  const dispatch = Object(external_react_["useContext"])(TreeDispatcherContext);
  const profilerStore = store.profilerStore;
  const subscription = Object(external_react_["useMemo"])(() => ({
    getCurrentValue: () => ({
      didRecordCommits: profilerStore.didRecordCommits,
      isProcessingData: profilerStore.isProcessingData,
      isProfiling: profilerStore.isProfiling,
      profilingData: profilerStore.profilingData,
      supportsProfiling: store.supportsProfiling
    }),
    subscribe: callback => {
      profilerStore.addListener('profilingData', callback);
      profilerStore.addListener('isProcessingData', callback);
      profilerStore.addListener('isProfiling', callback);
      store.addListener('supportsProfiling', callback);
      return () => {
        profilerStore.removeListener('profilingData', callback);
        profilerStore.removeListener('isProcessingData', callback);
        profilerStore.removeListener('isProfiling', callback);
        store.removeListener('supportsProfiling', callback);
      };
    }
  }), [profilerStore, store]);

  const _useSubscription = useSubscription(subscription),
        didRecordCommits = _useSubscription.didRecordCommits,
        isProcessingData = _useSubscription.isProcessingData,
        isProfiling = _useSubscription.isProfiling,
        profilingData = _useSubscription.profilingData,
        supportsProfiling = _useSubscription.supportsProfiling;

  const _useState = Object(external_react_["useState"])(null),
        _useState2 = ProfilerContext_slicedToArray(_useState, 2),
        prevProfilingData = _useState2[0],
        setPrevProfilingData = _useState2[1];

  const _useState3 = Object(external_react_["useState"])(null),
        _useState4 = ProfilerContext_slicedToArray(_useState3, 2),
        rootID = _useState4[0],
        setRootID = _useState4[1];

  const _useState5 = Object(external_react_["useState"])(null),
        _useState6 = ProfilerContext_slicedToArray(_useState5, 2),
        selectedFiberID = _useState6[0],
        selectFiberID = _useState6[1];

  const _useState7 = Object(external_react_["useState"])(null),
        _useState8 = ProfilerContext_slicedToArray(_useState7, 2),
        selectedFiberName = _useState8[0],
        selectFiberName = _useState8[1];

  const selectFiber = Object(external_react_["useCallback"])((id, name) => {
    selectFiberID(id);
    selectFiberName(name); // Sync selection to the Components tab for convenience.
    // Keep in mind that profiling data may be from a previous session.
    // If data has been imported, we should skip the selection sync.

    if (id !== null && profilingData !== null && profilingData.imported === false) {
      // We should still check to see if this element is still in the store.
      // It may have been removed during profiling.
      if (store.containsElement(id)) {
        dispatch({
          type: 'SELECT_ELEMENT_BY_ID',
          payload: id
        });
      }
    }
  }, [dispatch, selectFiberID, selectFiberName, store, profilingData]);
  const setRootIDAndClearFiber = Object(external_react_["useCallback"])(id => {
    selectFiber(null, null);
    setRootID(id);
  }, [setRootID, selectFiber]);

  if (prevProfilingData !== profilingData) {
    Object(external_react_dom_["unstable_batchedUpdates"])(() => {
      setPrevProfilingData(profilingData);
      const dataForRoots = profilingData !== null ? profilingData.dataForRoots : null;

      if (dataForRoots != null) {
        const firstRootID = dataForRoots.keys().next().value || null;

        if (rootID === null || !dataForRoots.has(rootID)) {
          let selectedElementRootID = null;

          if (selectedElementID !== null) {
            selectedElementRootID = store.getRootIDForElement(selectedElementID);
          }

          if (selectedElementRootID !== null && dataForRoots.has(selectedElementRootID)) {
            setRootIDAndClearFiber(selectedElementRootID);
          } else {
            setRootIDAndClearFiber(firstRootID);
          }
        }
      }
    });
  }

  const startProfiling = Object(external_react_["useCallback"])(() => store.profilerStore.startProfiling(), [store]);
  const stopProfiling = Object(external_react_["useCallback"])(() => store.profilerStore.stopProfiling(), [store]);

  const _useLocalStorage = useLocalStorage('React::DevTools::isCommitFilterEnabled', false),
        _useLocalStorage2 = ProfilerContext_slicedToArray(_useLocalStorage, 2),
        isCommitFilterEnabled = _useLocalStorage2[0],
        setIsCommitFilterEnabled = _useLocalStorage2[1];

  const _useLocalStorage3 = useLocalStorage('minCommitDuration', 0),
        _useLocalStorage4 = ProfilerContext_slicedToArray(_useLocalStorage3, 2),
        minCommitDuration = _useLocalStorage4[0],
        setMinCommitDuration = _useLocalStorage4[1];

  const _useState9 = Object(external_react_["useState"])(null),
        _useState10 = ProfilerContext_slicedToArray(_useState9, 2),
        selectedCommitIndex = _useState10[0],
        selectCommitIndex = _useState10[1];

  const _useState11 = Object(external_react_["useState"])('flame-chart'),
        _useState12 = ProfilerContext_slicedToArray(_useState11, 2),
        selectedTabID = _useState12[0],
        selectTab = _useState12[1];

  const _useState13 = Object(external_react_["useState"])(null),
        _useState14 = ProfilerContext_slicedToArray(_useState13, 2),
        selectedInteractionID = _useState14[0],
        selectInteraction = _useState14[1];

  if (isProfiling) {
    Object(external_react_dom_["unstable_batchedUpdates"])(() => {
      if (selectedCommitIndex !== null) {
        selectCommitIndex(null);
      }

      if (selectedFiberID !== null) {
        selectFiberID(null);
        selectFiberName(null);
      }

      if (selectedInteractionID !== null) {
        selectInteraction(null);
      }
    });
  }

  const value = Object(external_react_["useMemo"])(() => ({
    selectedTabID,
    selectTab,
    didRecordCommits,
    isProcessingData,
    isProfiling,
    profilingData,
    startProfiling,
    stopProfiling,
    supportsProfiling,
    rootID,
    setRootID: setRootIDAndClearFiber,
    isCommitFilterEnabled,
    setIsCommitFilterEnabled,
    minCommitDuration,
    setMinCommitDuration,
    selectedCommitIndex,
    selectCommitIndex,
    selectedFiberID,
    selectedFiberName,
    selectFiber,
    selectedInteractionID,
    selectInteraction
  }), [selectedTabID, selectTab, didRecordCommits, isProcessingData, isProfiling, profilingData, startProfiling, stopProfiling, supportsProfiling, rootID, setRootID, setRootIDAndClearFiber, isCommitFilterEnabled, setIsCommitFilterEnabled, minCommitDuration, setMinCommitDuration, selectedCommitIndex, selectCommitIndex, selectedFiberID, selectedFiberName, selectFiber, selectedInteractionID, selectInteraction]);
  return /*#__PURE__*/external_react_["createElement"](ProfilerContext.Provider, {
    value: value
  }, children);
}


// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Settings/ProfilerSettings.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






function ProfilerSettings(_) {
  const _useContext = Object(external_react_["useContext"])(ProfilerContext),
        isCommitFilterEnabled = _useContext.isCommitFilterEnabled,
        minCommitDuration = _useContext.minCommitDuration,
        setIsCommitFilterEnabled = _useContext.setIsCommitFilterEnabled,
        setMinCommitDuration = _useContext.setMinCommitDuration;

  const store = Object(external_react_["useContext"])(StoreContext);
  const recordChangeDescriptionsSubscription = Object(external_react_["useMemo"])(() => ({
    getCurrentValue: () => store.recordChangeDescriptions,
    subscribe: callback => {
      store.addListener('recordChangeDescriptions', callback);
      return () => store.removeListener('recordChangeDescriptions', callback);
    }
  }), [store]);
  const recordChangeDescriptions = useSubscription(recordChangeDescriptionsSubscription);
  const updateRecordChangeDescriptions = Object(external_react_["useCallback"])(({
    currentTarget
  }) => {
    store.recordChangeDescriptions = currentTarget.checked;
  }, [store]);
  const updateMinCommitDuration = Object(external_react_["useCallback"])(event => {
    const newValue = parseFloat(event.currentTarget.value);
    setMinCommitDuration(Number.isNaN(newValue) || newValue <= 0 ? 0 : newValue);
  }, [setMinCommitDuration]);
  const updateIsCommitFilterEnabled = Object(external_react_["useCallback"])(event => {
    const checked = event.currentTarget.checked;
    setIsCommitFilterEnabled(checked);

    if (checked) {
      if (minCommitDurationInputRef.current !== null) {
        minCommitDurationInputRef.current.focus();
      }
    }
  }, [setIsCommitFilterEnabled]);
  const minCommitDurationInputRef = Object(external_react_["useRef"])(null);
  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsShared_default.a.Settings
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsShared_default.a.Setting
  }, /*#__PURE__*/external_react_["createElement"]("label", null, /*#__PURE__*/external_react_["createElement"]("input", {
    type: "checkbox",
    checked: recordChangeDescriptions,
    onChange: updateRecordChangeDescriptions
  }), ' ', "Record why each component rendered while profiling.")), /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsShared_default.a.Setting
  }, /*#__PURE__*/external_react_["createElement"]("label", null, /*#__PURE__*/external_react_["createElement"]("input", {
    checked: isCommitFilterEnabled,
    onChange: updateIsCommitFilterEnabled,
    type: "checkbox"
  }), ' ', "Hide commits below"), ' ', /*#__PURE__*/external_react_["createElement"]("input", {
    className: SettingsShared_default.a.Input,
    onChange: updateMinCommitDuration,
    ref: minCommitDurationInputRef,
    type: "number",
    value: minCommitDuration
  }), ' ', "(ms)"));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Settings/SettingsModal.css
var SettingsModal = __webpack_require__(43);
var SettingsModal_default = /*#__PURE__*/__webpack_require__.n(SettingsModal);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Settings/SettingsModal.js
function SettingsModal_slicedToArray(arr, i) { return SettingsModal_arrayWithHoles(arr) || SettingsModal_iterableToArrayLimit(arr, i) || SettingsModal_unsupportedIterableToArray(arr, i) || SettingsModal_nonIterableRest(); }

function SettingsModal_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function SettingsModal_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return SettingsModal_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return SettingsModal_arrayLikeToArray(o, minLen); }

function SettingsModal_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function SettingsModal_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function SettingsModal_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */













function SettingsModal_SettingsModal(_) {
  const _useContext = Object(external_react_["useContext"])(SettingsModalContext),
        isModalShowing = _useContext.isModalShowing,
        setIsModalShowing = _useContext.setIsModalShowing;

  const store = Object(external_react_["useContext"])(StoreContext);
  const profilerStore = store.profilerStore; // Updating preferences while profiling is in progress could break things (e.g. filtering)
  // Explicitly disallow it for now.

  const isProfilingSubscription = Object(external_react_["useMemo"])(() => ({
    getCurrentValue: () => profilerStore.isProfiling,
    subscribe: callback => {
      profilerStore.addListener('isProfiling', callback);
      return () => profilerStore.removeListener('isProfiling', callback);
    }
  }), [profilerStore]);
  const isProfiling = useSubscription(isProfilingSubscription);

  if (isProfiling && isModalShowing) {
    setIsModalShowing(false);
  }

  if (!isModalShowing) {
    return null;
  }

  return /*#__PURE__*/external_react_["createElement"](SettingsModalImpl, null);
}

function SettingsModalImpl(_) {
  const _useContext2 = Object(external_react_["useContext"])(SettingsModalContext),
        setIsModalShowing = _useContext2.setIsModalShowing;

  const dismissModal = Object(external_react_["useCallback"])(() => setIsModalShowing(false), [setIsModalShowing]);

  const _useLocalStorage = useLocalStorage('React::DevTools::selectedSettingsTabID', 'general'),
        _useLocalStorage2 = SettingsModal_slicedToArray(_useLocalStorage, 2),
        selectedTabID = _useLocalStorage2[0],
        selectTab = _useLocalStorage2[1];

  const modalRef = Object(external_react_["useRef"])(null);
  useModalDismissSignal(modalRef, dismissModal);
  Object(external_react_["useEffect"])(() => {
    if (modalRef.current !== null) {
      modalRef.current.focus();
    }
  }, [modalRef]);
  let view = null;

  switch (selectedTabID) {
    case 'components':
      view = /*#__PURE__*/external_react_["createElement"](ComponentsSettings, null);
      break;

    case 'debugging':
      view = /*#__PURE__*/external_react_["createElement"](DebuggingSettings, null);
      break;

    case 'general':
      view = /*#__PURE__*/external_react_["createElement"](GeneralSettings, null);
      break;

    case 'profiler':
      view = /*#__PURE__*/external_react_["createElement"](ProfilerSettings, null);
      break;

    default:
      break;
  }

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsModal_default.a.Background
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsModal_default.a.Modal,
    ref: modalRef
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsModal_default.a.Tabs
  }, /*#__PURE__*/external_react_["createElement"](TabBar_TabBar, {
    currentTab: selectedTabID,
    id: "Settings",
    selectTab: selectTab,
    tabs: SettingsModal_tabs,
    type: "settings"
  }), /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsModal_default.a.Spacer
  }), /*#__PURE__*/external_react_["createElement"](Button_Button, {
    onClick: dismissModal,
    title: "Close settings dialog"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "close"
  }))), /*#__PURE__*/external_react_["createElement"]("div", {
    className: SettingsModal_default.a.Content
  }, view)));
}

const SettingsModal_tabs = [{
  id: 'general',
  icon: 'settings',
  label: 'General'
}, {
  id: 'debugging',
  icon: 'bug',
  label: 'Debugging'
}, {
  id: 'components',
  icon: 'components',
  label: 'Components'
}, {
  id: 'profiler',
  icon: 'profiler',
  label: 'Profiler'
}];
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Components/Components.css
var Components = __webpack_require__(39);
var Components_default = /*#__PURE__*/__webpack_require__.n(Components);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Components/Components.js
function Components_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function Components_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Components_ownKeys(Object(source), true).forEach(function (key) { Components_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Components_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Components_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Components_slicedToArray(arr, i) { return Components_arrayWithHoles(arr) || Components_iterableToArrayLimit(arr, i) || Components_unsupportedIterableToArray(arr, i) || Components_nonIterableRest(); }

function Components_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function Components_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Components_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Components_arrayLikeToArray(o, minLen); }

function Components_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function Components_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function Components_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */














function Components_Components(_) {
  const wrapperElementRef = Object(external_react_["useRef"])(null);
  const resizeElementRef = Object(external_react_["useRef"])(null);

  const _useReducer = Object(external_react_["useReducer"])(resizeReducer, null, initResizeState),
        _useReducer2 = Components_slicedToArray(_useReducer, 2),
        state = _useReducer2[0],
        dispatch = _useReducer2[1];

  const horizontalPercentage = state.horizontalPercentage,
        verticalPercentage = state.verticalPercentage;
  Object(external_react_["useLayoutEffect"])(() => {
    const resizeElement = resizeElementRef.current;
    setResizeCSSVariable(resizeElement, 'horizontal', horizontalPercentage * 100);
    setResizeCSSVariable(resizeElement, 'vertical', verticalPercentage * 100);
  }, []);
  Object(external_react_["useEffect"])(() => {
    const timeoutID = setTimeout(() => {
      Object(storage["b" /* localStorageSetItem */])(LOCAL_STORAGE_KEY, JSON.stringify({
        horizontalPercentage,
        verticalPercentage
      }));
    }, 500);
    return () => clearTimeout(timeoutID);
  }, [horizontalPercentage, verticalPercentage]);
  const isResizing = state.isResizing;

  const onResizeStart = () => dispatch({
    type: 'ACTION_SET_IS_RESIZING',
    payload: true
  });

  let onResize;
  let onResizeEnd;

  if (isResizing) {
    onResizeEnd = () => dispatch({
      type: 'ACTION_SET_IS_RESIZING',
      payload: false
    });

    onResize = event => {
      const resizeElement = resizeElementRef.current;
      const wrapperElement = wrapperElementRef.current;

      if (!isResizing || wrapperElement === null || resizeElement === null) {
        return;
      }

      event.preventDefault();
      const orientation = getOrientation(wrapperElement);

      const _wrapperElement$getBo = wrapperElement.getBoundingClientRect(),
            height = _wrapperElement$getBo.height,
            width = _wrapperElement$getBo.width,
            left = _wrapperElement$getBo.left,
            top = _wrapperElement$getBo.top;

      const currentMousePosition = orientation === 'horizontal' ? event.clientX - left : event.clientY - top;
      const boundaryMin = MINIMUM_SIZE;
      const boundaryMax = orientation === 'horizontal' ? width - MINIMUM_SIZE : height - MINIMUM_SIZE;
      const isMousePositionInBounds = currentMousePosition > boundaryMin && currentMousePosition < boundaryMax;

      if (isMousePositionInBounds) {
        const resizedElementDimension = orientation === 'horizontal' ? width : height;
        const actionType = orientation === 'horizontal' ? 'ACTION_SET_HORIZONTAL_PERCENTAGE' : 'ACTION_SET_VERTICAL_PERCENTAGE';
        const percentage = currentMousePosition / resizedElementDimension * 100;
        setResizeCSSVariable(resizeElement, orientation, percentage);
        dispatch({
          type: actionType,
          payload: currentMousePosition / resizedElementDimension
        });
      }
    };
  }

  return /*#__PURE__*/external_react_["createElement"](SettingsModalContextController, null, /*#__PURE__*/external_react_["createElement"](OwnersListContextController, null, /*#__PURE__*/external_react_["createElement"](InspectedElementContextController, null, /*#__PURE__*/external_react_["createElement"]("div", {
    ref: wrapperElementRef,
    className: Components_default.a.Components,
    onMouseMove: onResize,
    onMouseLeave: onResizeEnd,
    onMouseUp: onResizeEnd
  }, /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("div", {
    ref: resizeElementRef,
    className: Components_default.a.TreeWrapper
  }, /*#__PURE__*/external_react_["createElement"](Tree_Tree, null)), /*#__PURE__*/external_react_["createElement"]("div", {
    className: Components_default.a.ResizeBarWrapper
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    onMouseDown: onResizeStart,
    className: Components_default.a.ResizeBar
  })), /*#__PURE__*/external_react_["createElement"]("div", {
    className: Components_default.a.InspectedElementWrapper
  }, /*#__PURE__*/external_react_["createElement"](NativeStyleContextController, null, /*#__PURE__*/external_react_["createElement"](external_react_["Suspense"], {
    fallback: /*#__PURE__*/external_react_["createElement"](Components_Loading, null)
  }, /*#__PURE__*/external_react_["createElement"](InspectedElementWrapper, null)))), /*#__PURE__*/external_react_["createElement"](ModalDialog_ModalDialog, null), /*#__PURE__*/external_react_["createElement"](SettingsModal_SettingsModal, null))))));
}

function Components_Loading() {
  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: Components_default.a.Loading
  }, "Loading...");
}

const LOCAL_STORAGE_KEY = 'React::DevTools::createResizeReducer';
const VERTICAL_MODE_MAX_WIDTH = 600;
const MINIMUM_SIZE = 50;

function initResizeState() {
  let horizontalPercentage = 0.65;
  let verticalPercentage = 0.5;

  try {
    let data = Object(storage["a" /* localStorageGetItem */])(LOCAL_STORAGE_KEY);

    if (data != null) {
      data = JSON.parse(data);
      horizontalPercentage = data.horizontalPercentage;
      verticalPercentage = data.verticalPercentage;
    }
  } catch (error) {}

  return {
    horizontalPercentage,
    isResizing: false,
    verticalPercentage
  };
}

function resizeReducer(state, action) {
  switch (action.type) {
    case 'ACTION_SET_IS_RESIZING':
      return Components_objectSpread(Components_objectSpread({}, state), {}, {
        isResizing: action.payload
      });

    case 'ACTION_SET_HORIZONTAL_PERCENTAGE':
      return Components_objectSpread(Components_objectSpread({}, state), {}, {
        horizontalPercentage: action.payload
      });

    case 'ACTION_SET_VERTICAL_PERCENTAGE':
      return Components_objectSpread(Components_objectSpread({}, state), {}, {
        verticalPercentage: action.payload
      });

    default:
      return state;
  }
}

function getOrientation(wrapperElement) {
  if (wrapperElement != null) {
    const _wrapperElement$getBo2 = wrapperElement.getBoundingClientRect(),
          width = _wrapperElement$getBo2.width;

    return width > VERTICAL_MODE_MAX_WIDTH ? 'horizontal' : 'vertical';
  }

  return null;
}

function setResizeCSSVariable(resizeElement, orientation, percentage) {
  if (resizeElement !== null && orientation !== null) {
    resizeElement.style.setProperty(`--${orientation}-resize-percentage`, `${percentage}%`);
  }
}

/* harmony default export */ var views_Components_Components = (portaledContent(Components_Components));
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/ClearProfilingDataButton.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






function ClearProfilingDataButton() {
  const store = Object(external_react_["useContext"])(StoreContext);

  const _useContext = Object(external_react_["useContext"])(ProfilerContext),
        didRecordCommits = _useContext.didRecordCommits,
        isProfiling = _useContext.isProfiling;

  const profilerStore = store.profilerStore;
  const clear = Object(external_react_["useCallback"])(() => profilerStore.clear(), [profilerStore]);
  return /*#__PURE__*/external_react_["createElement"](Button_Button, {
    disabled: isProfiling || !didRecordCommits,
    onClick: clear,
    title: "Clear profiling data"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "clear"
  }));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/NoCommitData.css
var NoCommitData = __webpack_require__(59);
var NoCommitData_default = /*#__PURE__*/__webpack_require__.n(NoCommitData);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/NoCommitData.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


function NoCommitData_NoCommitData(_) {
  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: NoCommitData_default.a.NoCommitData
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: NoCommitData_default.a.Header
  }, "There is no data matching the current filter criteria."), /*#__PURE__*/external_react_["createElement"]("div", {
    className: NoCommitData_default.a.FilterMessage
  }, "Try adjusting the commit filter in Profiler settings."));
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/constants.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const barWidthThreshold = 2;
const constants_interactionCommitSize = 10;
const constants_interactionLabelWidth = 200;
const maxBarWidth = 30;
const minBarWidth = 5;
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/ChartNode.css
var ChartNode = __webpack_require__(52);
var ChartNode_default = /*#__PURE__*/__webpack_require__.n(ChartNode);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/ChartNode.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


const minWidthToDisplay = 35;
function ChartNode_ChartNode({
  color,
  height,
  isDimmed = false,
  label,
  onClick,
  onMouseEnter,
  onMouseLeave,
  onDoubleClick,
  textStyle,
  width,
  x,
  y
}) {
  return /*#__PURE__*/external_react_["createElement"]("g", {
    className: ChartNode_default.a.Group,
    transform: `translate(${x},${y})`
  }, /*#__PURE__*/external_react_["createElement"]("rect", {
    width: width,
    height: height,
    fill: color,
    onClick: onClick,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    onDoubleClick: onDoubleClick,
    className: ChartNode_default.a.Rect,
    style: {
      opacity: isDimmed ? 0.5 : 1
    }
  }), width >= minWidthToDisplay && /*#__PURE__*/external_react_["createElement"]("foreignObject", {
    width: width,
    height: height,
    className: ChartNode_default.a.ForeignObject,
    style: {
      paddingLeft: x < 0 ? -x : 0,
      opacity: isDimmed ? 0.75 : 1,
      display: width < minWidthToDisplay ? 'none' : 'block'
    },
    y: 0
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: ChartNode_default.a.Div,
    style: textStyle
  }, label)));
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/CommitFlamegraphListItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */








function CommitFlamegraphListItem({
  data,
  index,
  style
}) {
  const chartData = data.chartData,
        onElementMouseEnter = data.onElementMouseEnter,
        onElementMouseLeave = data.onElementMouseLeave,
        scaleX = data.scaleX,
        selectedChartNode = data.selectedChartNode,
        selectedChartNodeIndex = data.selectedChartNodeIndex,
        selectFiber = data.selectFiber,
        width = data.width;
  const renderPathNodes = chartData.renderPathNodes,
        maxSelfDuration = chartData.maxSelfDuration,
        rows = chartData.rows;

  const _useContext = Object(external_react_["useContext"])(SettingsContext),
        lineHeight = _useContext.lineHeight;

  const handleClick = Object(external_react_["useCallback"])((event, id, name) => {
    event.stopPropagation();
    selectFiber(id, name);
  }, [selectFiber]);

  const handleMouseEnter = nodeData => {
    const id = nodeData.id,
          name = nodeData.name;
    onElementMouseEnter({
      id,
      name
    });
  };

  const handleMouseLeave = () => {
    onElementMouseLeave();
  }; // List items are absolutely positioned using the CSS "top" attribute.
  // The "left" value will always be 0.
  // Since height is fixed, and width is based on the node's duration,
  // We can ignore those values as well.


  const top = parseInt(style.top, 10);
  const row = rows[index];
  const selectedNodeOffset = scaleX(selectedChartNode !== null ? selectedChartNode.offset : 0, width);
  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, row.map(chartNode => {
    const didRender = chartNode.didRender,
          id = chartNode.id,
          label = chartNode.label,
          name = chartNode.name,
          offset = chartNode.offset,
          selfDuration = chartNode.selfDuration,
          treeBaseDuration = chartNode.treeBaseDuration;
    const nodeOffset = scaleX(offset, width);
    const nodeWidth = scaleX(treeBaseDuration, width); // Filter out nodes that are too small to see or click.
    // This also helps render large trees faster.

    if (nodeWidth < barWidthThreshold) {
      return null;
    } // Filter out nodes that are outside of the horizontal window.


    if (nodeOffset + nodeWidth < selectedNodeOffset || nodeOffset > selectedNodeOffset + width) {
      return null;
    }

    let color = 'url(#didNotRenderPattern)';
    let textColor = 'var(--color-commit-did-not-render-pattern-text)';

    if (didRender) {
      color = getGradientColor(selfDuration / maxSelfDuration);
      textColor = 'var(--color-commit-gradient-text)';
    } else if (renderPathNodes.has(id)) {
      color = 'var(--color-commit-did-not-render-fill)';
      textColor = 'var(--color-commit-did-not-render-fill-text)';
    }

    return /*#__PURE__*/external_react_["createElement"](ChartNode_ChartNode, {
      color: color,
      height: lineHeight,
      isDimmed: index < selectedChartNodeIndex,
      key: id,
      label: label,
      onClick: event => handleClick(event, id, name),
      onMouseEnter: () => handleMouseEnter(chartNode),
      onMouseLeave: handleMouseLeave,
      textStyle: {
        color: textColor
      },
      width: nodeWidth,
      x: nodeOffset - selectedNodeOffset,
      y: top
    });
  }));
}

/* harmony default export */ var Profiler_CommitFlamegraphListItem = (/*#__PURE__*/Object(external_react_["memo"])(CommitFlamegraphListItem, areEqual));
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/WhatChanged.css
var WhatChanged = __webpack_require__(20);
var WhatChanged_default = /*#__PURE__*/__webpack_require__.n(WhatChanged);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/WhatChanged.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */





function WhatChanged_WhatChanged({
  fiberID
}) {
  const _useContext = Object(external_react_["useContext"])(StoreContext),
        profilerStore = _useContext.profilerStore;

  const _useContext2 = Object(external_react_["useContext"])(ProfilerContext),
        rootID = _useContext2.rootID,
        selectedCommitIndex = _useContext2.selectedCommitIndex; // TRICKY
  // Handle edge case where no commit is selected because of a min-duration filter update.
  // If the commit index is null, suspending for data below would throw an error.
  // TODO (ProfilerContext) This check should not be necessary.


  if (selectedCommitIndex === null) {
    return null;
  }

  const _profilerStore$getCom = profilerStore.getCommitData(rootID, selectedCommitIndex),
        changeDescriptions = _profilerStore$getCom.changeDescriptions;

  if (changeDescriptions === null) {
    return null;
  }

  const changeDescription = changeDescriptions.get(fiberID);

  if (changeDescription == null) {
    return null;
  }

  if (changeDescription.isFirstMount) {
    return /*#__PURE__*/external_react_["createElement"]("div", {
      className: WhatChanged_default.a.Component
    }, /*#__PURE__*/external_react_["createElement"]("label", {
      className: WhatChanged_default.a.Label
    }, "Why did this render?"), /*#__PURE__*/external_react_["createElement"]("div", {
      className: WhatChanged_default.a.Item
    }, "This is the first time the component rendered."));
  }

  const changes = [];

  if (changeDescription.context === true) {
    changes.push( /*#__PURE__*/external_react_["createElement"]("div", {
      key: "context",
      className: WhatChanged_default.a.Item
    }, "\u2022 Context changed"));
  } else if (typeof changeDescription.context === 'object' && changeDescription.context !== null && changeDescription.context.length !== 0) {
    changes.push( /*#__PURE__*/external_react_["createElement"]("div", {
      key: "context",
      className: WhatChanged_default.a.Item
    }, "\u2022 Context changed:", changeDescription.context.map(key => /*#__PURE__*/external_react_["createElement"]("span", {
      key: key,
      className: WhatChanged_default.a.Key
    }, key))));
  }

  if (changeDescription.didHooksChange) {
    changes.push( /*#__PURE__*/external_react_["createElement"]("div", {
      key: "hooks",
      className: WhatChanged_default.a.Item
    }, "\u2022 Hooks changed"));
  }

  if (changeDescription.props !== null && changeDescription.props.length !== 0) {
    changes.push( /*#__PURE__*/external_react_["createElement"]("div", {
      key: "props",
      className: WhatChanged_default.a.Item
    }, "\u2022 Props changed:", changeDescription.props.map(key => /*#__PURE__*/external_react_["createElement"]("span", {
      key: key,
      className: WhatChanged_default.a.Key
    }, key))));
  }

  if (changeDescription.state !== null && changeDescription.state.length !== 0) {
    changes.push( /*#__PURE__*/external_react_["createElement"]("div", {
      key: "state",
      className: WhatChanged_default.a.Item
    }, "\u2022 State changed:", changeDescription.state.map(key => /*#__PURE__*/external_react_["createElement"]("span", {
      key: key,
      className: WhatChanged_default.a.Key
    }, key))));
  }

  if (changes.length === 0) {
    changes.push( /*#__PURE__*/external_react_["createElement"]("div", {
      key: "nothing",
      className: WhatChanged_default.a.Item
    }, "The parent component rendered."));
  }

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: WhatChanged_default.a.Component
  }, /*#__PURE__*/external_react_["createElement"]("label", {
    className: WhatChanged_default.a.Label
  }, "Why did this render?"), changes);
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/HoveredFiberInfo.css
var HoveredFiberInfo = __webpack_require__(53);
var HoveredFiberInfo_default = /*#__PURE__*/__webpack_require__.n(HoveredFiberInfo);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/HoveredFiberInfo.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */







function HoveredFiberInfo_HoveredFiberInfo({
  fiberData
}) {
  const _useContext = Object(external_react_["useContext"])(StoreContext),
        profilerStore = _useContext.profilerStore;

  const _useContext2 = Object(external_react_["useContext"])(ProfilerContext),
        rootID = _useContext2.rootID,
        selectedCommitIndex = _useContext2.selectedCommitIndex;

  const id = fiberData.id,
        name = fiberData.name;
  const profilingCache = profilerStore.profilingCache;
  const commitIndices = profilingCache.getFiberCommits({
    fiberID: id,
    rootID: rootID
  });
  let renderDurationInfo = null;
  let i = 0;

  for (i = 0; i < commitIndices.length; i++) {
    const commitIndex = commitIndices[i];

    if (selectedCommitIndex === commitIndex) {
      const _profilerStore$getCom = profilerStore.getCommitData(rootID, commitIndex),
            fiberActualDurations = _profilerStore$getCom.fiberActualDurations,
            fiberSelfDurations = _profilerStore$getCom.fiberSelfDurations;

      const actualDuration = fiberActualDurations.get(id) || 0;
      const selfDuration = fiberSelfDurations.get(id) || 0;
      renderDurationInfo = /*#__PURE__*/external_react_["createElement"]("div", {
        key: commitIndex,
        className: HoveredFiberInfo_default.a.CurrentCommit
      }, formatDuration(selfDuration), "ms of ", formatDuration(actualDuration), "ms");
      break;
    }
  }

  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("div", {
    className: HoveredFiberInfo_default.a.Toolbar
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: HoveredFiberInfo_default.a.Component
  }, name)), /*#__PURE__*/external_react_["createElement"]("div", {
    className: HoveredFiberInfo_default.a.Content
  }, renderDurationInfo || /*#__PURE__*/external_react_["createElement"]("div", null, "Did not render."), /*#__PURE__*/external_react_["createElement"](WhatChanged_WhatChanged, {
    fiberID: id
  })));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/Tooltip.css
var Profiler_Tooltip = __webpack_require__(60);
var Profiler_Tooltip_default = /*#__PURE__*/__webpack_require__.n(Profiler_Tooltip);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/Tooltip.js



const initialTooltipState = {
  height: 0,
  mouseX: 0,
  mouseY: 0,
  width: 0
};
function Tooltip_Tooltip({
  children,
  label
}) {
  const containerRef = Object(external_react_["useRef"])(null);
  const tooltipRef = Object(external_react_["useRef"])(null); // update the position of the tooltip based on current mouse position

  const updateTooltipPosition = event => {
    const element = tooltipRef.current;

    if (element != null) {
      // first find the mouse position
      const mousePosition = getMousePosition(containerRef.current, event); // use the mouse position to find the position of tooltip

      const _getTooltipPosition = getTooltipPosition(element, mousePosition),
            left = _getTooltipPosition.left,
            top = _getTooltipPosition.top; // update tooltip position


      element.style.left = left;
      element.style.top = top;
    }
  };

  const onMouseMove = event => {
    updateTooltipPosition(event);
  };

  const tooltipClassName = label === null ? Profiler_Tooltip_default.a.hidden : '';
  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: Profiler_Tooltip_default.a.Container,
    onMouseMove: onMouseMove,
    ref: containerRef
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    ref: tooltipRef,
    className: `${Profiler_Tooltip_default.a.Tooltip} ${tooltipClassName}`
  }, label), children);
}
const TOOLTIP_OFFSET = 5; // Method used to find the position of the tooltip based on current mouse position

function getTooltipPosition(element, mousePosition) {
  const height = mousePosition.height,
        mouseX = mousePosition.mouseX,
        mouseY = mousePosition.mouseY,
        width = mousePosition.width;
  let top = 0;
  let left = 0;

  if (mouseY + TOOLTIP_OFFSET + element.offsetHeight >= height) {
    if (mouseY - TOOLTIP_OFFSET - element.offsetHeight > 0) {
      top = `${mouseY - element.offsetHeight - TOOLTIP_OFFSET}px`;
    } else {
      top = '0px';
    }
  } else {
    top = `${mouseY + TOOLTIP_OFFSET}px`;
  }

  if (mouseX + TOOLTIP_OFFSET + element.offsetWidth >= width) {
    if (mouseX - TOOLTIP_OFFSET - element.offsetWidth > 0) {
      left = `${mouseX - element.offsetWidth - TOOLTIP_OFFSET}px`;
    } else {
      left = '0px';
    }
  } else {
    left = `${mouseX + TOOLTIP_OFFSET * 2}px`;
  }

  return {
    left,
    top
  };
} // method used to find the current mouse position inside the container


function getMousePosition(relativeContainer, mouseEvent) {
  if (relativeContainer !== null) {
    // Position within the nearest position:relative container.
    let targetContainer = relativeContainer;

    while (targetContainer.parentElement != null) {
      if (targetContainer.style.position === 'relative') {
        break;
      } else {
        targetContainer = targetContainer.parentElement;
      }
    }

    const _targetContainer$getB = targetContainer.getBoundingClientRect(),
          height = _targetContainer$getB.height,
          left = _targetContainer$getB.left,
          top = _targetContainer$getB.top,
          width = _targetContainer$getB.width;

    const mouseX = mouseEvent.clientX - left;
    const mouseY = mouseEvent.clientY - top;
    return {
      height,
      mouseX,
      mouseY,
      width
    };
  } else {
    return initialTooltipState;
  }
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/CommitFlamegraph.css
var CommitFlamegraph = __webpack_require__(73);
var CommitFlamegraph_default = /*#__PURE__*/__webpack_require__.n(CommitFlamegraph);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/CommitFlamegraph.js
function CommitFlamegraph_extends() { CommitFlamegraph_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return CommitFlamegraph_extends.apply(this, arguments); }

function CommitFlamegraph_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = CommitFlamegraph_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function CommitFlamegraph_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function CommitFlamegraph_slicedToArray(arr, i) { return CommitFlamegraph_arrayWithHoles(arr) || CommitFlamegraph_iterableToArrayLimit(arr, i) || CommitFlamegraph_unsupportedIterableToArray(arr, i) || CommitFlamegraph_nonIterableRest(); }

function CommitFlamegraph_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function CommitFlamegraph_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return CommitFlamegraph_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return CommitFlamegraph_arrayLikeToArray(o, minLen); }

function CommitFlamegraph_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function CommitFlamegraph_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function CommitFlamegraph_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */














function CommitFlamegraphAutoSizer(_) {
  const _useContext = Object(external_react_["useContext"])(StoreContext),
        profilerStore = _useContext.profilerStore;

  const _useContext2 = Object(external_react_["useContext"])(ProfilerContext),
        rootID = _useContext2.rootID,
        selectedCommitIndex = _useContext2.selectedCommitIndex,
        selectFiber = _useContext2.selectFiber;

  const profilingCache = profilerStore.profilingCache;
  const deselectCurrentFiber = Object(external_react_["useCallback"])(event => {
    event.stopPropagation();
    selectFiber(null, null);
  }, [selectFiber]);
  let commitTree = null;
  let chartData = null;

  if (selectedCommitIndex !== null) {
    commitTree = profilingCache.getCommitTree({
      commitIndex: selectedCommitIndex,
      rootID: rootID
    });
    chartData = profilingCache.getFlamegraphChartData({
      commitIndex: selectedCommitIndex,
      commitTree,
      rootID: rootID
    });
  }

  if (commitTree != null && chartData != null && chartData.depth > 0) {
    return /*#__PURE__*/external_react_["createElement"]("div", {
      className: CommitFlamegraph_default.a.Container,
      onClick: deselectCurrentFiber
    }, /*#__PURE__*/external_react_["createElement"](index_esm["a" /* default */], null, ({
      height,
      width
    }) =>
    /*#__PURE__*/
    // Force Flow types to avoid checking for `null` here because there's no static proof that
    // by the time this render prop function is called, the values of the `let` variables have not changed.
    external_react_["createElement"](CommitFlamegraph_CommitFlamegraph, {
      chartData: chartData,
      commitTree: commitTree,
      height: height,
      width: width
    })));
  } else {
    return /*#__PURE__*/external_react_["createElement"](NoCommitData_NoCommitData, null);
  }
}

function CommitFlamegraph_CommitFlamegraph({
  chartData,
  commitTree,
  height,
  width
}) {
  const _useState = Object(external_react_["useState"])(null),
        _useState2 = CommitFlamegraph_slicedToArray(_useState, 2),
        hoveredFiberData = _useState2[0],
        setHoveredFiberData = _useState2[1];

  const _useContext3 = Object(external_react_["useContext"])(SettingsContext),
        lineHeight = _useContext3.lineHeight;

  const _useContext4 = Object(external_react_["useContext"])(ProfilerContext),
        selectFiber = _useContext4.selectFiber,
        selectedFiberID = _useContext4.selectedFiberID;

  const _useHighlightNativeEl = useHighlightNativeElement(),
        highlightNativeElement = _useHighlightNativeEl.highlightNativeElement,
        clearHighlightNativeElement = _useHighlightNativeEl.clearHighlightNativeElement;

  const selectedChartNodeIndex = Object(external_react_["useMemo"])(() => {
    if (selectedFiberID === null) {
      return 0;
    } // The selected node might not be in the tree for this commit,
    // so it's important that we have a fallback plan.


    const depth = chartData.idToDepthMap.get(selectedFiberID);
    return depth !== undefined ? depth - 1 : 0;
  }, [chartData, selectedFiberID]);
  const selectedChartNode = Object(external_react_["useMemo"])(() => {
    if (selectedFiberID !== null) {
      return chartData.rows[selectedChartNodeIndex].find(chartNode => chartNode.id === selectedFiberID) || null;
    }

    return null;
  }, [chartData, selectedFiberID, selectedChartNodeIndex]);
  const handleElementMouseEnter = Object(external_react_["useCallback"])(({
    id,
    name
  }) => {
    highlightNativeElement(id); // Highlight last hovered element.

    setHoveredFiberData({
      id,
      name
    }); // Set hovered fiber data for tooltip
  }, [highlightNativeElement]);
  const handleElementMouseLeave = Object(external_react_["useCallback"])(() => {
    clearHighlightNativeElement(); // clear highlighting of element on mouse leave

    setHoveredFiberData(null); // clear hovered fiber data for tooltip
  }, [clearHighlightNativeElement]);
  const itemData = Object(external_react_["useMemo"])(() => ({
    chartData,
    onElementMouseEnter: handleElementMouseEnter,
    onElementMouseLeave: handleElementMouseLeave,
    scaleX: scale(0, selectedChartNode !== null ? selectedChartNode.treeBaseDuration : chartData.baseDuration, 0, width),
    selectedChartNode,
    selectedChartNodeIndex,
    selectFiber,
    width
  }), [chartData, handleElementMouseEnter, handleElementMouseLeave, selectedChartNode, selectedChartNodeIndex, selectFiber, width]); // Tooltip used to show summary of fiber info on hover

  const tooltipLabel = Object(external_react_["useMemo"])(() => hoveredFiberData !== null ? /*#__PURE__*/external_react_["createElement"](HoveredFiberInfo_HoveredFiberInfo, {
    fiberData: hoveredFiberData
  }) : null, [hoveredFiberData]);
  return /*#__PURE__*/external_react_["createElement"](Tooltip_Tooltip, {
    label: tooltipLabel
  }, /*#__PURE__*/external_react_["createElement"](FixedSizeList, {
    height: height,
    innerElementType: CommitFlamegraph_InnerElementType,
    itemCount: chartData.depth,
    itemData: itemData,
    itemSize: lineHeight,
    width: width
  }, Profiler_CommitFlamegraphListItem));
}

const CommitFlamegraph_InnerElementType = /*#__PURE__*/Object(external_react_["forwardRef"])((_ref, ref) => {
  let children = _ref.children,
      rest = CommitFlamegraph_objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/external_react_["createElement"]("svg", CommitFlamegraph_extends({
    ref: ref
  }, rest), /*#__PURE__*/external_react_["createElement"]("defs", null, /*#__PURE__*/external_react_["createElement"]("pattern", {
    id: "didNotRenderPattern",
    patternUnits: "userSpaceOnUse",
    width: "4",
    height: "4"
  }, /*#__PURE__*/external_react_["createElement"]("path", {
    d: "M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2",
    className: CommitFlamegraph_default.a.PatternPath
  }))), children);
});
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/CommitRankedListItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */








function CommitRankedListItem({
  data,
  index,
  style
}) {
  const chartData = data.chartData,
        onElementMouseEnter = data.onElementMouseEnter,
        onElementMouseLeave = data.onElementMouseLeave,
        scaleX = data.scaleX,
        selectedFiberIndex = data.selectedFiberIndex,
        selectFiber = data.selectFiber,
        width = data.width;
  const node = chartData.nodes[index];

  const _useContext = Object(external_react_["useContext"])(SettingsContext),
        lineHeight = _useContext.lineHeight;

  const handleClick = Object(external_react_["useCallback"])(event => {
    event.stopPropagation();
    const id = node.id,
          name = node.name;
    selectFiber(id, name);
  }, [node, selectFiber]);

  const handleMouseEnter = () => {
    const id = node.id,
          name = node.name;
    onElementMouseEnter({
      id,
      name
    });
  };

  const handleMouseLeave = () => {
    onElementMouseLeave();
  }; // List items are absolutely positioned using the CSS "top" attribute.
  // The "left" value will always be 0.
  // Since height is fixed, and width is based on the node's duration,
  // We can ignore those values as well.


  const top = parseInt(style.top, 10);
  return /*#__PURE__*/external_react_["createElement"](ChartNode_ChartNode, {
    color: getGradientColor(node.value / chartData.maxValue),
    height: lineHeight,
    isDimmed: index < selectedFiberIndex,
    key: node.id,
    label: node.label,
    onClick: handleClick,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    width: Math.max(minBarWidth, scaleX(node.value, width)),
    x: 0,
    y: top
  });
}

/* harmony default export */ var Profiler_CommitRankedListItem = (/*#__PURE__*/Object(external_react_["memo"])(CommitRankedListItem, areEqual));
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/CommitRanked.css
var CommitRanked = __webpack_require__(86);
var CommitRanked_default = /*#__PURE__*/__webpack_require__.n(CommitRanked);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/CommitRanked.js
function CommitRanked_slicedToArray(arr, i) { return CommitRanked_arrayWithHoles(arr) || CommitRanked_iterableToArrayLimit(arr, i) || CommitRanked_unsupportedIterableToArray(arr, i) || CommitRanked_nonIterableRest(); }

function CommitRanked_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function CommitRanked_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return CommitRanked_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return CommitRanked_arrayLikeToArray(o, minLen); }

function CommitRanked_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function CommitRanked_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function CommitRanked_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */














function CommitRankedAutoSizer(_) {
  const _useContext = Object(external_react_["useContext"])(StoreContext),
        profilerStore = _useContext.profilerStore;

  const _useContext2 = Object(external_react_["useContext"])(ProfilerContext),
        rootID = _useContext2.rootID,
        selectedCommitIndex = _useContext2.selectedCommitIndex,
        selectFiber = _useContext2.selectFiber;

  const profilingCache = profilerStore.profilingCache;
  const deselectCurrentFiber = Object(external_react_["useCallback"])(event => {
    event.stopPropagation();
    selectFiber(null, null);
  }, [selectFiber]);
  let commitTree = null;
  let chartData = null;

  if (selectedCommitIndex !== null) {
    commitTree = profilingCache.getCommitTree({
      commitIndex: selectedCommitIndex,
      rootID: rootID
    });
    chartData = profilingCache.getRankedChartData({
      commitIndex: selectedCommitIndex,
      commitTree,
      rootID: rootID
    });
  }

  if (commitTree != null && chartData != null && chartData.nodes.length > 0) {
    return /*#__PURE__*/external_react_["createElement"]("div", {
      className: CommitRanked_default.a.Container,
      onClick: deselectCurrentFiber
    }, /*#__PURE__*/external_react_["createElement"](index_esm["a" /* default */], null, ({
      height,
      width
    }) => /*#__PURE__*/external_react_["createElement"](CommitRanked_CommitRanked, {
      chartData: chartData,
      commitTree: commitTree,
      height: height,
      width: width
    })));
  } else {
    return /*#__PURE__*/external_react_["createElement"](NoCommitData_NoCommitData, null);
  }
}

function CommitRanked_CommitRanked({
  chartData,
  commitTree,
  height,
  width
}) {
  const _useState = Object(external_react_["useState"])(null),
        _useState2 = CommitRanked_slicedToArray(_useState, 2),
        hoveredFiberData = _useState2[0],
        setHoveredFiberData = _useState2[1];

  const _useContext3 = Object(external_react_["useContext"])(SettingsContext),
        lineHeight = _useContext3.lineHeight;

  const _useContext4 = Object(external_react_["useContext"])(ProfilerContext),
        selectedFiberID = _useContext4.selectedFiberID,
        selectFiber = _useContext4.selectFiber;

  const _useHighlightNativeEl = useHighlightNativeElement(),
        highlightNativeElement = _useHighlightNativeEl.highlightNativeElement,
        clearHighlightNativeElement = _useHighlightNativeEl.clearHighlightNativeElement;

  const selectedFiberIndex = Object(external_react_["useMemo"])(() => getNodeIndex(chartData, selectedFiberID), [chartData, selectedFiberID]);
  const handleElementMouseEnter = Object(external_react_["useCallback"])(({
    id,
    name
  }) => {
    highlightNativeElement(id); // Highlight last hovered element.

    setHoveredFiberData({
      id,
      name
    }); // Set hovered fiber data for tooltip
  }, [highlightNativeElement]);
  const handleElementMouseLeave = Object(external_react_["useCallback"])(() => {
    clearHighlightNativeElement(); // clear highlighting of element on mouse leave

    setHoveredFiberData(null); // clear hovered fiber data for tooltip
  }, [clearHighlightNativeElement]);
  const itemData = Object(external_react_["useMemo"])(() => ({
    chartData,
    onElementMouseEnter: handleElementMouseEnter,
    onElementMouseLeave: handleElementMouseLeave,
    scaleX: scale(0, chartData.nodes[selectedFiberIndex].value, 0, width),
    selectedFiberID,
    selectedFiberIndex,
    selectFiber,
    width
  }), [chartData, handleElementMouseEnter, handleElementMouseLeave, selectedFiberID, selectedFiberIndex, selectFiber, width]); // Tooltip used to show summary of fiber info on hover

  const tooltipLabel = Object(external_react_["useMemo"])(() => hoveredFiberData !== null ? /*#__PURE__*/external_react_["createElement"](HoveredFiberInfo_HoveredFiberInfo, {
    fiberData: hoveredFiberData
  }) : null, [hoveredFiberData]);
  return /*#__PURE__*/external_react_["createElement"](Tooltip_Tooltip, {
    label: tooltipLabel
  }, /*#__PURE__*/external_react_["createElement"](FixedSizeList, {
    height: height,
    innerElementType: "svg",
    itemCount: chartData.nodes.length,
    itemData: itemData,
    itemSize: lineHeight,
    width: width
  }, Profiler_CommitRankedListItem));
}

const getNodeIndex = (chartData, id) => {
  if (id === null) {
    return 0;
  }

  const nodes = chartData.nodes;

  for (let index = 0; index < nodes.length; index++) {
    if (nodes[index].id === id) {
      return index;
    }
  }

  return 0;
};
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/InteractionListItem.css
var InteractionListItem = __webpack_require__(44);
var InteractionListItem_default = /*#__PURE__*/__webpack_require__.n(InteractionListItem);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/InteractionListItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






function InteractionListItem_InteractionListItem({
  data: itemData,
  index,
  style
}) {
  const chartData = itemData.chartData,
        dataForRoot = itemData.dataForRoot,
        labelWidth = itemData.labelWidth,
        scaleX = itemData.scaleX,
        selectedInteractionID = itemData.selectedInteractionID,
        selectCommitIndex = itemData.selectCommitIndex,
        selectInteraction = itemData.selectInteraction,
        selectTab = itemData.selectTab;
  const commitData = dataForRoot.commitData,
        interactionCommits = dataForRoot.interactionCommits;
  const interactions = chartData.interactions,
        lastInteractionTime = chartData.lastInteractionTime,
        maxCommitDuration = chartData.maxCommitDuration;
  const interaction = interactions[index];

  if (interaction == null) {
    throw Error(`Could not find interaction #${index}`);
  }

  const handleClick = Object(external_react_["useCallback"])(() => {
    selectInteraction(interaction.id);
  }, [interaction, selectInteraction]);
  const commits = interactionCommits.get(interaction.id) || [];
  const startTime = interaction.timestamp;
  const stopTime = lastInteractionTime;

  const viewCommit = commitIndex => {
    selectTab('flame-chart');
    selectCommitIndex(commitIndex);
  };

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: selectedInteractionID === interaction.id ? InteractionListItem_default.a.SelectedInteraction : InteractionListItem_default.a.Interaction,
    onClick: handleClick,
    style: style
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: InteractionListItem_default.a.Name,
    style: {
      maxWidth: labelWidth
    },
    title: interaction.name
  }, interaction.name), /*#__PURE__*/external_react_["createElement"]("div", {
    className: InteractionListItem_default.a.InteractionLine,
    style: {
      left: labelWidth + scaleX(startTime, 0),
      width: scaleX(stopTime - startTime, 0)
    }
  }), commits.map(commitIndex => /*#__PURE__*/external_react_["createElement"]("div", {
    className: InteractionListItem_default.a.CommitBox,
    key: commitIndex,
    onClick: () => viewCommit(commitIndex),
    style: {
      backgroundColor: getGradientColor(Math.min(1, Math.max(0, commitData[commitIndex].duration / maxCommitDuration)) || 0),
      left: labelWidth + scaleX(commitData[commitIndex].timestamp, 0)
    }
  })));
}

/* harmony default export */ var Profiler_InteractionListItem = (/*#__PURE__*/Object(external_react_["memo"])(InteractionListItem_InteractionListItem, areEqual));
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/NoInteractions.css
var NoInteractions = __webpack_require__(61);
var NoInteractions_default = /*#__PURE__*/__webpack_require__.n(NoInteractions);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/NoInteractions.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


function NoInteractions_NoInteractions({
  height,
  width
}) {
  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: NoInteractions_default.a.NoInteractions,
    style: {
      height,
      width
    }
  }, /*#__PURE__*/external_react_["createElement"]("p", {
    className: NoInteractions_default.a.Header
  }, "No interactions were recorded."), /*#__PURE__*/external_react_["createElement"]("p", null, /*#__PURE__*/external_react_["createElement"]("a", {
    className: NoInteractions_default.a.Link,
    href: "https://reactjs.org/link/interaction-tracing",
    rel: "noopener noreferrer",
    target: "_blank"
  }, "Learn more about the interaction tracing API here.")));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/Interactions.css
var Interactions = __webpack_require__(74);
var Interactions_default = /*#__PURE__*/__webpack_require__.n(Interactions);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/Interactions.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */










function InteractionsAutoSizer(_) {
  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: Interactions_default.a.Container
  }, /*#__PURE__*/external_react_["createElement"](index_esm["a" /* default */], null, ({
    height,
    width
  }) => /*#__PURE__*/external_react_["createElement"](Interactions_Interactions, {
    height: height,
    width: width
  })));
}

function Interactions_Interactions({
  height,
  width
}) {
  const _useContext = Object(external_react_["useContext"])(ProfilerContext),
        rootID = _useContext.rootID,
        selectedInteractionID = _useContext.selectedInteractionID,
        selectInteraction = _useContext.selectInteraction,
        selectCommitIndex = _useContext.selectCommitIndex,
        selectTab = _useContext.selectTab;

  const _useContext2 = Object(external_react_["useContext"])(StoreContext),
        profilerStore = _useContext2.profilerStore;

  const profilingCache = profilerStore.profilingCache;
  const dataForRoot = profilerStore.getDataForRoot(rootID);
  const chartData = profilingCache.getInteractionsChartData({
    rootID: rootID
  });
  const interactions = chartData.interactions;
  const handleKeyDown = Object(external_react_["useCallback"])(event => {
    let index;

    switch (event.key) {
      case 'ArrowDown':
        index = interactions.findIndex(interaction => interaction.id === selectedInteractionID);
        selectInteraction(Math.min(interactions.length - 1, index + 1));
        event.stopPropagation();
        break;

      case 'ArrowUp':
        index = interactions.findIndex(interaction => interaction.id === selectedInteractionID);
        selectInteraction(Math.max(0, index - 1));
        event.stopPropagation();
        break;

      default:
        break;
    }
  }, [interactions, selectedInteractionID, selectInteraction]);
  const itemData = Object(external_react_["useMemo"])(() => {
    const interactionCommitSize = parseInt(getComputedStyle(document.body).getPropertyValue('--interaction-commit-size'), 10);
    const interactionLabelWidth = parseInt(getComputedStyle(document.body).getPropertyValue('--interaction-label-width'), 10);
    const labelWidth = Math.min(interactionLabelWidth, width / 5);
    const timelineWidth = width - labelWidth - interactionCommitSize;
    return {
      chartData,
      dataForRoot,
      labelWidth,
      scaleX: scale(0, chartData.lastInteractionTime, 0, timelineWidth),
      selectedInteractionID,
      selectCommitIndex,
      selectInteraction,
      selectTab
    };
  }, [chartData, dataForRoot, selectedInteractionID, selectCommitIndex, selectInteraction, selectTab, width]); // If a commit contains no fibers with an actualDuration > 0,
  // Display a fallback message.

  if (interactions.length === 0) {
    return /*#__PURE__*/external_react_["createElement"](NoInteractions_NoInteractions, {
      height: height,
      width: width
    });
  }

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: Interactions_default.a.FocusTarget,
    onKeyDown: handleKeyDown,
    tabIndex: 0
  }, /*#__PURE__*/external_react_["createElement"](FixedSizeList, {
    height: height,
    itemCount: interactions.length,
    itemData: itemData,
    itemSize: 30,
    width: width
  }, Profiler_InteractionListItem));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/RootSelector.css
var RootSelector = __webpack_require__(87);
var RootSelector_default = /*#__PURE__*/__webpack_require__.n(RootSelector);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/RootSelector.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */




function RootSelector_RootSelector(_) {
  const _useContext = Object(external_react_["useContext"])(ProfilerContext),
        profilingData = _useContext.profilingData,
        rootID = _useContext.rootID,
        setRootID = _useContext.setRootID;

  const options = [];

  if (profilingData !== null) {
    profilingData.dataForRoots.forEach((dataForRoot, id) => {
      options.push( /*#__PURE__*/external_react_["createElement"]("option", {
        key: id,
        value: id
      }, dataForRoot.displayName));
    });
  }

  const handleChange = Object(external_react_["useCallback"])(({
    currentTarget
  }) => {
    setRootID(parseInt(currentTarget.value, 10));
  }, [setRootID]);

  if (profilingData === null || profilingData.dataForRoots.size <= 1) {
    // Don't take up visual space if there's only one root.
    return null;
  }

  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("div", {
    className: RootSelector_default.a.Spacer
  }), /*#__PURE__*/external_react_["createElement"]("select", {
    value: rootID,
    onChange: handleChange
  }, options));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/RecordToggle.css
var RecordToggle = __webpack_require__(62);
var RecordToggle_default = /*#__PURE__*/__webpack_require__.n(RecordToggle);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/RecordToggle.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






function RecordToggle_RecordToggle({
  disabled
}) {
  const _useContext = Object(external_react_["useContext"])(ProfilerContext),
        isProfiling = _useContext.isProfiling,
        startProfiling = _useContext.startProfiling,
        stopProfiling = _useContext.stopProfiling;

  let className = RecordToggle_default.a.InactiveRecordToggle;

  if (disabled) {
    className = RecordToggle_default.a.DisabledRecordToggle;
  } else if (isProfiling) {
    className = RecordToggle_default.a.ActiveRecordToggle;
  }

  return /*#__PURE__*/external_react_["createElement"](Button_Button, {
    className: className,
    disabled: disabled,
    onClick: isProfiling ? stopProfiling : startProfiling,
    title: isProfiling ? 'Stop profiling' : 'Start profiling'
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "record"
  }));
}
// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/ReloadAndProfileButton.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






function ReloadAndProfileButton() {
  const bridge = Object(external_react_["useContext"])(BridgeContext);
  const store = Object(external_react_["useContext"])(StoreContext);
  const subscription = Object(external_react_["useMemo"])(() => ({
    getCurrentValue: () => ({
      recordChangeDescriptions: store.recordChangeDescriptions,
      supportsReloadAndProfile: store.supportsReloadAndProfile
    }),
    subscribe: callback => {
      store.addListener('recordChangeDescriptions', callback);
      store.addListener('supportsReloadAndProfile', callback);
      return () => {
        store.removeListener('recordChangeDescriptions', callback);
        store.removeListener('supportsReloadAndProfile', callback);
      };
    }
  }), [store]);

  const _useSubscription = useSubscription(subscription),
        recordChangeDescriptions = _useSubscription.recordChangeDescriptions,
        supportsReloadAndProfile = _useSubscription.supportsReloadAndProfile;

  const reloadAndProfile = Object(external_react_["useCallback"])(() => {
    // TODO If we want to support reload-and-profile for e.g. React Native,
    // we might need to also start profiling here before reloading the app (since DevTools itself isn't reloaded).
    // We'd probably want to do this before reloading though, to avoid sending a message on a disconnected port in the browser.
    // For now, let's just skip doing it entirely to avoid paying snapshot costs for data we don't need.
    // startProfiling();
    bridge.send('reloadAndProfile', recordChangeDescriptions);
  }, [bridge, recordChangeDescriptions]);

  if (!supportsReloadAndProfile) {
    return null;
  }

  return /*#__PURE__*/external_react_["createElement"](Button_Button, {
    disabled: !store.supportsProfiling,
    onClick: reloadAndProfile,
    title: "Reload and start profiling"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "reload"
  }));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/ProfilingImportExportButtons.css
var ProfilingImportExportButtons = __webpack_require__(54);
var ProfilingImportExportButtons_default = /*#__PURE__*/__webpack_require__.n(ProfilingImportExportButtons);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/ProfilingImportExportButtons.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */










function ProfilingImportExportButtons_ProfilingImportExportButtons() {
  const _useContext = Object(external_react_["useContext"])(ProfilerContext),
        isProfiling = _useContext.isProfiling,
        profilingData = _useContext.profilingData,
        rootID = _useContext.rootID;

  const store = Object(external_react_["useContext"])(StoreContext);
  const profilerStore = store.profilerStore;
  const inputRef = Object(external_react_["useRef"])(null);
  const downloadRef = Object(external_react_["useRef"])(null);

  const _useContext2 = Object(external_react_["useContext"])(ModalDialogContext),
        modalDialogDispatch = _useContext2.dispatch;

  const downloadData = Object(external_react_["useCallback"])(() => {
    if (rootID === null) {
      return;
    }

    const anchorElement = downloadRef.current;

    if (profilingData !== null && anchorElement !== null) {
      const profilingDataExport = prepareProfilingDataExport(profilingData);
      const date = new Date();
      const dateString = date.toLocaleDateString(undefined, {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit'
      }).replace(/\//g, '-');
      const timeString = date.toLocaleTimeString(undefined, {
        hour12: false
      }).replace(/:/g, '-');
      downloadFile(anchorElement, `profiling-data.${dateString}.${timeString}.json`, JSON.stringify(profilingDataExport, null, 2));
    }
  }, [rootID, profilingData]);
  const uploadData = Object(external_react_["useCallback"])(() => {
    if (inputRef.current !== null) {
      inputRef.current.click();
    }
  }, []);
  const handleFiles = Object(external_react_["useCallback"])(() => {
    const input = inputRef.current;

    if (input !== null && input.files.length > 0) {
      const fileReader = new FileReader();
      fileReader.addEventListener('load', () => {
        try {
          const raw = fileReader.result;
          const profilingDataExport = JSON.parse(raw);
          profilerStore.profilingData = prepareProfilingDataFrontendFromExport(profilingDataExport);
        } catch (error) {
          modalDialogDispatch({
            type: 'SHOW',
            title: 'Import failed',
            content: /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("div", null, "The profiling data you selected cannot be imported."), error !== null && /*#__PURE__*/external_react_["createElement"]("div", {
              className: ProfilingImportExportButtons_default.a.ErrorMessage
            }, error.message))
          });
        }
      }); // TODO (profiling) Handle fileReader errors.

      fileReader.readAsText(input.files[0]);
    }
  }, [modalDialogDispatch, profilerStore]);
  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("div", {
    className: ProfilingImportExportButtons_default.a.VRule
  }), /*#__PURE__*/external_react_["createElement"]("input", {
    ref: inputRef,
    className: ProfilingImportExportButtons_default.a.Input,
    type: "file",
    onChange: handleFiles,
    tabIndex: -1
  }), /*#__PURE__*/external_react_["createElement"]("a", {
    ref: downloadRef,
    className: ProfilingImportExportButtons_default.a.Input
  }), /*#__PURE__*/external_react_["createElement"](Button_Button, {
    disabled: isProfiling,
    onClick: uploadData,
    title: "Load profile..."
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "import"
  })), /*#__PURE__*/external_react_["createElement"](Button_Button, {
    disabled: isProfiling || !profilerStore.didRecordCommits,
    onClick: downloadData,
    title: "Save profile..."
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "export"
  })));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/SnapshotCommitListItem.css
var SnapshotCommitListItem = __webpack_require__(75);
var SnapshotCommitListItem_default = /*#__PURE__*/__webpack_require__.n(SnapshotCommitListItem);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/SnapshotCommitListItem.js
function SnapshotCommitListItem_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function SnapshotCommitListItem_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SnapshotCommitListItem_ownKeys(Object(source), true).forEach(function (key) { SnapshotCommitListItem_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SnapshotCommitListItem_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function SnapshotCommitListItem_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






function SnapshotCommitListItem_SnapshotCommitListItem({
  data: itemData,
  index,
  style
}) {
  const commitDurations = itemData.commitDurations,
        commitTimes = itemData.commitTimes,
        filteredCommitIndices = itemData.filteredCommitIndices,
        maxDuration = itemData.maxDuration,
        selectedCommitIndex = itemData.selectedCommitIndex,
        selectCommitIndex = itemData.selectCommitIndex,
        startCommitDrag = itemData.startCommitDrag;
  index = filteredCommitIndices[index];
  const commitDuration = commitDurations[index];
  const commitTime = commitTimes[index]; // Guard against commits with duration 0

  const percentage = Math.min(1, Math.max(0, commitDuration / maxDuration)) || 0;
  const isSelected = selectedCommitIndex === index; // Leave a 1px gap between snapshots

  const width = parseFloat(style.width) - 1;

  const handleMouseDown = ({
    buttons,
    target
  }) => {
    if (buttons === 1) {
      selectCommitIndex(index);
      startCommitDrag({
        commitIndex: index,
        left: target.getBoundingClientRect().left,
        sizeIncrement: parseFloat(style.width)
      });
    }
  };

  return /*#__PURE__*/external_react_["createElement"]("div", {
    className: SnapshotCommitListItem_default.a.Outer,
    onMouseDown: handleMouseDown,
    style: SnapshotCommitListItem_objectSpread(SnapshotCommitListItem_objectSpread({}, style), {}, {
      width,
      borderBottom: isSelected ? '3px solid var(--color-tab-selected-border)' : undefined
    }),
    title: `Duration ${formatDuration(commitDuration)}ms at ${formatTime(commitTime)}s`
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: SnapshotCommitListItem_default.a.Inner,
    style: {
      height: `${Math.round(percentage * 100)}%`,
      backgroundColor: percentage > 0 ? getGradientColor(percentage) : undefined
    }
  }));
}

/* harmony default export */ var Profiler_SnapshotCommitListItem = (/*#__PURE__*/Object(external_react_["memo"])(SnapshotCommitListItem_SnapshotCommitListItem, areEqual));
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/SnapshotCommitList.css
var SnapshotCommitList = __webpack_require__(88);
var SnapshotCommitList_default = /*#__PURE__*/__webpack_require__.n(SnapshotCommitList);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/SnapshotCommitList.js
function SnapshotCommitList_slicedToArray(arr, i) { return SnapshotCommitList_arrayWithHoles(arr) || SnapshotCommitList_iterableToArrayLimit(arr, i) || SnapshotCommitList_unsupportedIterableToArray(arr, i) || SnapshotCommitList_nonIterableRest(); }

function SnapshotCommitList_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function SnapshotCommitList_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return SnapshotCommitList_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return SnapshotCommitList_arrayLikeToArray(o, minLen); }

function SnapshotCommitList_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function SnapshotCommitList_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function SnapshotCommitList_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */







function SnapshotCommitList_SnapshotCommitList({
  commitDurations,
  commitTimes,
  filteredCommitIndices,
  selectedCommitIndex,
  selectedFilteredCommitIndex,
  selectCommitIndex
}) {
  return /*#__PURE__*/external_react_["createElement"](index_esm["a" /* default */], null, ({
    height,
    width
  }) => /*#__PURE__*/external_react_["createElement"](SnapshotCommitList_List, {
    commitDurations: commitDurations,
    commitTimes: commitTimes,
    height: height,
    filteredCommitIndices: filteredCommitIndices,
    selectedCommitIndex: selectedCommitIndex,
    selectedFilteredCommitIndex: selectedFilteredCommitIndex,
    selectCommitIndex: selectCommitIndex,
    width: width
  }));
}

function SnapshotCommitList_List({
  commitDurations,
  selectedCommitIndex,
  commitTimes,
  height,
  filteredCommitIndices,
  selectedFilteredCommitIndex,
  selectCommitIndex,
  width
}) {
  const listRef = Object(external_react_["useRef"])(null);
  const divRef = Object(external_react_["useRef"])(null);
  const prevCommitIndexRef = Object(external_react_["useRef"])(null); // Make sure a newly selected snapshot is fully visible within the list.

  Object(external_react_["useEffect"])(() => {
    if (selectedFilteredCommitIndex !== prevCommitIndexRef.current) {
      prevCommitIndexRef.current = selectedFilteredCommitIndex;

      if (selectedFilteredCommitIndex !== null && listRef.current !== null) {
        listRef.current.scrollToItem(selectedFilteredCommitIndex);
      }
    }
  }, [listRef, selectedFilteredCommitIndex]);
  const itemSize = Object(external_react_["useMemo"])(() => Math.max(minBarWidth, width / filteredCommitIndices.length), [filteredCommitIndices, width]);
  const maxDuration = Object(external_react_["useMemo"])(() => commitDurations.reduce((max, duration) => Math.max(max, duration), 0), [commitDurations]);
  const maxCommitIndex = filteredCommitIndices.length - 1;

  const _useState = Object(external_react_["useState"])(null),
        _useState2 = SnapshotCommitList_slicedToArray(_useState, 2),
        dragState = _useState2[0],
        setDragState = _useState2[1];

  const handleDragCommit = ({
    buttons,
    pageX
  }) => {
    if (buttons === 0) {
      setDragState(null);
      return;
    }

    if (dragState !== null) {
      const commitIndex = dragState.commitIndex,
            left = dragState.left,
            sizeIncrement = dragState.sizeIncrement;
      let newCommitIndex = commitIndex;
      let newCommitLeft = left;

      if (pageX < newCommitLeft) {
        while (pageX < newCommitLeft) {
          newCommitLeft -= sizeIncrement;
          newCommitIndex -= 1;
        }
      } else {
        let newCommitRectRight = newCommitLeft + sizeIncrement;

        while (pageX > newCommitRectRight) {
          newCommitRectRight += sizeIncrement;
          newCommitIndex += 1;
        }
      }

      if (newCommitIndex < 0) {
        newCommitIndex = 0;
      } else if (newCommitIndex > maxCommitIndex) {
        newCommitIndex = maxCommitIndex;
      }

      selectCommitIndex(newCommitIndex);
    }
  };

  Object(external_react_["useEffect"])(() => {
    if (dragState === null) {
      return;
    }

    const element = divRef.current;

    if (element !== null) {
      const ownerDocument = element.ownerDocument;
      ownerDocument.addEventListener('mousemove', handleDragCommit);
      return () => {
        ownerDocument.removeEventListener('mousemove', handleDragCommit);
      };
    }
  }, [dragState]); // Pass required contextual data down to the ListItem renderer.

  const itemData = Object(external_react_["useMemo"])(() => ({
    commitDurations,
    commitTimes,
    filteredCommitIndices,
    maxDuration,
    selectedCommitIndex,
    selectedFilteredCommitIndex,
    selectCommitIndex,
    startCommitDrag: setDragState
  }), [commitDurations, commitTimes, filteredCommitIndices, maxDuration, selectedCommitIndex, selectedFilteredCommitIndex, selectCommitIndex]);
  return /*#__PURE__*/external_react_["createElement"]("div", {
    ref: divRef,
    style: {
      height,
      width
    }
  }, /*#__PURE__*/external_react_["createElement"](FixedSizeList, {
    className: SnapshotCommitList_default.a.List,
    layout: "horizontal",
    height: height,
    itemCount: filteredCommitIndices.length,
    itemData: itemData,
    itemSize: itemSize,
    ref: listRef,
    width: width
  }, Profiler_SnapshotCommitListItem));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/SnapshotSelector.css
var SnapshotSelector = __webpack_require__(45);
var SnapshotSelector_default = /*#__PURE__*/__webpack_require__.n(SnapshotSelector);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/SnapshotSelector.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */









function SnapshotSelector_SnapshotSelector(_) {
  const _useContext = Object(external_react_["useContext"])(ProfilerContext),
        isCommitFilterEnabled = _useContext.isCommitFilterEnabled,
        minCommitDuration = _useContext.minCommitDuration,
        rootID = _useContext.rootID,
        selectedCommitIndex = _useContext.selectedCommitIndex,
        selectCommitIndex = _useContext.selectCommitIndex;

  const _useContext2 = Object(external_react_["useContext"])(StoreContext),
        profilerStore = _useContext2.profilerStore;

  const _profilerStore$getDat = profilerStore.getDataForRoot(rootID),
        commitData = _profilerStore$getDat.commitData;

  const commitDurations = [];
  const commitTimes = [];
  commitData.forEach(commitDatum => {
    commitDurations.push(commitDatum.duration);
    commitTimes.push(commitDatum.timestamp);
  });
  const filteredCommitIndices = Object(external_react_["useMemo"])(() => commitData.reduce((reduced, commitDatum, index) => {
    if (!isCommitFilterEnabled || commitDatum.duration >= minCommitDuration) {
      reduced.push(index);
    }

    return reduced;
  }, []), [commitData, isCommitFilterEnabled, minCommitDuration]);
  const numFilteredCommits = filteredCommitIndices.length; // Map the (unfiltered) selected commit index to an index within the filtered data.

  const selectedFilteredCommitIndex = Object(external_react_["useMemo"])(() => {
    if (selectedCommitIndex !== null) {
      for (let i = 0; i < filteredCommitIndices.length; i++) {
        if (filteredCommitIndices[i] === selectedCommitIndex) {
          return i;
        }
      }
    }

    return null;
  }, [filteredCommitIndices, selectedCommitIndex]); // TODO (ProfilerContext) This should be managed by the context controller (reducer).
  // It doesn't currently know about the filtered commits though (since it doesn't suspend).
  // Maybe this component should pass filteredCommitIndices up?

  if (selectedFilteredCommitIndex === null) {
    if (numFilteredCommits > 0) {
      selectCommitIndex(0);
    } else {
      selectCommitIndex(null);
    }
  } else if (selectedFilteredCommitIndex >= numFilteredCommits) {
    selectCommitIndex(numFilteredCommits === 0 ? null : numFilteredCommits - 1);
  }

  let label = null;

  if (numFilteredCommits > 0) {
    label = `${selectedFilteredCommitIndex + 1}`.padStart(`${numFilteredCommits}`.length, '0') + ' / ' + numFilteredCommits;
  }

  const viewNextCommit = Object(external_react_["useCallback"])(() => {
    let nextCommitIndex = selectedFilteredCommitIndex + 1;

    if (nextCommitIndex === filteredCommitIndices.length) {
      nextCommitIndex = 0;
    }

    selectCommitIndex(filteredCommitIndices[nextCommitIndex]);
  }, [selectedFilteredCommitIndex, filteredCommitIndices, selectCommitIndex]);
  const viewPrevCommit = Object(external_react_["useCallback"])(() => {
    let nextCommitIndex = selectedFilteredCommitIndex - 1;

    if (nextCommitIndex < 0) {
      nextCommitIndex = filteredCommitIndices.length - 1;
    }

    selectCommitIndex(filteredCommitIndices[nextCommitIndex]);
  }, [selectedFilteredCommitIndex, filteredCommitIndices, selectCommitIndex]);
  const handleKeyDown = Object(external_react_["useCallback"])(event => {
    switch (event.key) {
      case 'ArrowLeft':
        viewPrevCommit();
        event.stopPropagation();
        break;

      case 'ArrowRight':
        viewNextCommit();
        event.stopPropagation();
        break;

      default:
        break;
    }
  }, [viewNextCommit, viewPrevCommit]);

  if (commitData.length === 0) {
    return null;
  }

  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("span", {
    className: SnapshotSelector_default.a.IndexLabel
  }, label), /*#__PURE__*/external_react_["createElement"](Button_Button, {
    className: SnapshotSelector_default.a.Button,
    disabled: numFilteredCommits === 0,
    onClick: viewPrevCommit,
    title: "Select previous commit"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "previous"
  })), /*#__PURE__*/external_react_["createElement"]("div", {
    className: SnapshotSelector_default.a.Commits,
    onKeyDown: handleKeyDown,
    style: {
      flex: numFilteredCommits > 0 ? '1 1 auto' : '0 0 auto',
      maxWidth: numFilteredCommits > 0 ? numFilteredCommits * maxBarWidth : undefined
    },
    tabIndex: 0
  }, numFilteredCommits > 0 && /*#__PURE__*/external_react_["createElement"](SnapshotCommitList_SnapshotCommitList, {
    commitDurations: commitDurations,
    commitTimes: commitTimes,
    filteredCommitIndices: filteredCommitIndices,
    selectedCommitIndex: selectedCommitIndex,
    selectedFilteredCommitIndex: selectedFilteredCommitIndex,
    selectCommitIndex: selectCommitIndex
  }), numFilteredCommits === 0 && /*#__PURE__*/external_react_["createElement"]("div", {
    className: SnapshotSelector_default.a.NoCommits
  }, "No commits")), /*#__PURE__*/external_react_["createElement"](Button_Button, {
    className: SnapshotSelector_default.a.Button,
    disabled: numFilteredCommits === 0,
    onClick: viewNextCommit,
    title: "Select next commit"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "next"
  })));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/SidebarCommitInfo.css
var SidebarCommitInfo = __webpack_require__(15);
var SidebarCommitInfo_default = /*#__PURE__*/__webpack_require__.n(SidebarCommitInfo);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/SidebarCommitInfo.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */






function SidebarCommitInfo_SidebarCommitInfo(_) {
  const _useContext = Object(external_react_["useContext"])(ProfilerContext),
        selectedCommitIndex = _useContext.selectedCommitIndex,
        rootID = _useContext.rootID,
        selectInteraction = _useContext.selectInteraction,
        selectTab = _useContext.selectTab;

  const _useContext2 = Object(external_react_["useContext"])(StoreContext),
        profilerStore = _useContext2.profilerStore;

  if (rootID === null || selectedCommitIndex === null) {
    return /*#__PURE__*/external_react_["createElement"]("div", {
      className: SidebarCommitInfo_default.a.NothingSelected
    }, "Nothing selected");
  }

  const _profilerStore$getDat = profilerStore.getDataForRoot(rootID),
        interactions = _profilerStore$getDat.interactions;

  const _profilerStore$getCom = profilerStore.getCommitData(rootID, selectedCommitIndex),
        duration = _profilerStore$getCom.duration,
        interactionIDs = _profilerStore$getCom.interactionIDs,
        priorityLevel = _profilerStore$getCom.priorityLevel,
        timestamp = _profilerStore$getCom.timestamp;

  const viewInteraction = interactionID => {
    selectTab('interactions');
    selectInteraction(interactionID);
  };

  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("div", {
    className: SidebarCommitInfo_default.a.Toolbar
  }, "Commit information"), /*#__PURE__*/external_react_["createElement"]("div", {
    className: SidebarCommitInfo_default.a.Content
  }, /*#__PURE__*/external_react_["createElement"]("ul", {
    className: SidebarCommitInfo_default.a.List
  }, priorityLevel !== null && /*#__PURE__*/external_react_["createElement"]("li", {
    className: SidebarCommitInfo_default.a.ListItem
  }, /*#__PURE__*/external_react_["createElement"]("label", {
    className: SidebarCommitInfo_default.a.Label
  }, "Priority"), ":", ' ', /*#__PURE__*/external_react_["createElement"]("span", {
    className: SidebarCommitInfo_default.a.Value
  }, priorityLevel)), /*#__PURE__*/external_react_["createElement"]("li", {
    className: SidebarCommitInfo_default.a.ListItem
  }, /*#__PURE__*/external_react_["createElement"]("label", {
    className: SidebarCommitInfo_default.a.Label
  }, "Committed at"), ":", ' ', /*#__PURE__*/external_react_["createElement"]("span", {
    className: SidebarCommitInfo_default.a.Value
  }, formatTime(timestamp), "s")), /*#__PURE__*/external_react_["createElement"]("li", {
    className: SidebarCommitInfo_default.a.ListItem
  }, /*#__PURE__*/external_react_["createElement"]("label", {
    className: SidebarCommitInfo_default.a.Label
  }, "Render duration"), ":", ' ', /*#__PURE__*/external_react_["createElement"]("span", {
    className: SidebarCommitInfo_default.a.Value
  }, formatDuration(duration), "ms")), /*#__PURE__*/external_react_["createElement"]("li", {
    className: SidebarCommitInfo_default.a.Interactions
  }, /*#__PURE__*/external_react_["createElement"]("label", {
    className: SidebarCommitInfo_default.a.Label
  }, "Interactions"), ":", /*#__PURE__*/external_react_["createElement"]("div", {
    className: SidebarCommitInfo_default.a.InteractionList
  }, interactionIDs.length === 0 ? /*#__PURE__*/external_react_["createElement"]("div", {
    className: SidebarCommitInfo_default.a.NoInteractions
  }, "None") : null, interactionIDs.map(interactionID => {
    const interaction = interactions.get(interactionID);

    if (interaction == null) {
      throw Error(`Invalid interaction "${interactionID}"`);
    }

    return /*#__PURE__*/external_react_["createElement"]("button", {
      key: interactionID,
      className: SidebarCommitInfo_default.a.Interaction,
      onClick: () => viewInteraction(interactionID)
    }, interaction.name);
  }))))));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/SidebarInteractions.css
var SidebarInteractions = __webpack_require__(33);
var SidebarInteractions_default = /*#__PURE__*/__webpack_require__.n(SidebarInteractions);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/SidebarInteractions.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */







function SidebarInteractions_SidebarInteractions(_) {
  const _useContext = Object(external_react_["useContext"])(ProfilerContext),
        selectedInteractionID = _useContext.selectedInteractionID,
        rootID = _useContext.rootID,
        selectCommitIndex = _useContext.selectCommitIndex,
        selectTab = _useContext.selectTab;

  const _useContext2 = Object(external_react_["useContext"])(StoreContext),
        profilerStore = _useContext2.profilerStore;

  const profilingCache = profilerStore.profilingCache;

  if (selectedInteractionID === null) {
    return /*#__PURE__*/external_react_["createElement"]("div", {
      className: SidebarInteractions_default.a.NothingSelected
    }, "Nothing selected");
  }

  const _profilerStore$getDat = profilerStore.getDataForRoot(rootID),
        interactionCommits = _profilerStore$getDat.interactionCommits,
        interactions = _profilerStore$getDat.interactions;

  const interaction = interactions.get(selectedInteractionID);

  if (interaction == null) {
    throw Error(`Could not find interaction by selected interaction id "${selectedInteractionID}"`);
  }

  const _profilingCache$getIn = profilingCache.getInteractionsChartData({
    rootID: rootID
  }),
        maxCommitDuration = _profilingCache$getIn.maxCommitDuration;

  const viewCommit = commitIndex => {
    selectTab('flame-chart');
    selectCommitIndex(commitIndex);
  };

  const listItems = [];
  const commitIndices = interactionCommits.get(selectedInteractionID);

  if (commitIndices != null) {
    commitIndices.forEach(commitIndex => {
      const _profilerStore$getCom = profilerStore.getCommitData(rootID, commitIndex),
            duration = _profilerStore$getCom.duration,
            timestamp = _profilerStore$getCom.timestamp;

      listItems.push( /*#__PURE__*/external_react_["createElement"]("li", {
        key: commitIndex,
        className: SidebarInteractions_default.a.ListItem,
        onClick: () => viewCommit(commitIndex)
      }, /*#__PURE__*/external_react_["createElement"]("div", {
        className: SidebarInteractions_default.a.CommitBox,
        style: {
          backgroundColor: getGradientColor(Math.min(1, Math.max(0, duration / maxCommitDuration)) || 0)
        }
      }), /*#__PURE__*/external_react_["createElement"]("div", null, "timestamp: ", formatTime(timestamp), "s", /*#__PURE__*/external_react_["createElement"]("br", null), "duration: ", formatDuration(duration), "ms")));
    });
  }

  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("div", {
    className: SidebarInteractions_default.a.Toolbar
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: SidebarInteractions_default.a.Name,
    title: interaction.name
  }, interaction.name)), /*#__PURE__*/external_react_["createElement"]("div", {
    className: SidebarInteractions_default.a.Content
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: SidebarInteractions_default.a.Commits
  }, "Commits:"), /*#__PURE__*/external_react_["createElement"]("ul", {
    className: SidebarInteractions_default.a.List
  }, listItems)));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/SidebarSelectedFiberInfo.css
var SidebarSelectedFiberInfo = __webpack_require__(35);
var SidebarSelectedFiberInfo_default = /*#__PURE__*/__webpack_require__.n(SidebarSelectedFiberInfo);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/SidebarSelectedFiberInfo.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */









function SidebarSelectedFiberInfo_SidebarSelectedFiberInfo(_) {
  const _useContext = Object(external_react_["useContext"])(StoreContext),
        profilerStore = _useContext.profilerStore;

  const _useContext2 = Object(external_react_["useContext"])(ProfilerContext),
        rootID = _useContext2.rootID,
        selectCommitIndex = _useContext2.selectCommitIndex,
        selectedCommitIndex = _useContext2.selectedCommitIndex,
        selectedFiberID = _useContext2.selectedFiberID,
        selectedFiberName = _useContext2.selectedFiberName,
        selectFiber = _useContext2.selectFiber;

  const profilingCache = profilerStore.profilingCache;
  const selectedListItemRef = Object(external_react_["useRef"])(null);
  const commitIndices = profilingCache.getFiberCommits({
    fiberID: selectedFiberID,
    rootID: rootID
  });

  const handleKeyDown = event => {
    switch (event.key) {
      case 'ArrowUp':
        if (selectedCommitIndex !== null) {
          const prevIndex = commitIndices.indexOf(selectedCommitIndex);
          const nextIndex = prevIndex > 0 ? prevIndex - 1 : commitIndices.length - 1;
          selectCommitIndex(commitIndices[nextIndex]);
        }

        event.preventDefault();
        break;

      case 'ArrowDown':
        if (selectedCommitIndex !== null) {
          const prevIndex = commitIndices.indexOf(selectedCommitIndex);
          const nextIndex = prevIndex < commitIndices.length - 1 ? prevIndex + 1 : 0;
          selectCommitIndex(commitIndices[nextIndex]);
        }

        event.preventDefault();
        break;

      default:
        break;
    }
  };

  Object(external_react_["useEffect"])(() => {
    const selectedElement = selectedListItemRef.current;

    if (selectedElement !== null && typeof selectedElement.scrollIntoView === 'function') {
      selectedElement.scrollIntoView({
        block: 'nearest',
        inline: 'nearest'
      });
    }
  }, [selectedCommitIndex]);
  const listItems = [];
  let i = 0;

  for (i = 0; i < commitIndices.length; i++) {
    const commitIndex = commitIndices[i];

    const _profilerStore$getCom = profilerStore.getCommitData(rootID, commitIndex),
          duration = _profilerStore$getCom.duration,
          timestamp = _profilerStore$getCom.timestamp;

    listItems.push( /*#__PURE__*/external_react_["createElement"]("button", {
      key: commitIndex,
      ref: selectedCommitIndex === commitIndex ? selectedListItemRef : null,
      className: selectedCommitIndex === commitIndex ? SidebarSelectedFiberInfo_default.a.CurrentCommit : SidebarSelectedFiberInfo_default.a.Commit,
      onClick: () => selectCommitIndex(commitIndex)
    }, formatTime(timestamp), "s for ", formatDuration(duration), "ms"));
  }

  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("div", {
    className: SidebarSelectedFiberInfo_default.a.Toolbar
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: SidebarSelectedFiberInfo_default.a.Component
  }, selectedFiberName || 'Selected component'), /*#__PURE__*/external_react_["createElement"](Button_Button, {
    className: SidebarSelectedFiberInfo_default.a.IconButton,
    onClick: () => selectFiber(null, null),
    title: "Back to commit view"
  }, /*#__PURE__*/external_react_["createElement"](ButtonIcon_ButtonIcon, {
    type: "close"
  }))), /*#__PURE__*/external_react_["createElement"]("div", {
    className: SidebarSelectedFiberInfo_default.a.Content,
    onKeyDown: handleKeyDown,
    tabIndex: 0
  }, /*#__PURE__*/external_react_["createElement"](WhatChanged_WhatChanged, {
    fiberID: selectedFiberID
  }), listItems.length > 0 && /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("label", {
    className: SidebarSelectedFiberInfo_default.a.Label
  }, "Rendered at"), ": ", listItems), listItems.length === 0 && /*#__PURE__*/external_react_["createElement"]("div", null, "Did not render during this profiling session.")));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/Profiler/Profiler.css
var Profiler = __webpack_require__(11);
var Profiler_default = /*#__PURE__*/__webpack_require__.n(Profiler);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/Profiler/Profiler.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
























function Profiler_Profiler(_) {
  const _useContext = Object(external_react_["useContext"])(ProfilerContext),
        didRecordCommits = _useContext.didRecordCommits,
        isProcessingData = _useContext.isProcessingData,
        isProfiling = _useContext.isProfiling,
        selectedCommitIndex = _useContext.selectedCommitIndex,
        selectedFiberID = _useContext.selectedFiberID,
        selectedTabID = _useContext.selectedTabID,
        selectTab = _useContext.selectTab,
        supportsProfiling = _useContext.supportsProfiling;

  let view = null;

  if (didRecordCommits) {
    switch (selectedTabID) {
      case 'flame-chart':
        view = /*#__PURE__*/external_react_["createElement"](CommitFlamegraphAutoSizer, null);
        break;

      case 'ranked-chart':
        view = /*#__PURE__*/external_react_["createElement"](CommitRankedAutoSizer, null);
        break;

      case 'interactions':
        view = /*#__PURE__*/external_react_["createElement"](InteractionsAutoSizer, null);
        break;

      default:
        break;
    }
  } else if (isProfiling) {
    view = /*#__PURE__*/external_react_["createElement"](RecordingInProgress, null);
  } else if (isProcessingData) {
    view = /*#__PURE__*/external_react_["createElement"](ProcessingData, null);
  } else if (supportsProfiling) {
    view = /*#__PURE__*/external_react_["createElement"](NoProfilingData, null);
  } else {
    view = /*#__PURE__*/external_react_["createElement"](ProfilingNotSupported, null);
  }

  let sidebar = null;

  if (!isProfiling && !isProcessingData && didRecordCommits) {
    switch (selectedTabID) {
      case 'interactions':
        sidebar = /*#__PURE__*/external_react_["createElement"](SidebarInteractions_SidebarInteractions, null);
        break;

      case 'flame-chart':
      case 'ranked-chart':
        // TRICKY
        // Handle edge case where no commit is selected because of a min-duration filter update.
        // In that case, the selected commit index would be null.
        // We could still show a sidebar for the previously selected fiber,
        // but it would be an odd user experience.
        // TODO (ProfilerContext) This check should not be necessary.
        if (selectedCommitIndex !== null) {
          if (selectedFiberID !== null) {
            sidebar = /*#__PURE__*/external_react_["createElement"](SidebarSelectedFiberInfo_SidebarSelectedFiberInfo, null);
          } else {
            sidebar = /*#__PURE__*/external_react_["createElement"](SidebarCommitInfo_SidebarCommitInfo, null);
          }
        }

        break;

      default:
        break;
    }
  }

  return /*#__PURE__*/external_react_["createElement"](SettingsModalContextController, null, /*#__PURE__*/external_react_["createElement"]("div", {
    className: Profiler_default.a.Profiler
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: Profiler_default.a.LeftColumn
  }, /*#__PURE__*/external_react_["createElement"]("div", {
    className: Profiler_default.a.Toolbar
  }, /*#__PURE__*/external_react_["createElement"](RecordToggle_RecordToggle, {
    disabled: !supportsProfiling
  }), /*#__PURE__*/external_react_["createElement"](ReloadAndProfileButton, null), /*#__PURE__*/external_react_["createElement"](ClearProfilingDataButton, null), /*#__PURE__*/external_react_["createElement"](ProfilingImportExportButtons_ProfilingImportExportButtons, null), /*#__PURE__*/external_react_["createElement"]("div", {
    className: Profiler_default.a.VRule
  }), /*#__PURE__*/external_react_["createElement"](TabBar_TabBar, {
    currentTab: selectedTabID,
    id: "Profiler",
    selectTab: selectTab,
    tabs: Profiler_tabs,
    type: "profiler"
  }), /*#__PURE__*/external_react_["createElement"](RootSelector_RootSelector, null), /*#__PURE__*/external_react_["createElement"]("div", {
    className: Profiler_default.a.Spacer
  }), /*#__PURE__*/external_react_["createElement"](SettingsModalContextToggle, null), didRecordCommits && /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("div", {
    className: Profiler_default.a.VRule
  }), /*#__PURE__*/external_react_["createElement"](SnapshotSelector_SnapshotSelector, null))), /*#__PURE__*/external_react_["createElement"]("div", {
    className: Profiler_default.a.Content
  }, view, /*#__PURE__*/external_react_["createElement"](ModalDialog_ModalDialog, null))), /*#__PURE__*/external_react_["createElement"]("div", {
    className: Profiler_default.a.RightColumn
  }, sidebar), /*#__PURE__*/external_react_["createElement"](SettingsModal_SettingsModal, null)));
}

const Profiler_tabs = [{
  id: 'flame-chart',
  icon: 'flame-chart',
  label: 'Flamegraph',
  title: 'Flamegraph chart'
}, {
  id: 'ranked-chart',
  icon: 'ranked-chart',
  label: 'Ranked',
  title: 'Ranked chart'
}, {
  id: 'interactions',
  icon: 'interactions',
  label: 'Interactions',
  title: 'Profiled interactions'
}];

const NoProfilingData = () => /*#__PURE__*/external_react_["createElement"]("div", {
  className: Profiler_default.a.Column
}, /*#__PURE__*/external_react_["createElement"]("div", {
  className: Profiler_default.a.Header
}, "No profiling data has been recorded."), /*#__PURE__*/external_react_["createElement"]("div", {
  className: Profiler_default.a.Row
}, "Click the record button ", /*#__PURE__*/external_react_["createElement"](RecordToggle_RecordToggle, null), " to start recording."));

const ProfilingNotSupported = () => /*#__PURE__*/external_react_["createElement"]("div", {
  className: Profiler_default.a.Column
}, /*#__PURE__*/external_react_["createElement"]("div", {
  className: Profiler_default.a.Header
}, "Profiling not supported."), /*#__PURE__*/external_react_["createElement"]("p", {
  className: Profiler_default.a.Paragraph
}, "Profiling support requires either a development or production-profiling build of React v16.5+."), /*#__PURE__*/external_react_["createElement"]("p", {
  className: Profiler_default.a.Paragraph
}, "Learn more at", ' ', /*#__PURE__*/external_react_["createElement"]("a", {
  className: Profiler_default.a.Link,
  href: "https://reactjs.org/link/profiling",
  rel: "noopener noreferrer",
  target: "_blank"
}, "reactjs.org/link/profiling"), "."));

const ProcessingData = () => /*#__PURE__*/external_react_["createElement"]("div", {
  className: Profiler_default.a.Column
}, /*#__PURE__*/external_react_["createElement"]("div", {
  className: Profiler_default.a.Header
}, "Processing data..."), /*#__PURE__*/external_react_["createElement"]("div", {
  className: Profiler_default.a.Row
}, "This should only take a minute."));

const RecordingInProgress = () => /*#__PURE__*/external_react_["createElement"]("div", {
  className: Profiler_default.a.Column
}, /*#__PURE__*/external_react_["createElement"]("div", {
  className: Profiler_default.a.Header
}, "Profiling is in progress..."), /*#__PURE__*/external_react_["createElement"]("div", {
  className: Profiler_default.a.Row
}, "Click the record button ", /*#__PURE__*/external_react_["createElement"](RecordToggle_RecordToggle, null), " to stop recording."));

function Profiler_onErrorRetry(store) {
  // If an error happened in the Profiler,
  // we should clear data on retry (or it will just happen again).
  store.profilerStore.profilingData = null;
}

/* harmony default export */ var views_Profiler_Profiler = (portaledContent(Profiler_Profiler, Profiler_onErrorRetry));
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/ReactLogo.css
var ReactLogo = __webpack_require__(89);
var ReactLogo_default = /*#__PURE__*/__webpack_require__.n(ReactLogo);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/ReactLogo.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


function ReactLogo_ReactLogo({
  className
}) {
  return /*#__PURE__*/external_react_["createElement"]("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    className: `${ReactLogo_default.a.ReactLogo} ${className || ''}`,
    viewBox: "-11.5 -10.23174 23 20.46348"
  }, /*#__PURE__*/external_react_["createElement"]("circle", {
    cx: "0",
    cy: "0",
    r: "2.05",
    fill: "currentColor"
  }), /*#__PURE__*/external_react_["createElement"]("g", {
    stroke: "currentColor",
    strokeWidth: "1",
    fill: "none"
  }, /*#__PURE__*/external_react_["createElement"]("ellipse", {
    rx: "11",
    ry: "4.2"
  }), /*#__PURE__*/external_react_["createElement"]("ellipse", {
    rx: "11",
    ry: "4.2",
    transform: "rotate(60)"
  }), /*#__PURE__*/external_react_["createElement"]("ellipse", {
    rx: "11",
    ry: "4.2",
    transform: "rotate(120)"
  })));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/UnsupportedVersionDialog.css
var UnsupportedVersionDialog = __webpack_require__(63);
var UnsupportedVersionDialog_default = /*#__PURE__*/__webpack_require__.n(UnsupportedVersionDialog);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/UnsupportedVersionDialog.js
function UnsupportedVersionDialog_slicedToArray(arr, i) { return UnsupportedVersionDialog_arrayWithHoles(arr) || UnsupportedVersionDialog_iterableToArrayLimit(arr, i) || UnsupportedVersionDialog_unsupportedIterableToArray(arr, i) || UnsupportedVersionDialog_nonIterableRest(); }

function UnsupportedVersionDialog_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function UnsupportedVersionDialog_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return UnsupportedVersionDialog_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return UnsupportedVersionDialog_arrayLikeToArray(o, minLen); }

function UnsupportedVersionDialog_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function UnsupportedVersionDialog_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function UnsupportedVersionDialog_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */







function UnsupportedVersionDialog_UnsupportedVersionDialog(_) {
  const _useContext = Object(external_react_["useContext"])(ModalDialogContext),
        dispatch = _useContext.dispatch;

  const store = Object(external_react_["useContext"])(StoreContext);

  const _useState = Object(external_react_["useState"])('dialog-not-shown'),
        _useState2 = UnsupportedVersionDialog_slicedToArray(_useState, 2),
        state = _useState2[0],
        setState = _useState2[1];

  Object(external_react_["useEffect"])(() => {
    if (state === 'dialog-not-shown') {
      const showDialog = () => {
        Object(external_react_dom_["unstable_batchedUpdates"])(() => {
          setState('show-dialog');
          dispatch({
            canBeDismissed: true,
            type: 'SHOW',
            content: /*#__PURE__*/external_react_["createElement"](DialogContent, null)
          });
        });
      };

      if (store.unsupportedRendererVersionDetected) {
        showDialog();
      } else {
        store.addListener('unsupportedRendererVersionDetected', showDialog);
        return () => {
          store.removeListener('unsupportedRendererVersionDetected', showDialog);
        };
      }
    }
  }, [state, store]);
  return null;
}

function DialogContent(_) {
  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("div", {
    className: UnsupportedVersionDialog_default.a.Row
  }, /*#__PURE__*/external_react_["createElement"]("div", null, /*#__PURE__*/external_react_["createElement"]("div", {
    className: UnsupportedVersionDialog_default.a.Title
  }, "Unsupported React version detected"), /*#__PURE__*/external_react_["createElement"]("p", null, "This version of React DevTools supports React DOM v15+ and React Native v61+."), /*#__PURE__*/external_react_["createElement"]("p", null, "In order to use DevTools with an older version of React, you'll need to", ' ', /*#__PURE__*/external_react_["createElement"]("a", {
    className: UnsupportedVersionDialog_default.a.ReleaseNotesLink,
    target: "_blank",
    rel: "noopener noreferrer",
    href: constants["p" /* UNSUPPORTED_VERSION_URL */]
  }, "install an older version of the extension"), "."))));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/WarnIfLegacyBackendDetected.css
var WarnIfLegacyBackendDetected = __webpack_require__(90);
var WarnIfLegacyBackendDetected_default = /*#__PURE__*/__webpack_require__.n(WarnIfLegacyBackendDetected);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/WarnIfLegacyBackendDetected.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */





function WarnIfLegacyBackendDetected_WarnIfLegacyBackendDetected(_) {
  const bridge = Object(external_react_["useContext"])(BridgeContext);

  const _useContext = Object(external_react_["useContext"])(ModalDialogContext),
        dispatch = _useContext.dispatch; // Detect pairing with legacy v3 backend.
  // We do this by listening to a message that it broadcasts but the v4 backend doesn't.
  // In this case the frontend should show upgrade instructions.


  Object(external_react_["useEffect"])(() => {
    // Wall.listen returns a cleanup function
    let unlisten = bridge.wall.listen(message => {
      switch (message.type) {
        case 'call':
        case 'event':
        case 'many-events':
          // Any of these types indicate the v3 backend.
          dispatch({
            canBeDismissed: false,
            type: 'SHOW',
            title: 'DevTools v4 is incompatible with this version of React',
            content: /*#__PURE__*/external_react_["createElement"](InvalidBackendDetected, null)
          }); // Once we've identified the backend version, it's safe to unsubscribe.

          if (typeof unlisten === 'function') {
            unlisten();
            unlisten = null;
          }

          break;

        default:
          break;
      }

      switch (message.event) {
        case 'isBackendStorageAPISupported':
        case 'isNativeStyleEditorSupported':
        case 'operations':
        case 'overrideComponentFilters':
          // Any of these is sufficient to indicate a v4 backend.
          // Once we've identified the backend version, it's safe to unsubscribe.
          if (typeof unlisten === 'function') {
            unlisten();
            unlisten = null;
          }

          break;

        default:
          break;
      }
    });
    return () => {
      if (typeof unlisten === 'function') {
        unlisten();
        unlisten = null;
      }
    };
  }, [bridge, dispatch]);
  return null;
}

function InvalidBackendDetected(_) {
  return /*#__PURE__*/external_react_["createElement"](external_react_["Fragment"], null, /*#__PURE__*/external_react_["createElement"]("p", null, "Either upgrade React or install React DevTools v3:"), /*#__PURE__*/external_react_["createElement"]("code", {
    className: WarnIfLegacyBackendDetected_default.a.Command
  }, "npm install -d react-devtools@^3"));
}
// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/DevTools.css
var DevTools = __webpack_require__(40);
var DevTools_default = /*#__PURE__*/__webpack_require__.n(DevTools);

// EXTERNAL MODULE: ../react-devtools-shared/src/devtools/views/root.css
var root = __webpack_require__(158);

// CONCATENATED MODULE: ../react-devtools-shared/src/devtools/views/DevTools.js
function DevTools_slicedToArray(arr, i) { return DevTools_arrayWithHoles(arr) || DevTools_iterableToArrayLimit(arr, i) || DevTools_unsupportedIterableToArray(arr, i) || DevTools_nonIterableRest(); }

function DevTools_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function DevTools_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return DevTools_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return DevTools_arrayLikeToArray(o, minLen); }

function DevTools_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function DevTools_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function DevTools_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// Reach styles need to come before any component styles.
// This makes overriding the styles simpler.




















const componentsTab = {
  id: 'components',
  icon: 'components',
  label: 'Components',
  title: 'React Components'
};
const profilerTab = {
  id: 'profiler',
  icon: 'profiler',
  label: 'Profiler',
  title: 'React Profiler'
};
const DevTools_tabs = [componentsTab, profilerTab];
function DevTools_DevTools({
  bridge,
  browserTheme = 'light',
  canViewElementSourceFunction,
  componentsPortalContainer,
  defaultTab = 'components',
  enabledInspectedElementContextMenu = false,
  overrideTab,
  profilerPortalContainer,
  showTabBar = false,
  store,
  warnIfLegacyBackendDetected = false,
  warnIfUnsupportedVersionDetected = false,
  viewAttributeSourceFunction,
  viewElementSourceFunction
}) {
  const _useLocalStorage = useLocalStorage('React::DevTools::defaultTab', defaultTab),
        _useLocalStorage2 = DevTools_slicedToArray(_useLocalStorage, 2),
        currentTab = _useLocalStorage2[0],
        setTab = _useLocalStorage2[1];

  let tab = currentTab;

  if (overrideTab != null) {
    tab = overrideTab;
  }

  const viewElementSource = Object(external_react_["useMemo"])(() => ({
    canViewElementSourceFunction: canViewElementSourceFunction || null,
    viewElementSourceFunction: viewElementSourceFunction || null
  }), [canViewElementSourceFunction, viewElementSourceFunction]);
  const contextMenu = Object(external_react_["useMemo"])(() => ({
    isEnabledForInspectedElement: enabledInspectedElementContextMenu,
    viewAttributeSourceFunction: viewAttributeSourceFunction || null
  }), [enabledInspectedElementContextMenu, viewAttributeSourceFunction]);
  const devToolsRef = Object(external_react_["useRef"])(null);
  Object(external_react_["useEffect"])(() => {
    if (!showTabBar) {
      return;
    }

    const div = devToolsRef.current;

    if (div === null) {
      return;
    }

    const ownerWindow = div.ownerDocument.defaultView;

    const handleKeyDown = event => {
      if (event.ctrlKey || event.metaKey) {
        switch (event.key) {
          case '1':
            setTab(DevTools_tabs[0].id);
            event.preventDefault();
            event.stopPropagation();
            break;

          case '2':
            setTab(DevTools_tabs[1].id);
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
    };

    ownerWindow.addEventListener('keydown', handleKeyDown);
    return () => {
      ownerWindow.removeEventListener('keydown', handleKeyDown);
    };
  }, [showTabBar]);
  Object(external_react_["useLayoutEffect"])(() => {
    return () => {
      try {
        // Shut the Bridge down synchronously (during unmount).
        bridge.shutdown();
      } catch (error) {// Attempting to use a disconnected port.
      }
    };
  }, [bridge]);
  return /*#__PURE__*/external_react_["createElement"](BridgeContext.Provider, {
    value: bridge
  }, /*#__PURE__*/external_react_["createElement"](StoreContext.Provider, {
    value: store
  }, /*#__PURE__*/external_react_["createElement"](ContextMenuContext.Provider, {
    value: contextMenu
  }, /*#__PURE__*/external_react_["createElement"](ModalDialogContextController, null, /*#__PURE__*/external_react_["createElement"](SettingsContextController, {
    browserTheme: browserTheme,
    componentsPortalContainer: componentsPortalContainer,
    profilerPortalContainer: profilerPortalContainer
  }, /*#__PURE__*/external_react_["createElement"](Components_ViewElementSourceContext.Provider, {
    value: viewElementSource
  }, /*#__PURE__*/external_react_["createElement"](TreeContextController, null, /*#__PURE__*/external_react_["createElement"](ProfilerContextController, null, /*#__PURE__*/external_react_["createElement"]("div", {
    className: DevTools_default.a.DevTools,
    ref: devToolsRef
  }, showTabBar && /*#__PURE__*/external_react_["createElement"]("div", {
    className: DevTools_default.a.TabBar
  }, /*#__PURE__*/external_react_["createElement"](ReactLogo_ReactLogo, null), /*#__PURE__*/external_react_["createElement"]("span", {
    className: DevTools_default.a.DevToolsVersion
  }, "4.10.1-3a8c04e3b2"), /*#__PURE__*/external_react_["createElement"]("div", {
    className: DevTools_default.a.Spacer
  }), /*#__PURE__*/external_react_["createElement"](TabBar_TabBar, {
    currentTab: tab,
    id: "DevTools",
    selectTab: setTab,
    tabs: DevTools_tabs,
    type: "navigation"
  })), /*#__PURE__*/external_react_["createElement"]("div", {
    className: DevTools_default.a.TabContent,
    hidden: tab !== 'components'
  }, /*#__PURE__*/external_react_["createElement"](views_Components_Components, {
    portalContainer: componentsPortalContainer
  })), /*#__PURE__*/external_react_["createElement"]("div", {
    className: DevTools_default.a.TabContent,
    hidden: tab !== 'profiler'
  }, /*#__PURE__*/external_react_["createElement"](views_Profiler_Profiler, {
    portalContainer: profilerPortalContainer
  }))))))), warnIfLegacyBackendDetected && /*#__PURE__*/external_react_["createElement"](WarnIfLegacyBackendDetected_WarnIfLegacyBackendDetected, null), warnIfUnsupportedVersionDetected && /*#__PURE__*/external_react_["createElement"](UnsupportedVersionDialog_UnsupportedVersionDialog, null)))));
}
// EXTERNAL MODULE: ./src/constants.js
var src_constants = __webpack_require__(38);

// CONCATENATED MODULE: ./src/frontend.js
function frontend_extends() { frontend_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return frontend_extends.apply(this, arguments); }








function initialize(contentWindow) {
  const onGetSavedPreferencesMessage = ({
    data,
    source
  }) => {
    if (source === 'react-devtools-content-script') {// Ignore messages from the DevTools browser extension.
    }

    switch (data.type) {
      case src_constants["a" /* MESSAGE_TYPE_GET_SAVED_PREFERENCES */]:
        // This is the only message we're listening for,
        // so it's safe to cleanup after we've received it.
        window.removeEventListener('message', onGetSavedPreferencesMessage); // The renderer interface can't read saved preferences directly,
        // because they are stored in localStorage within the context of the extension.
        // Instead it relies on the extension to pass them through.

        contentWindow.postMessage({
          type: src_constants["b" /* MESSAGE_TYPE_SAVED_PREFERENCES */],
          appendComponentStack: Object(utils["d" /* getAppendComponentStack */])(),
          breakOnConsoleErrors: Object(utils["e" /* getBreakOnConsoleErrors */])(),
          componentFilters: Object(utils["k" /* getSavedComponentFilters */])()
        }, '*');
        break;

      default:
        break;
    }
  };

  window.addEventListener('message', onGetSavedPreferencesMessage);
  const bridge = new src_bridge["a" /* default */]({
    listen(fn) {
      const onMessage = ({
        data
      }) => {
        fn(data);
      };

      window.addEventListener('message', onMessage);
      return () => {
        window.removeEventListener('message', onMessage);
      };
    },

    send(event, payload, transferable) {
      contentWindow.postMessage({
        event,
        payload
      }, '*', transferable);
    }

  });
  const store = new store_Store(bridge, {
    supportsTraceUpdates: true
  });
  const ForwardRef = /*#__PURE__*/Object(external_react_["forwardRef"])((props, ref) => /*#__PURE__*/external_react_["createElement"](DevTools_DevTools, frontend_extends({
    ref: ref,
    bridge: bridge,
    store: store
  }, props)));
  ForwardRef.displayName = 'DevTools';
  return ForwardRef;
}

/***/ })
/******/ ]);
//# sourceMappingURL=frontend.js.map

/***/ }),

/***/ "../../node_modules/react-devtools-inline/frontend.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("../../node_modules/react-devtools-inline/dist/frontend.js");


/***/ }),

/***/ "../../node_modules/react-is/cjs/react-is.production.min.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;
exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};
exports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};
exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;


/***/ }),

/***/ "../../node_modules/react-is/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__("../../node_modules/react-is/cjs/react-is.production.min.js");
} else {}


/***/ })

}]);